aspect MJTypeAnalysis {
    
    inh BodyDecl Pattern.hostBodyDecl();
    inh BodyDecl IteratorDecl.hostBodyDecl();
    eq IteratorDecl.getPattern().hostBodyDecl() = hostBodyDecl();
    eq IteratorDecl.getNestedPattern(int i).hostBodyDecl() = hostBodyDecl();
    eq StaticForMethodDecl.getIteratorDecl().hostBodyDecl() = this;
    eq StaticForConstructorDecl.getIteratorDecl().hostBodyDecl() = this;
    eq StaticForFieldDeclaration.getIteratorDecl().hostBodyDecl() = this;

    refine TypeAnalysis public TypeDecl ClassDecl.superclass() {
	if(isObject())
	    return null;
	if(hasSuperClassAccess() && !isCircular() &&
	   getSuperClassAccess().type().canbeSuperclass()) 
	    return getSuperClassAccess().type();
	return typeObject();
    }


    refine TypeAnalysis public Iterator ClassDecl.interfacesIterator() {
	return new Iterator() {
		public boolean hasNext() {
		    computeNextCurrent();
		    return current != null;
		}
		public Object next() {
		    return current;
		}
		public void remove() {
		    throw new UnsupportedOperationException();
		}
		private int index = 0;
		private TypeDecl current = null;
		private void computeNextCurrent() {
		    current = null;
		    if(isObject() || isCircular())
			return;
		    while(index < getNumImplements()) {
			TypeDecl typeDecl = getImplements(index++).type();
			if(!typeDecl.isCircular() && typeDecl.canbeSuperinterface()) {
			    current = typeDecl;
			    return;
			}
		    }
		}
	    };
    }
    
    refine TypeAnalysis public Iterator InterfaceDecl.superinterfacesIterator() {
	return new Iterator() {
		public boolean hasNext() {
		    computeNextCurrent();
		    return current != null;
		}
		public Object next() {
		    return current;
		}
		public void remove() {
		    throw new UnsupportedOperationException();
		}
		private int index = 0;
		private TypeDecl current = null;
		private void computeNextCurrent() {
		    current = null;
		    if(isCircular()) return;
		    while(index < getNumSuperInterfaceId()) {
			TypeDecl typeDecl = getSuperInterfaceId(index++).type();
			if(!typeDecl.isCircular() && typeDecl.canbeSuperinterface()) {
			    current = typeDecl;
			    return;
			}
		    }
		}
	    };
    }
}

aspect MJCircularity {
    // Each type has a chain of dependent types.
    syn lazy boolean TypeDecl.circularlyDefined(Set currentChain) = currentChain.contains(this);

    eq ClassDecl.circularlyDefined(Set currentChain) {
	if ( currentChain.contains(this)) return true;

	currentChain.add(this);

	if ( hasSuperclass())
	    if ( superclass().circularlyDefined(currentChain)) return true;
	for ( Iterator ifIt = interfacesIterator(); ifIt.hasNext(); ) {
	    if ( ((TypeDecl) ifIt.next()).circularlyDefined(currentChain))
		return true;
	}

	// add all the types this uses for reflective declaration.
	Collection rm = reflectiveMethods();
	for ( Iterator rmIt = rm.iterator(); rmIt.hasNext(); ) {
	    TypeDecl baseType = ((MethodDecl) rmIt.next()).reflectiveBaseType();
	    if ( baseType.circularlyDefined(currentChain))
		return true;
	}

	return false;
    }

    eq ParTypeDecl.circularlyDefined(Set currentChain) = genericDecl().circularlyDefined(currentChain);
	
    refine TypeAnalysis eq ClassDecl.isCircular() {
	if (TypeAnalysis.ClassDecl.isCircular()) return true;
	return circularlyDefined(new HashSet());
    }
    refine TypeAnalysis eq InterfaceDecl.isCircular() {
	if (TypeAnalysis.InterfaceDecl.isCircular()) return true;
	return circularlyDefined(new HashSet());
    }    

    // NonVoidType.
    eq NonVoidType.isSupertypeOfClassDecl(ClassDecl type) = true;
    eq NonVoidType.isSupertypeOfInterfaceDecl(InterfaceDecl type) = true;
    eq NonVoidType.isSupertypeOfArrayDecl(ArrayDecl type) = true;
    eq NonVoidType.isSupertypeOfPrimitiveType(PrimitiveType type) = true;
    eq NonVoidType.isSupertypeOfNullType(NullType type) = true;
    eq NonVoidType.isSupertypeOfVoidType(VoidType type) = false;

    eq NonVoidType.isClassDecl() = true;
    eq NonVoidType.isInterfaceDecl() = true;
    eq NonVoidType.erasure() = this;
    eq NonVoidType.accessibleFrom(TypeDecl type) = true;

    syn lazy boolean TypeDecl.isNonVoidType() = false;
    eq NonVoidType.isNonVoidType() = true;


    eq PatternTypeVariable.erasure() {
	if ( getTypeBound(0).type().isNonVoidType()) 
	    return this;
	return super.erasure();
    }

    refine GenericsParTypeDecl eq MethodDecl.visibleTypeParameters() = !isStatic() || hostType().needsExpansion();
    refine GenericsParTypeDecl eq FieldDeclaration.visibleTypeParameters() = !isStatic() || hostType().needsExpansion();
    refine GenericsParTypeDecl eq StaticInitializer.visibleTypeParameters() = hostType().needsExpansion();
    refine GenericsParTypeDecl eq MemberTypeDecl.visibleTypeParameters() = !isStatic() || hostType().needsExpansion();

    public boolean NonVoidType.isNestedType() { return false; }
    public void NonVoidType.java2Transformation() {}

}
