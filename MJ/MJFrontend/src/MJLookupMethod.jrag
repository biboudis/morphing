aspect MJLookupMethod {
    /**
     * JastAddJ uses a method signature map to store mappings from 
     * String (method signature) to MethodDecl.  This no longer works
     * for reflectively declared methods. We will keep the statically
     * declared methods the way they are. And use another data structure
     * for reflectively declared methods.
     **/

    syn lazy Collection<StaticForMethodDecl> TypeDecl.reflectiveMethods() {
	Set set = new HashSet();
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if ( getBodyDecl(i).isReflectiveDecl()  &&
		 getBodyDecl(i) instanceof MethodDecl )
		set.add((StaticForMethodDecl)getBodyDecl(i));
	}
	return set;
    }
    eq TypeVariable.reflectiveMethods() {
	Set set = new HashSet();
	for ( int i=0; i<getNumTypeBound(); i++) {
	    set.addAll(getTypeBound(i).type().reflectiveMethods());
	}
	return set;
    }
    eq ParTypeDecl.reflectiveMethods() {
	Collection<StaticForMethodDecl> refMethods = 
	    genericDecl().reflectiveMethods();
	Set<StaticForMethodDecl> substitutedMethods = new HashSet();
	for ( Iterator<StaticForMethodDecl> rmIt = refMethods.iterator(); rmIt.hasNext(); ) {
	    StaticForMethodDecl md = rmIt.next();
	    if ( md.usesTypeVariable()) {
		BodyDecl bd = md.p(this);
		bd.is$Final = true;
		addBodyDecl((StaticForMethodDecl)bd);
		substitutedMethods.add((StaticForMethodDecl)bd);
	    } else 
		substitutedMethods.add((StaticForMethodDecl)md);
	}
	return substitutedMethods;
    }

    refine LookupMethod eq ClassDecl.interfacesMethodsSignatureMap() {
	HashMap map = new HashMap();
	for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)iter.next();
	    for(Iterator i2 = typeDecl.methodsIterator(); i2.hasNext(); ) {
		MethodDecl m = (MethodDecl)i2.next();
		putSimpleSetElement(map, m.signature(), m);
	    }
	}
	return map;
    }

    refine LookupMethod eq TypeDecl.localMethodsSignatureMap() {
	HashMap map = new HashMap(getNumBodyDecl());
	for(int i = 0; i < getNumBodyDecl(); i++) {
	    if(getBodyDecl(i) instanceof MethodDecl) {
		if ( getBodyDecl(i) instanceof StaticForMethodDecl) {
		    StaticForMethodDecl decl = (StaticForMethodDecl) getBodyDecl(i);
		    if (decl.expandable()) {
			List<? extends MethodDecl> expandedMethods = decl.expandedMethods();
			for ( int j=0; j<expandedMethods.getNumChild(); j++) {
			    map.put(expandedMethods.getChild(j).signature(),
				    expandedMethods.getChild(j));
			}
		    }
		} else {
		    MethodDecl decl = (MethodDecl)getBodyDecl(i);
		    map.put(decl.signature(), decl);
		}
	    }
	}
	return map;
    }

    refine Generics eq ParTypeDecl.localMethodsSignatureMap() {    
	HashMap map = Generics.ParTypeDecl.localMethodsSignatureMap();
	// add the ones from grounded reflective declarations.
	Collection refMethods = reflectiveMethods();
	for ( Iterator refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    ParStaticForMethodDecl md = (ParStaticForMethodDecl) refIt.next();
	    if ( md.expandable() ) {
		List expandedMethods = md.expandedMethods();
		for ( int i=0; i<expandedMethods.getNumChild(); i++ ) {
		    MethodDecl decl = (MethodDecl) expandedMethods.getChild(i);
		    map.put(decl.signature(), decl);
		}
	    }
	}
	return map;
    }

    protected StaticForMethodDecl StaticForMethodDecl.original;
    syn StaticForMethodDecl StaticForMethodDecl.original() = original != null ? original : this;

    HashMap StaticForMethodDecl.parMethodDeclMap = new HashMap();

    public BodyDecl StaticForMethodDecl.p(ParTypeDecl parTypeDecl) {
	// check that this substitution doesn't already exist.
	if ( parMethodDeclMap.get(parTypeDecl) != null)
	    return (BodyDecl) parMethodDeclMap.get(parTypeDecl);
	
	// TODO: this is not good enough for generic methods.
	// Might need a StaticForGenericMethodDecl...
	// What I really need is for StaticForMethodDecl to be a proxy for
	// the underlying MethodDecl. But it is simply too hard to duplicate
	// all the functionalities in MethodDecl.
	// May be a nice functionality for JastAdd.
	ParStaticForMethodDecl m = 
	    new ParStaticForMethodDecl((Modifiers)getModifiers().fullCopy(), 
				       getTypeAccess().type().substituteReturnType(parTypeDecl),
				       getID(),
				       // TODO: this list needs to be substituted with whatever IteratorDecl's substitutions are.
				       getParameterList().substitute(parTypeDecl),
				       getExceptionList().substitute(parTypeDecl),
				       new Opt(),
				       getIteratorDecl().substitute(parTypeDecl),
				       new List(), new List());
	m.original = this;

	m.is$Final = true;
	((TypeDecl)parTypeDecl).addBodyDecl(m);

	parMethodDeclMap.put(parTypeDecl, m);

	return m;
    }

    // Modify how methods are retrieved.
    refine LookupMethod eq AbstractDot.getRight().lookupMethod(String name) {
	if ( isNameVariable(name)) 
	    return getLeft().type().memberMethods(getNameVariable(name));
	return LookupMethod.AbstractDot.getRight().lookupMethod(name);
    }

    syn Collection TypeDecl.memberMethods(PatternNameVariable name) = Collections.EMPTY_LIST;

    eq TypeVariable.memberMethods(PatternNameVariable name) {
	Collection methods = new ArrayList();

	if ( name.reflectiveBaseType() == this ) 
	    // If the name is exactly what is used to match on the outermost
	    // reflective loop, then the method designated by the name is
	    // exactly what is specified by the pattern.
	    methods.add(name.enclosingRefIterator().getPattern().patternMethodDecl());
	else if ( false ) {
	    // TODO
	    // otherwise, if :
	    // 1. the type is the reflective base type for a nested pattern, AND
	    // 2. name is the name variable used in the nested pattern, AND
	    // 3. the nested pattern is guaranteed to have a range of exactly one.
	    // then again the method is what's specified by the nested pattern.

	} else {
	    // look into bounds.
	    for ( int i=0; i<getNumTypeBound(); i++) {
		methods.addAll(getTypeBound(i).type().memberMethods(name));
	    }
	}
	return methods;
    }
	
    syn Collection<StaticForMethodDecl> TypeDecl.reflectivelyDeclaredMethods(MethodDecl m) {
	Collection<StaticForMethodDecl> results = new HashSet<StaticForMethodDecl>();
	Collection<StaticForMethodDecl> refMethods = reflectiveMethods();
	for ( Iterator<StaticForMethodDecl> refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    StaticForMethodDecl md = refIt.next();
	    if ( md.expandable()) continue;

	    HashMap uniMap = new HashMap();
	    if ( m.canUnifySignature(md, uniMap, md.getIteratorDecl().patternTypeVariables(), md.getIteratorDecl().patternNameVariables()) &&
		 m.type().unifiesWith(md.type(), uniMap, md.getIteratorDecl().patternTypeVariables())) {
		results.add(md);
	    }
	}
	return results;
    }

    syn lazy HashMap TypeDecl.unrestrictedMethodsSignatureMap() 
	= localMethodsSignatureMap();
    
    eq ClassDecl.unrestrictedMethodsSignatureMap() {
	HashMap map = new HashMap(localMethodsSignatureMap());

	// first collect all non-reflectively declared methods.
	if ( hasSuperclass()) {
	    for(Iterator iter = superclass().methodsIterator(); iter.hasNext(); ) {
		MethodDecl m = (MethodDecl)iter.next();
		if(!localMethodsSignatureMap().containsKey(m.signature()))
		    putSimpleSetElement(map, m.signature(), m);
	    }
	}
	for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)outerIter.next();
	    for(Iterator iter = typeDecl.methodsIterator(); iter.hasNext(); ) {
		MethodDecl m = (MethodDecl)iter.next();
		if(!localMethodsSignatureMap().containsKey(m.signature()))
		    //		    if(allMethodsAbstract((SimpleSet)map.get(m.signature())))
		    putSimpleSetElement(map, m.signature(), m);
	    }
	}

	// get all the reflective methods, expanded.
	Collection refMethods = reflectiveMethods();
	for (Iterator refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    StaticForMethodDecl m = (StaticForMethodDecl) refIt.next();
	    List expandedMethods = m.expandedMethods();
	    for ( int i=0; i<expandedMethods.getNumChild(); i++) {
		MethodDecl md = (MethodDecl) expandedMethods.getChild(i);
		if ( !map.containsKey(md.signature()))
		    putSimpleSetElement(map, md.signature(), md);
	    }
	}
	return map;
    }

    eq InterfaceDecl.unrestrictedMethodsSignatureMap() {
	HashMap map = new HashMap(localMethodsSignatureMap());
	for(Iterator outerIter = superinterfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)outerIter.next();
	    for(Iterator iter = typeDecl.methodsIterator(); iter.hasNext(); ) {
		MethodDecl m = (MethodDecl)iter.next();
		if(!localMethodsSignatureMap().containsKey(m.signature()))
		    putSimpleSetElement(map, m.signature(), m);
	    }
	}
	for(Iterator iter = typeObject().methodsIterator(); iter.hasNext(); ) {
	    MethodDecl m = (MethodDecl)iter.next();
	    if(!map.containsKey(m.signature()))
		putSimpleSetElement(map, m.signature(), m);
	}	
	// get all the reflective methods, expanded.
	Collection refMethods = reflectiveMethods();
	for (Iterator refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    StaticForMethodDecl m = (StaticForMethodDecl) refIt.next();
	    List expandedMethods = m.expandedMethods();
	    for ( int i=0; i<expandedMethods.getNumChild(); i++) {
		MethodDecl md = (MethodDecl) expandedMethods.getChild(i);
		if ( !map.containsKey(md.signature()))
		    putSimpleSetElement(map, md.signature(), md);
	    }
	}
	return map;
    }

    syn Collection TypeDecl.unrestrictedMemberMethods(String name) {
	// retrieves from all nonreflectively declared methods.
	// do not apply the same restrictions as memberMethods(name)
	// such as access restriction.
	Collection c = (Collection)unrestrictedMethodsNameMap().get(name);
	if(c != null) return c;
	return Collections.EMPTY_LIST;	
    }
    syn lazy HashMap TypeDecl.unrestrictedMethodsNameMap () {
	HashMap map = new HashMap();
	for(Iterator iter =unrestrictedMethodsIterator(); iter.hasNext(); ) {
	    MethodDecl m = (MethodDecl)iter.next();
	    ArrayList list = (ArrayList)map.get(m.name());
	    if(list == null) {
		list = new ArrayList(4);
		map.put(m.name(), list);
	    }
	    list.add(m);
	}
	return map;
    }

    // iterate over all member methods in this type
    public Iterator TypeDecl.unrestrictedMethodsIterator() {
	return new Iterator() {
		private Iterator outer = unrestrictedMethodsSignatureMap().values().iterator();
		private Iterator inner = null;
		public boolean hasNext() {
		    if((inner == null || !inner.hasNext()) && outer.hasNext())
			inner = ((SimpleSet)outer.next()).iterator();
		    return inner != null ? inner.hasNext() : false;
		}
		public Object next() {
		    return inner.next();
		}
		public void remove() { throw new UnsupportedOperationException(); }
	    };
    }
    

    public List List.expandParameterList(Map submap ) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    ParameterDeclaration node = (ParameterDeclaration) getChild(i);
	    TypeDecl argType = node.getTypeAccess().type();

	    // call substitution first.
	    Access argAccess = argType.substitute(submap);
	    TypeDecl subArgType = argAccess.type();

	    if ( subArgType.isVectorTypeVariable()) {
		List argTypes = subArgType.expandAccessList(submap);
		for ( int j=0; j<argTypes.getNumChild(); j++) {
		    ParameterDeclaration newNode = 
			new ParameterDeclaration((Modifiers) node.getModifiers().fullCopy(),
						 (Access) argTypes.getChild(j),
						 node.getID() + j);
		    list.add(newNode);
		}
	    } else {
		ParameterDeclaration newNode = 
		    new ParameterDeclaration((Modifiers) node.getModifiers().fullCopy(),
					     argAccess,
					     node.getID());
		list.add(newNode);
	    }
	}
	return list;
    }

    public List List.expandAccessList(Map submap) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    Access node = (Access) getChild(i);
	    List subs = node.type().expandAccessList(submap);
	    for ( int j=0; j<subs.getNumChild(); j++)
		list.add(subs.getChild(j));
	}
	return list;
    }
    syn lazy List TypeDecl.expandAccessList(Map submap ) {
	return new List().add(substitute(submap));
    }
    eq VectorTypeVariable.expandAccessList(Map submap) {
	List subed = new List();

	// check whether there is a map for this type in submap.
	if ( submap.containsKey(this))
	    return ((TypeDecl) submap.get(this)).expandAccessList(submap);

	for ( int i=0; i<getNumMatchedVectorTypeVariable(); i++) {
	    MatchedVectorTypeVariable t = getMatchedVectorTypeVariable(i);
	    if ( submap.containsKey(t) && submap.get(t) != null )
		subed.add(((TypeDecl) submap.get(t)).substitute(submap));
	}
	return subed;
    }

    syn lazy List<? extends MethodDecl> MethodDecl.expandedMethods () = new List().add(this);
    eq StaticForMethodDecl.expandedMethods() = new List<MethodDecl>();
    eq ParStaticForMethodDecl.expandedMethods() {
	ParTypeDecl ht = (ParTypeDecl) hostType();
	GenericTypeDecl gtd = (GenericTypeDecl) ht.genericDecl();
	    
	IteratorDecl id = getIteratorDecl();

	// get the mappings for each element in the iterator decl's range. 
	for ( Iterator subMaps = id.reflectiveElmts().values().iterator();
	      subMaps.hasNext(); ) {
	    Map substitutions = (Map) subMaps.next();

	    // put into the map the parameterization from this
	    for ( int i=0; i<gtd.getNumTypeParameter(); i++) {
		substitutions.put(gtd.getTypeParameter(i),
				  ht.getArgument(i).type());
	    }

	    ExpandedMethodDecl md = substitute(substitutions);
	    md.expansionSubstitutions = substitutions;
	    md.original = this; //this.original;

	    md.is$Final = true;
	    addExpandedMethodDecl(md);
	}

	return getExpandedMethodDeclList();
    }

    public Map BodyDecl.expansionSubstitutions = null;

    public StaticForMethodDecl ExpandedMethodDecl.original = null;

    // A map from elements in the reflective range to the mappings 
    // resulting from the pattern variables to the concrete values in
    // the element.
    syn lazy Map IteratorDecl.reflectiveElmts() {
	// in order to call this, base type must be fully grounded.
	if ( !getPattern().getBaseSet().getTypeAccess().type().grounded())
	    // this should never happen.
	    throw new Error("Cannot return the reflective elements of a " +
			    "reflective iterator when the base type is " +
			    "not grounded");

	// if this is ParIteratorDecl, we need to put in map
	// original pattern type variable --> parameterized pattern
	// type variables.
	Map ptMap = new HashMap();
	if ( this instanceof ParIteratorDecl ) {
	    for ( int i=0; i<getNumPatternTypeParameter(); i++)
		ptMap.put(((ParIteratorDecl) this).original.getPatternTypeParameter(i),
			  getPatternTypeParameter(i));
	}
	
	Map refElmtsMap = new HashMap();

	if ( getPattern().getBaseSet().iterateMethods()) {
	    Map methods = getPattern().getBaseSet().type().unrestrictedMethodsSignatureMap();
	    // find all methods that fall into the range of this
	    // iterator decl.
	    for ( Iterator mIt = methods.values().iterator(); 
		  mIt.hasNext(); ) {
		MethodDecl md = (MethodDecl) mIt.next();
		HashMap map = new HashMap();

		if ( md.isSubsumedBy(this, map)) {
		    map.putAll(ptMap);
		    refElmtsMap.put(md, map);
		}
	    }
	} else {
	    // iterate over fields.
	}

	return refElmtsMap;
    }

    syn lazy boolean BaseSet.iterateMethods () = getRefElmt().getElmtName().equals("methods");
    syn lazy boolean BaseSet.iterateFields () = getRefElmt().getElmtName().equals("fields");

}

aspect MJLookupConstructor {

    boolean ConstrainedTypeVariable.usedAsSupertype = false;
    public boolean ConstrainedTypeVariable.usedAsSupertype() {
	return usedAsSupertype; 
    }
    public void ConstrainedTypeVariable.setUsedAsSupertype(boolean p) {
	usedAsSupertype = p;
    }


    // A constrained TypeVariable used as a supertype must not be final.
    eq ConstrainedTypeVariable.isFinal() = 
	usedAsSupertype ? false : super.isFinal() ;

    // Add a default constructor to a TypeVariable constrained to be a class. 
    eq ConstrainedTypeVariable.constructors() {
	if ( getConstraint().equals("class")) {
	    ConstructorDecl cd = new ConstructorDecl(new Modifiers(new List().add(new Modifier("public"))), typeName(), new List(), new List(), new Opt(), new Block());
	    addBodyDecl(cd);
	    cd.is$Final = true;
	    cd.bypassErrorChecking = true;

	    Collection c = new ArrayList();
	    c.add(cd);
	    return c;
	}
	return super.constructors();
    }

    // TODO: what about super constructor?  any?
}
