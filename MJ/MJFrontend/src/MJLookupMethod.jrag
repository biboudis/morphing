aspect MJLookupMethod {
    /**
     * JastAddJ uses a method signature map to store mappings from 
     * String (method signature) to MethodDecl.  This no longer works
     * for reflectively declared methods. We will keep the statically
     * declared methods the way they are. And use another data structure
     * for reflectively declared methods.
     **/

    syn lazy Collection TypeDecl.reflectiveMethods() {
	Set set = new HashSet();
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if ( getBodyDecl(i).isReflectiveDecl()  &&
		 getBodyDecl(i) instanceof MethodDecl )
		set.add(getBodyDecl(i));
	}
	return set;
    }
    eq TypeVariable.reflectiveMethods() {
	Set set = new HashSet();
	for ( int i=0; i<getNumTypeBound(); i++) {
	    set.addAll(getTypeBound(i).type().reflectiveMethods());
	}
	return set;
    }
    eq ParTypeDecl.reflectiveMethods() {
	Collection refMethods = genericDecl().reflectiveMethods();
	Set substitutedMethods = new HashSet();
	for ( Iterator rmIt = refMethods.iterator(); rmIt.hasNext(); ) {
	    MethodDecl md = (MethodDecl) rmIt.next();
	    if ( md.usesTypeVariable()) {
		BodyDecl bd = md.p(this);
		bd.is$Final = true;
		addBodyDecl(bd);
		substitutedMethods.add(bd);
	    } else 
		substitutedMethods.add(md);
	}
	return substitutedMethods;
    }

    refine LookupMethod eq ClassDecl.interfacesMethodsSignatureMap() {
	HashMap map = new HashMap();
	for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)iter.next();
	    for(Iterator i2 = typeDecl.methodsIterator(); i2.hasNext(); ) {
		MethodDecl m = (MethodDecl)i2.next();
		putSimpleSetElement(map, m.signature(), m);
	    }
	}
	return map;
    }

    refine LookupMethod eq TypeDecl.localMethodsSignatureMap() {
	HashMap map = new HashMap(getNumBodyDecl());
	for(int i = 0; i < getNumBodyDecl(); i++) {
	    if(getBodyDecl(i) instanceof MethodDecl && 
	       !(getBodyDecl(i) instanceof StaticForMethodDecl) ) {
		MethodDecl decl = (MethodDecl)getBodyDecl(i);
		map.put(decl.signature(), decl);
	    }
	}
	return map;
    }
    
    refine Generics eq ParClassDecl.localMethodsSignatureMap() {    
	HashMap map = Generics.ParClassDecl.localMethodsSignatureMap();	
	// add the ones from grounded reflective declarations.
	Collection refMethods = reflectiveMethods();
	for ( Iterator refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    ParStaticForMethodDecl md = (ParStaticForMethodDecl) refIt.next();
	    if ( md.expandable() ) {
		List expandedMethods = md.expandedMethods();
		for ( int i=0; i<expandedMethods.getNumChild(); i++ ) {
		    MethodDecl decl = (MethodDecl) expandedMethods.getChild(i);
		    map.put(decl.signature(), decl);
		}
	    }
	}
	return map;
    }
    refine Generics eq ParInterfaceDecl.localMethodsSignatureMap() {    
	HashMap map = Generics.ParInterfaceDecl.localMethodsSignatureMap();
	// add the ones from grounded reflective declarations.
	Collection refMethods = reflectiveMethods();
	for ( Iterator refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    ParStaticForMethodDecl md = (ParStaticForMethodDecl) refIt.next();
	    if ( md.expandable() ) {
		List expandedMethods = md.expandedMethods();
		for ( int i=0; i<expandedMethods.getNumChild(); i++ ) {
		    MethodDecl decl = (MethodDecl) expandedMethods.getChild(i);
		    map.put(decl.signature(), decl);
		}
	    }
	}
	return map;
    }
    
    protected StaticForMethodDecl StaticForMethodDecl.original;
    syn StaticForMethodDecl StaticForMethodDecl.original() = original != null ? original : this;

    HashMap StaticForMethodDecl.parMethodDeclMap = new HashMap();

    public BodyDecl StaticForMethodDecl.p(ParTypeDecl parTypeDecl) {
	// check that this substitution doesn't already exist.
	if ( parMethodDeclMap.get(parTypeDecl) != null)
	    return (BodyDecl) parMethodDeclMap.get(parTypeDecl);
	
	// TODO: this is not good enough for generic methods.
	// Might need a StaticForGenericMethodDecl...
	// What I really need is for StaticForMethodDecl to be a proxy for
	// the underlying MethodDecl. But it is simply too hard to duplicate
	// all the functionalities in MethodDecl.
	// May be a nice functionality for JastAdd.
	ParStaticForMethodDecl m = 
	    new ParStaticForMethodDecl((Modifiers)getModifiers().fullCopy(), 
				       getTypeAccess().type().substituteReturnType(parTypeDecl),
				       getID(),
				       getParameterList().substitute(parTypeDecl),
				       new List(),
				       getExceptionList().substitute(parTypeDecl),
				       new Opt(),
				       getIteratorDecl().substitute(parTypeDecl),
				       new List(), new List());
	m.original = this;

	m.is$Final = true;
	((TypeDecl)parTypeDecl).addBodyDecl(m);

	parMethodDeclMap.put(parTypeDecl, m);

	return m;
    }

    public IteratorDecl IteratorDecl.substitute(ParTypeDecl parTypeDecl) {
	ParIteratorDecl pid = 
	    new ParIteratorDecl(getPatternTypeParameterList(),
				getPatternNameParameterList(),
				getPattern().substitute(parTypeDecl), getNestedPatternList().substitute(parTypeDecl));
	
	pid.original = this;
	return pid;
    }

    public IteratorDecl ParIteratorDecl.original;

    public Pattern Pattern.substitute(ParTypeDecl parTypeDecl) {
	return new Pattern((Modifiers) getModifiers().fullCopy(),
			   getTypeAccess().type().substitute(parTypeDecl),
			   getID(),
			   getParameterList().substitute(parTypeDecl),
			   new List(),
			   getExceptionList().substitute(parTypeDecl),
			   getBaseSet().substitute(parTypeDecl));
    }
    public NestedPattern NestedPattern.substitute(ParTypeDecl parTypeDecl) {
	return new NestedPattern((Modifiers) getModifiers().fullCopy(),
				 getTypeAccess().type().substitute(parTypeDecl),
				 getID(),
				 getParameterList().substitute(parTypeDecl),
				 new List(),
				 getExceptionList().substitute(parTypeDecl),
				 getBaseSet().substitute(parTypeDecl),
				 getIsPositive());
    }

    public BaseSet BaseSet.substitute(ParTypeDecl parTypeDecl) {
	return new BaseSet(getTypeAccess().type().substitute(parTypeDecl),
			   (RefElmt) getRefElmt().fullCopy());
    }

    // Modify how methods are retrieved.
    refine LookupMethod eq AbstractDot.getRight().lookupMethod(String name) {
	if ( isNameVariable(name)) 
	    return getLeft().type().memberMethods(getNameVariable(name));
	return LookupMethod.AbstractDot.getRight().lookupMethod(name);
    }

    syn Collection TypeDecl.memberMethods(PatternNameVariable name) = Collections.EMPTY_LIST;

    eq TypeVariable.memberMethods(PatternNameVariable name) {
	Collection methods = new ArrayList();

	if ( name.reflectiveBaseType() == this ) 
	    // If the name is exactly what is used to match on the outermost
	    // reflective loop, then the method designated by the name is
	    // exactly what is specified by the pattern.
	    methods.add(name.enclosingRefIterator().getPattern().patternMethodDecl());
	else if ( false ) {
	    // TODO
	    // otherwise, if :
	    // 1. the type is the reflective base type for a nested pattern, AND
	    // 2. name is the name variable used in the nested pattern, AND
	    // 3. the nested pattern is guaranteed to have a range of exactly one.
	    // then again the method is what's specified by the nested pattern.

	} else {
	    // look into bounds.
	    for ( int i=0; i<getNumTypeBound(); i++) {
		methods.addAll(getTypeBound(i).type().memberMethods(name));
	    }
	}
	return methods;
    }
	
    syn lazy HashMap TypeDecl.unrestrictedMethodsSignatureMap() 
	= localMethodsSignatureMap();
    
    eq ClassDecl.unrestrictedMethodsSignatureMap() {
	HashMap map = new HashMap(localMethodsSignatureMap());

	// first collect all non-reflectively declared methods.
	if ( hasSuperclass()) {
	    for(Iterator iter = superclass().methodsIterator(); iter.hasNext(); ) {
		MethodDecl m = (MethodDecl)iter.next();
		if(!localMethodsSignatureMap().containsKey(m.signature()))
		    putSimpleSetElement(map, m.signature(), m);
	    }
	}
	for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)outerIter.next();
	    for(Iterator iter = typeDecl.methodsIterator(); iter.hasNext(); ) {
		MethodDecl m = (MethodDecl)iter.next();
		if(!localMethodsSignatureMap().containsKey(m.signature()))
		    //		    if(allMethodsAbstract((SimpleSet)map.get(m.signature())))
		    putSimpleSetElement(map, m.signature(), m);
	    }
	}

	// get all the reflective methods, expanded.
	Collection refMethods = reflectiveMethods();
	for (Iterator refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    StaticForMethodDecl m = (StaticForMethodDecl) refIt.next();
	    List expandedMethods = m.expandedMethods();
	    for ( int i=0; i<expandedMethods.getNumChild(); i++) {
		MethodDecl md = (MethodDecl) expandedMethods.getChild(i);
		if ( !map.containsKey(md.signature()))
		    putSimpleSetElement(map, md.signature(), md);
	    }
	}
	return map;
    }

    eq InterfaceDecl.unrestrictedMethodsSignatureMap() {
	HashMap map = new HashMap(localMethodsSignatureMap());
	for(Iterator outerIter = superinterfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)outerIter.next();
	    for(Iterator iter = typeDecl.methodsIterator(); iter.hasNext(); ) {
		MethodDecl m = (MethodDecl)iter.next();
		if(!localMethodsSignatureMap().containsKey(m.signature()))
		    putSimpleSetElement(map, m.signature(), m);
	    }
	}
	for(Iterator iter = typeObject().methodsIterator(); iter.hasNext(); ) {
	    MethodDecl m = (MethodDecl)iter.next();
	    if(!map.containsKey(m.signature()))
		putSimpleSetElement(map, m.signature(), m);
	}	
	// get all the reflective methods, expanded.
	Collection refMethods = reflectiveMethods();
	for (Iterator refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    StaticForMethodDecl m = (StaticForMethodDecl) refIt.next();
	    List expandedMethods = m.expandedMethods();
	    for ( int i=0; i<expandedMethods.getNumChild(); i++) {
		MethodDecl md = (MethodDecl) expandedMethods.getChild(i);
		if ( !map.containsKey(md.signature()))
		    putSimpleSetElement(map, md.signature(), md);
	    }
	}
	return map;
    }

    syn Collection TypeDecl.unrestrictedMemberMethods(String name) {
	// retrieves from all nonreflectively declared methods.
	// do not apply the same restrictions as memberMethods(name)
	// such as access restriction.
	Collection c = (Collection)unrestrictedMethodsNameMap().get(name);
	if(c != null) return c;
	return Collections.EMPTY_LIST;	
    }
    syn lazy HashMap TypeDecl.unrestrictedMethodsNameMap () {
	HashMap map = new HashMap();
	for(Iterator iter =unrestrictedMethodsIterator(); iter.hasNext(); ) {
	    MethodDecl m = (MethodDecl)iter.next();
	    ArrayList list = (ArrayList)map.get(m.name());
	    if(list == null) {
		list = new ArrayList(4);
		map.put(m.name(), list);
	    }
	    list.add(m);
	}
	return map;
    }

    // iterate over all member methods in this type
    public Iterator TypeDecl.unrestrictedMethodsIterator() {
	return new Iterator() {
		private Iterator outer = unrestrictedMethodsSignatureMap().values().iterator();
		private Iterator inner = null;
		public boolean hasNext() {
		    if((inner == null || !inner.hasNext()) && outer.hasNext())
			inner = ((SimpleSet)outer.next()).iterator();
		    return inner != null ? inner.hasNext() : false;
		}
		public Object next() {
		    return inner.next();
		}
		public void remove() { throw new UnsupportedOperationException(); }
	    };
    }
    
    public ExpandedMethodDecl StaticForMethodDecl.substitute(Map substitution) {
	return new ExpandedMethodDecl((Modifiers) getModifiers().fullCopy(),
				      getTypeAccess().type().substitute(substitution),
				      isNameVariable(getID()) ?
				      (String) substitution.get(getNameVariable(getID())) : getID(),
				      getParameterList().expandParameterList(substitution),
				      new List(),
				      getExceptionList().expandAccessList(substitution),
				      new Opt());
    }

    public NestedPattern NestedPattern.substitute(Map substitutions) {
	return new NestedPattern((Modifiers) getModifiers().fullCopy(),
				 getTypeAccess().type().substitute(substitutions),
				 isNameVariable(getID()) ? 
				 (String) substitutions.get(getNameVariable(getID())) : getID(),
				 getParameterList().expandParameterList(substitutions),
				 new List(),
				 getExceptionList().expandAccessList(substitutions),
				 getBaseSet().substitute(substitutions),
				 getIsPositive());	
    }

    public Access ParTypeDecl.substitute(Map submap) {
	java.util.ArrayList list = new java.util.ArrayList();
	for ( int i=0; i<getNumArgument(); i++) 
	    list.add(getArgument(i).type().substitute(submap).type());
	return ((GenericTypeDecl) genericDecl()).lookupParTypeDecl(list).createBoundAccess();
    }
    
    public Access RawClassDecl.substitute(Map submap) { return createBoundAccess(); }
    public Access RawInterfaceDecl.substitute(Map submap) { return createBoundAccess(); }

    public BaseSet BaseSet.substitute(Map substitutions) {
	return new BaseSet(getTypeAccess().type().substitute(substitutions), getRefElmt());
    }

    public List List.expandParameterList(Map submap ) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    ParameterDeclaration node = (ParameterDeclaration) getChild(i);
	    TypeDecl argType = node.getTypeAccess().type();
	    if ( argType.isVectorTypeVariable()) {
		List argTypes = argType.expandAccessList(submap);
		for ( int j=0; j<argTypes.getNumChild(); j++) {
		    ParameterDeclaration newNode = 
			new ParameterDeclaration((Modifiers) node.getModifiers().fullCopy(),
						 (Access) argTypes.getChild(j),
						 node.getID() + "j",
						 (List) node.getEmptyBracketList().fullCopy());
		    list.add(newNode);
		}
	    } else {
		ParameterDeclaration newNode = 
		    new ParameterDeclaration((Modifiers) node.getModifiers().fullCopy(),
					     node.getTypeAccess().type().substitute(submap),
					     node.getID(),
					     (List) node.getEmptyBracketList().fullCopy());
		list.add(newNode);
	    }
	}
	return list;
    }
    public List List.expandAccessList(Map submap) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    Access node = (Access) getChild(i);
	    List subs = node.type().expandAccessList(submap);
	    for ( int j=0; j<subs.getNumChild(); j++)
		list.add(subs.getChild(j));
	}
	return list;
    }

    public Access TypeDecl.substitute(Map submap) {
	return createBoundAccess();
    }
    public Access TypeVariable.substitute(Map submap) {
	if ( submap.containsKey(this))
	    return ((TypeDecl) submap.get(this)).substitute(submap);
	return createBoundAccess();
    }
    public Access VectorTypeVariable.substitute(Map submap) {
	throw new Error("Vector type variable can only be substituted " +
			"to a list of types.");
    }

    syn lazy List TypeDecl.expandAccessList(Map submap ) {
	return new List().add(substitute(submap));
    }
    eq VectorTypeVariable.expandAccessList(Map submap) {
	List subed = new List();
	for ( int i=0; i<getNumMatchedVectorTypeVariable(); i++) {
	    MatchedVectorTypeVariable t = getMatchedVectorTypeVariable(i);
	    if ( submap.containsKey(t) && submap.get(t) != null )
		subed.add(((TypeDecl) submap.get(t)).substitute(submap));
	}
	return subed;
    }

    syn lazy List MethodDecl.expandedMethods () = new List().add(this);
    eq StaticForMethodDecl.expandedMethods() = new List();
    eq ParStaticForMethodDecl.expandedMethods() {
	ParTypeDecl ht = (ParTypeDecl) hostType();
	GenericTypeDecl gtd = (GenericTypeDecl) ht.genericDecl();
	    
	IteratorDecl id = getIteratorDecl();

	// get the mappings for each element in the iterator decl's range. 
	for ( Iterator subMaps = id.reflectiveElmts().values().iterator();
	      subMaps.hasNext(); ) {
	    Map substitutions = (Map) subMaps.next();

	    // put into the map the parameterization from this
	    for ( int i=0; i<gtd.getNumTypeParameter(); i++) {
		substitutions.put(gtd.getTypeParameter(i),
				  ht.getArgument(i).type());
	    }

	    ExpandedMethodDecl md = substitute(substitutions);
	    md.expansionSubstitutions = substitutions;
	    md.original = this; //this.original;

	    md.is$Final = true;
	    addExpandedMethodDecl(md);
	}

	return getExpandedMethodDeclList();
    }

    public Map BodyDecl.expansionSubstitutions = null;

    public StaticForMethodDecl ExpandedMethodDecl.original = null;

    // A map from elements in the reflective range to the mappings 
    // resulting from the pattern variables to the concrete values in
    // the element.
    syn lazy Map IteratorDecl.reflectiveElmts() {
	// in order to call this, base type must be fully grounded.
	if ( !getPattern().getBaseSet().getTypeAccess().type().grounded())
	    // this should never happen.
	    throw new Error("Cannot return the reflective elements of a " +
			    "reflective iterator when the base type is " +
			    "not grounded");
	
	Map refElmtsMap = new HashMap();

	if ( getPattern().getBaseSet().iterateMethods()) {
	    Map methods = getPattern().getBaseSet().type().unrestrictedMethodsSignatureMap();
	    // find all methods that fall into the range of this
	    // iterator decl.
	    for ( Iterator mIt = methods.values().iterator(); 
		  mIt.hasNext(); ) {
		MethodDecl md = (MethodDecl) mIt.next();
		HashMap map = new HashMap();

		if ( md.isSubsumedBy(this, map))
		    refElmtsMap.put(md, map);
	    }
	} else {
	    // iterate over fields.
	}

	return refElmtsMap;
    }

    syn lazy boolean BaseSet.iterateMethods () = getRefElmt().getElmtName().equals("methods");
    syn lazy boolean BaseSet.iterateFields () = getRefElmt().getElmtName().equals("fields");

}

aspect MJLookupConstructor {

    boolean ConstrainedTypeVariable.usedAsSupertype = false;
    public boolean ConstrainedTypeVariable.usedAsSupertype() {
	return usedAsSupertype; 
    }
    public void ConstrainedTypeVariable.setUsedAsSupertype(boolean p) {
	usedAsSupertype = p;
    }


    // A constrained TypeVariable used as a supertype must not be final.
    eq ConstrainedTypeVariable.isFinal() = 
	usedAsSupertype ? false : super.isFinal() ;

    // Add a default constructor to a TypeVariable constrained to be a class. 
    eq ConstrainedTypeVariable.constructors() {
	if ( getConstraint().equals("class")) {
	    ConstructorDecl cd = new ConstructorDecl(new Modifiers(new List().add(new Modifier("public"))), typeName(), new List(), new List(), new Opt(), new Block());
	    addBodyDecl(cd);
	    cd.is$Final = true;
	    cd.bypassErrorChecking = true;

	    Collection c = new ArrayList();
	    c.add(cd);
	    return c;
	}
	return super.constructors();
    }

    // TODO: what about super constructor?  any?
}
