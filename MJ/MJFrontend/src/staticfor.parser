BodyDecl class_member_declaration =
    staticfor_declaration.b {: return b; :}
  ;

BodyDecl staticfor_declaration = 
    staticfor_header.i staticfor_body.l
  {: return new StaticForDecl(i, l); :}
  ;

List staticfor_stmts =
    block_statement.s {: return new List().add(s); :}
  | LBRACE OR block_statements.s OR RBRACE {: return s; :}
  ;

Stmt block_statement =
    staticfor_stmt_header.i staticfor_stmts.s {: return new StaticForStmt(i, s); :}
	
  ;

List pattern_type_parameter_list_2 = 
    LT IDENTIFIER.id GT {: return new List().add(new PatternTypeVariable(new Modifiers(), id, new List(), new List())); :}
  | LT IDENTIFIER.id type_bound.l GT {: return new List().add(new PatternTypeVariable(new Modifiers(), id, new List(), l)); :}

  | LT IDENTIFIER.id MULT GT {: return new List().add(new VectorTypeVariable(new Modifiers(), id, new List(), new List(), new List())); :}
  | LT IDENTIFIER.id MULT type_bound.l GT {: return new List().add(new VectorTypeVariable(new Modifiers(), id, new List(), l, new List())); :}

  | LT IDENTIFIER.id COMMA type_parameter_list.tl GT 
    {: return tl.add(new PatternTypeVariable(new Modifiers(), id, new List(), new List())); :}
  | LT IDENTIFIER.id type_bound.l COMMA type_parameter_list.tl GT 
    {: return tl.add(new PatternTypeVariable(new Modifiers(), id, new List(), l)); :}
  | LT IDENTIFIER.id MULT COMMA type_parameter_list.tl GT 
    {: return tl.add(new VectorTypeVariable(new Modifiers(), id, new List(), new List(), new List())); :}
  | LT IDENTIFIER.id MULT type_bound.l COMMA type_parameter_list.tl GT 
    {: return tl.add(new VectorTypeVariable(new Modifiers(), id, new List(), l, new List())); :}
  ;
 
List staticfor_body =
    class_body_declaration.c {: return new List().add(c); :}
  | LBRACE OR class_body_declarations.l OR RBRACE {: return l; :}
  ;

IteratorDecl staticfor_stmt_header = 
    pattern_type_parameter_list_2.l? pattern_name_parameter_list.n? FOR LPAREN pattern.p nested_patterns.np? RPAREN 
    {: return new IteratorDecl(l, n, p, np); :}
    ;

IteratorDecl staticfor_header = 
    pattern_type_parameter_list.l? pattern_name_parameter_list.n? FOR LPAREN pattern.p nested_patterns.np? RPAREN 
    {: return new IteratorDecl(l, n, p, np); :}
  ;  

List pattern_type_parameter_list =
    LT pattern_type_parameter_list_1.l {: return l; :}
  ;
List pattern_type_parameter_list_1 =
    type_parameter_list_1.l
    {: 
	List l2 = new List();
	for ( int i=0; i<l.getNumChildNoTransform(); i++) {
	  TypeVariable tv = (TypeVariable) l.getChildNoTransform(i); 	
	  if ( !(tv instanceof PatternTypeVariable) )
		  l2.add(new PatternTypeVariable(tv.getModifiersNoTransform(),
                                                 tv.getID(), 
                                                 tv.getBodyDeclListNoTransform(), tv.getTypeBoundListNoTransform()));
	  else l2.add(tv);
	}				
	return l2;	
    :}
  ;

List pattern_name_parameter_list =
    LBRACK pattern_name_parameters.n RBRACK {: return n; :}
  ;

TypeVariable type_parameter_1 = 
    IDENTIFIER.v MULT GT {: return new VectorTypeVariable(new Modifiers(), v, new List(), new List(), new List()); :}
  | IDENTIFIER.v MULT type_bound_1.l {: return new VectorTypeVariable(new Modifiers(), v, new List(), l, new List()); :}
  ;

TypeVariable type_parameter = 
    IDENTIFIER.v MULT {: return new VectorTypeVariable(new Modifiers(), v, new List(), new List(), new List()); :}
  | IDENTIFIER.v MULT type_bound.l {: return new VectorTypeVariable(new Modifiers(), v, new List(), l, new List()); :}
  ;

List pattern_name_parameters =
    pattern_name_parameter.p {: return new List().add(p); :}
  | pattern_name_parameters.l COMMA pattern_name_parameter.p {: return l.add(p); :}
  ;

PatternNameVariable pattern_name_parameter =
    IDENTIFIER.id {: return new PatternNameVariable(id); :}
  ;
    
Pattern pattern = 
     modifiers.m? VOID IDENTIFIER.id LPAREN formal_types.l? RPAREN throws.tl? COLON baseset.b 
     {: return new MethodPattern(b, new Modifiers(m), new PrimitiveTypeAccess("void"), id, l, tl, new Opt(), new List()); :}
  |  modifiers.m? type.t? IDENTIFIER.id LPAREN formal_types.l? RPAREN throws.tl? COLON baseset.b 
     {: return new OptMethodPattern(b, new Modifiers(m), t, id, l, tl, new Opt()); :}
  | modifiers.m? type.t? IDENTIFIER.id COLON baseset.b
     {: return new OptFieldPattern(b, new Modifiers(m), t, id); :}
  ;

List nested_patterns =
    SEMICOLON nested_pattern.p {: return new List().add(p); :}
  | nested_patterns.l SEMICOLON nested_pattern.p {: return l.add(p); :}
  ;

Pattern nested_pattern =
     NO modifiers.m? type.t? IDENTIFIER.id LPAREN formal_types.l? RPAREN throws.tl? COLON baseset.b
     {: return new OptNestedMethodPattern(b, new Modifiers(m), t, id, l, tl, new Opt(), false); :}
  |  NO modifiers.m? VOID IDENTIFIER.id LPAREN formal_types.l? RPAREN throws.tl? COLON baseset.b
    {: return new NestedMethodPattern(b, new Modifiers(m), new PrimitiveTypeAccess("void"), id, l, tl, new Opt(), new List(), false); :}
  |  NO modifiers.m? type.t? IDENTIFIER.id COLON baseset.b
     {: return new OptNestedFieldPattern(b, new Modifiers(m), t, id, false); :}
  |  SOME modifiers.m? type.t? IDENTIFIER.id LPAREN formal_types.l? RPAREN throws.tl? COLON baseset.b
     {: return new OptNestedMethodPattern(b, new Modifiers(m), t, id, l, tl, new Opt(), true); :}
  |  SOME modifiers.m? VOID IDENTIFIER.id LPAREN formal_types.l? RPAREN throws.tl? COLON baseset.b
     {: return new NestedMethodPattern(b, new Modifiers(m), new PrimitiveTypeAccess("void"), id, l, tl, new Opt(), new List(), true); :}
  |  SOME modifiers.m? type.t? IDENTIFIER.id COLON baseset.b
     {: return new OptNestedFieldPattern(b, new Modifiers(m), t, id, true); :}
  ;	

Modifier modifier = 
     NOT modifier.m {: return new NegativeModifier(m.getID()); :}
// I DON"T UNDERSTAND WHY THIS DOESN"T PARSE
//  |  NOMOD   {: return new NoModifier("NOMOD"); :}
  ;

List formal_types = 
    type.t {: return new List().add(t); :}
  | formal_types.l COMMA type.t {: return l.add(t); :}
  ; 

BaseSet baseset =
    type.t reflection_elmt.e
    {: return new BaseSet(t, e); :} 
  ;

RefElmt reflection_elmt =
    METHODS {: return new RefElmt("methods"); :}
  | FIELDS  {: return new RefElmt("fields"); :}
  ;
