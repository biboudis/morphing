BodyDecl class_member_declaration =
    staticfor_declaration.b {: return b; :}
  ;

BodyDecl staticfor_declaration = 
    staticfor_header.i staticfor_body.l
  {: return new StaticForDecl(i, l); :}
  ;

List staticfor_body =
    class_body_declaration.c {: return new List().add(c); :}
  | LBRACE OR class_body_declarations.l OR RBRACE {: return l; :}
  ;

IteratorDecl staticfor_header = 
    LT pattern_type_parameter_list_1.l LBRACK pattern_name_parameters.n RBRACK FOR LPAREN pattern.p RPAREN 
    {: return new IteratorDecl(l, n, p, new List()); :} 
  | LT pattern_type_parameter_list_1.l LBRACK pattern_name_parameters.n RBRACK FOR LPAREN pattern.p nested_patterns.np RPAREN 
    {: return new IteratorDecl(l, n, p, np);  :} 
  ;  

List pattern_type_parameter_list_1 =
    type_parameter_list_1.l
    {: 
	List l2 = new List();
	for ( int i=0; i<l.getNumChild(); i++) {
	  if ( !(l.getChild(i) instanceof PatternTypeVariable) ) 
		  l2.add(new PatternTypeVariable(new Modifiers(), ((TypeVariable) l.getChild(i)).getID(), new List(), new List()));
	  else l2.add(l.getChild(i));
	}			
	return l2;
    :}
  ;

List nested_patterns =
    SEMI nested_pattern.p {: return new List().add(p); :}
  | nested_patterns.l nested_pattern.p {: return l.add(p); :}
  ;

TypeVariable type_parameter_1 = 
    IDENTIFIER.v MULT GT {: return new VectorTypeVariable(new Modifiers(), v, new List(), new List(), new List()); :}
  | IDENTIFIER.v MULT type_bound_1.l {: return new VectorTypeVariable(new Modifiers(), v, new List(), l, new List()); :}
  ;

List pattern_name_parameters =
    pattern_name_parameter.p {: return new List().add(p); :}
  | pattern_name_parameters.l COMMA pattern_name_parameter.p {: return l.add(p); :}
  ;

PatternNameVariable pattern_name_parameter =
    IDENTIFIER.id {: return new PatternNameVariable(id); :}
  ;
    
Pattern pattern = 
     modifiers.m type.t IDENTIFIER.id LPAREN formal_types.l RPAREN COLON baseset.b
     {: return new Pattern(m, t, id, l, new List(), new List(), b); :}
  |  modifiers.m type.t IDENTIFIER.id LPAREN RPAREN COLON baseset.b
     {: return new Pattern(m, t, id, new List(), new List(), new List(), b); :}
  ;

NestedPattern nested_pattern =
     NO modifiers.m type.t IDENTIFIER.id LPAREN formal_types.l RPAREN  COLON baseset.b
     {: return new NestedPattern(m, t, id, l, new List(), new List(), b, false); :}
  |  SOME modifiers.m type.t IDENTIFIER.id LPAREN RPAREN COLON baseset.b
     {: return new NestedPattern(m, t, id, new List(), new List(), new List(), b, true); :}
  ;

/*
Modifiers modifiers =
     AT NOMOD   {: Modifiers ms = new Modifiers(); ms.addModifier(new NoModifier("NOMOD")); return ms; :}
  ;
*/

Modifier modifier = 
     NOT modifier.m {: return new NegativeModifier(m.getID()); :}
// I DON"T UNDERSTAND WHY THIS DOESN"T PARSE
//  |  NOMOD   {: return new NoModifier("NOMOD"); :}
  ;

List formal_types = 
    type.t {: return new List().add(t); :}
  | formal_types.l COMMA type.t {: return l.add(t); :}
  ; 

BaseSet baseset =
    type.t reflection_elmt.e 
    {: return new BaseSet(t, e); :}
  ;

RefElmt reflection_elmt =
    METHODS {: return new RefElmt("methods"); :}
  | FIELDS  {: return new RefElmt("fields"); :}
  ;
