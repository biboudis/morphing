aspect MJLookupVariable {
    refine LookupVariable eq AbstractDot.getRight().lookupVariable(String name) {
	if ( isNameVariable(name) || containsNameVariable(name))
	    return getLeft().qualifiedLookupVariable(new Identifier(name, enclosingRefIterator()));
	return LookupVariable.AbstractDot.getRight().lookupVariable(name);
    }

    // Copied from LookupVariable, for IDentifier.
    syn SimpleSet Expr.qualifiedLookupVariable(Identifier name) {
	if(type().accessibleFrom(hostType()))
	    return keepAccessibleFields(type().memberFields(name));
	return SimpleSet.emptySet;
    }
    eq TypeAccess.qualifiedLookupVariable(Identifier name) {
	if(type().accessibleFrom(hostType())) {
	    SimpleSet c = type().memberFields(name);
	    c = keepAccessibleFields(c);
	    if(type().isClassDecl() && c.size() == 1)
		c = removeInstanceVariables(c);
	    return c;
	}
	return SimpleSet.emptySet;
    }
    
    refine LookupVariable eq Block.getStmt(int index).lookupVariable(String name) {
	VariableDeclaration v = null;
	// need to figure out whether name is a name variable.
	if ( getStmt(index).isNameVariable(name) || getStmt(index).containsNameVariable(name)) {
	    //	    PatternNameVariable nv = getStmt(index).getNameVariable(name);
	    Identifier id = new Identifier(name, getStmt(index).enclosingRefIterator());
	    v = localVariableDeclaration(id);

	    // declare before use and shadowing
	    if(v != null && declaredBeforeUse(v, index))
		return v;
	    return lookupVariable(id);
	} else {
	    v = localVariableDeclaration(name);
	    
	    // declare before use and shadowing
	    if(v != null && declaredBeforeUse(v, index))
		return v;
	    return lookupVariable(name);
	} 
    }

    syn lazy VariableDeclaration Block.localVariableDeclaration(Identifier id) {
	for ( int i=0; i<getNumStmt(); i++) {
	    if ( getStmt(i).declaresVariable(id))
		return getStmt(i).getVariableDeclaration(id);
	}
	return null;
    }

    syn boolean Stmt.declaresVariable(Identifier id) = false;
    eq VariableDeclaration.declaresVariable(Identifier id) {
	if ( !id.substitutedName().equals(name())) return false;
	return enclosingRefIterator() == null ? false : 
	    enclosingRefIterator().subsumes(id.enclosingRefIterator(), new HashMap());
    }
    eq StaticForStmt.declaresVariable(Identifier id) {
	for ( int i=0; i<getNumStmt(); i++) {
	    if ( getStmt(i).declaresVariable(id)) return true;
	}
	return false;
    }

    syn lazy VariableDeclaration Stmt.getVariableDeclaration(Identifier id) = null;
    eq StaticForStmt.getVariableDeclaration(Identifier id) {
	for ( int i=0; i<getNumStmt(); i++) {
	    if ( getStmt(i).declaresVariable(id)) 
		return getStmt(i).getVariableDeclaration(id);
	}
	return null;
    }
    eq VariableDeclaration.getVariableDeclaration(Identifier id) {
	if ( this.declaresVariable(id)) return this;
	return null;
    }
    
    inh lazy SimpleSet TypeDecl.lookupVariable(Identifier id);
    inh lazy SimpleSet BodyDecl.lookupVariable(Identifier id);
    inh SimpleSet Stmt.lookupVariable(Identifier id);
    inh lazy SimpleSet Block.lookupVariable(Identifier id);
    inh lazy SimpleSet ForStmt.lookupVariable(Identifier id);
    inh SimpleSet Expr.lookupVariable(Identifier id);
    inh lazy SimpleSet CatchClause.lookupVariable(Identifier id);
    inh SimpleSet VariableDeclaration.lookupVariable(Identifier id);
    inh SimpleSet ParameterDeclaration.lookupVariable(Identifier id);
    
    eq Program.getChild().lookupVariable(Identifier id) = SimpleSet.emptySet;

    eq StaticForStmt.getStmt(int index).lookupVariable(Identifier id) {
	// check whether nv is captured by the primary pattern as a variable,
	// or captured by a nested pattern where the range is exactly one.
	Pattern p = getIteratorDecl().getPattern();
	if ( p.isFieldPattern() && 
	     id.substitutedName().equals(((FieldPattern) p).getID()))
	    return ((FieldPattern) p).patternFieldDeclaration();
	return lookupVariable(id);
    }

    // 6.5.6.1
    eq TypeDecl.getBodyDecl(int i).lookupVariable(Identifier id) {
	SimpleSet list = memberFields(id);
	if(!list.isEmpty()) return list;
	list = lookupVariable(id);
	if(inStaticContext() || isStatic())
	    list = removeInstanceVariables(list);
	else if(isAnonymous() && inExplicitConstructorInvocation()) {
	    TypeDecl typeDecl = enclosingType();
	    SimpleSet newSet = SimpleSet.emptySet;
	    for(Iterator iter = list.iterator(); iter.hasNext(); ) {
		Variable v = (Variable)iter.next();
		if(!v.isInstanceVariable() || 
		   !typeDecl.memberFields(id).contains(v))
		    newSet = newSet.add(v);
	    }
	    return newSet;
	}
	return list;
    }
    eq MethodDecl.getBlock().lookupVariable(Identifier id) {
	SimpleSet set = parameterDeclaration(id);
	if ( !set.isEmpty()) return set;
	return lookupVariable(id);
    }
    eq MethodDecl.getParameter().lookupVariable(Identifier id) = parameterDeclaration(id);

    eq ConstructorDecl.getBlock().lookupVariable(Identifier id) {
	SimpleSet set = parameterDeclaration(id);
	if(!set.isEmpty()) return set;
	return lookupVariable(id);
    }
    eq ConstructorDecl.getConstructorInvocation().lookupVariable(Identifier id) {
	SimpleSet set = parameterDeclaration(id);
	if(!set.isEmpty()) return set;
	set = hostType().memberFields(id); // search members
	if(!set.isEmpty()) {
	    set = removeInstanceVariables(set);
	    return set;
	}
	if(hostType().isNestedType() || hostType().isAnonymous())
	    return hostType().lookupVariable(id);
	return SimpleSet.emptySet;
    }
   
    eq ConstructorDecl.getParameter().lookupVariable(Identifier id) = parameterDeclaration(id);

    // the block in which the declaration appears
    eq Block.getStmt(int index).lookupVariable(Identifier id) {
	VariableDeclaration v = localVariableDeclaration(id);
	// declare before use and shadowing
	if(v != null && declaredBeforeUse(v, index))
	    return v;
	return lookupVariable(id);
    }

    
    syn lazy SimpleSet MethodDecl.parameterDeclaration(Identifier id) {
	for(int i = 0; i < getNumParameter(); i++)
	    if(getParameter(i).name().equals(id.substitutedName()))
		return (ParameterDeclaration)getParameter(i);
	return SimpleSet.emptySet;
    }
    syn lazy SimpleSet ConstructorDecl.parameterDeclaration(Identifier id) {
	for(int i = 0; i < getNumParameter(); i++)
	    if(getParameter(i).name().equals(id.substitutedName()))
		return (ParameterDeclaration)getParameter(i);
	return SimpleSet.emptySet;
    }
    syn lazy SimpleSet CatchClause.parameterDeclaration(Identifier id) =
	getParameter().name().equals(id.substitutedName()) ? (ParameterDeclaration)getParameter() : SimpleSet.emptySet;
    
}

aspect MJFields {
    syn lazy Collection<StaticForFieldDeclaration> TypeDecl.reflectiveFields() {
	Set set = new HashSet();
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if ( getBodyDecl(i).isReflectiveDecl()  &&
		 getBodyDecl(i) instanceof FieldDeclaration )
		set.add((StaticForFieldDeclaration)getBodyDecl(i));
	}
	return set;
    }
    eq TypeVariable.reflectiveFields () {
	Set set = new HashSet();
	for ( int i=0; i<getNumTypeBound(); i++) {
	    set.addAll(getTypeBound(i).type().reflectiveFields());
	}
	return set;
    }
    eq ParTypeDecl.reflectiveFields() {
	Collection<StaticForFieldDeclaration> refFields = 
	    genericDecl().reflectiveFields();
	Set<StaticForFieldDeclaration> substitutedFields = new HashSet();
	for ( Iterator<StaticForFieldDeclaration> rfIt = refFields.iterator(); 
	      rfIt.hasNext(); ) {
	    StaticForFieldDeclaration fd = rfIt.next();
	    if ( fd.usesTypeVariable()) {
		BodyDecl bd = fd.p(this);
		bd.is$Final = true;
		addBodyDecl((StaticForFieldDeclaration)bd);
		substitutedFields.add((StaticForFieldDeclaration)bd);
	    } else 
		substitutedFields.add((StaticForFieldDeclaration)fd);
	}
	return substitutedFields;
    }

    syn lazy List<? extends FieldDeclaration> FieldDeclaration.expandedFields() = new List().add(this);
    eq StaticForFieldDeclaration.expandedFields() = new List<FieldDeclaration>();
    eq ParStaticForFieldDeclaration.expandedFields() {
	ParTypeDecl ht = (ParTypeDecl) hostType();
	GenericTypeDecl gtd = (GenericTypeDecl) ht.genericDecl();
	    
	IteratorDecl id = getIteratorDecl();

	// get the mappings for each element in the iterator decl's range. 
	for ( Iterator subMaps = id.reflectiveElmts().values().iterator();
	      subMaps.hasNext(); ) {
	    Map substitutions = (Map) subMaps.next();

	    // put into the map the parameterization from this
	    for ( int i=0; i<gtd.getNumTypeParameter(); i++) {
		substitutions.put(gtd.getTypeParameter(i),
				  ht.getArgument(i).type());
	    }

	    ExpandedFieldDeclaration fd = substitute(substitutions);
	    fd.expansionSubstitutions = substitutions;
	    fd.original = this; //this.original;

	    fd.is$Final = true;
	    addExpandedFieldDeclaration(fd);
	}

	return getExpandedFieldDeclarationList();
    }

    refine Generics eq ParTypeDecl.fields(String name) {
	SimpleSet set = Generics.ParTypeDecl.fields(name);

	// find reflectively declared, expandable fields
	for ( Iterator refIt = reflectiveFields().iterator(); 
	      refIt.hasNext(); ) {
	    ParStaticForFieldDeclaration fd = (ParStaticForFieldDeclaration) refIt.next();
	    if ( fd.expandable()) {
		List expandedFields = fd.expandedFields();
		for ( int i=0; i<expandedFields.getNumChild(); i++) {
		    FieldDeclaration expandedfd = (FieldDeclaration) expandedFields.getChild(i);
		    if ( expandedfd.name().equals(name))
			set = set.add(expandedfd);
		}
	    }
	}
	return set;
    }

    eq ParTypeDecl.localFieldsMap() {
	HashMap map = super.localFieldsMap();
	
	// find reflectively declared, expandable fields
	for ( Iterator refIt = reflectiveFields().iterator(); 
	      refIt.hasNext(); ) {
	    ParStaticForFieldDeclaration fd = (ParStaticForFieldDeclaration) refIt.next();
	    if ( fd.expandable()) {
		List expandedFields = fd.expandedFields();
		for ( int i=0; i<expandedFields.getNumChild(); i++) {
		    FieldDeclaration expandedfd = (FieldDeclaration) expandedFields.getChild(i);
		    SimpleSet fields = (SimpleSet) map.get(expandedfd.name());
		    if ( fields == null ) fields = SimpleSet.emptySet;
		    fields.add(expandedfd);
		    map.put(expandedfd.name(), fields);
		}
	    }
	}
	return map;
    }

    syn SimpleSet TypeDecl.unrestrictedFields() {
	SimpleSet fields = SimpleSet.emptySet;
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if(getBodyDecl(i) instanceof FieldDeclaration &&
	       !getBodyDecl(i).isReflectiveDecl()) 
		fields = fields.add(getBodyDecl(i));
	}
	return fields;
    }

    // member fields
    eq ClassDecl.unrestrictedFields() {
	SimpleSet fields = super.unrestrictedFields();

	if(hasSuperclass()) {
	    for(Iterator iter = superclass().unrestrictedFields().iterator(); iter.hasNext(); ) {
		FieldDeclaration decl = (FieldDeclaration)iter.next();
		if ( !decl.isReflectiveDecl())
		    fields = fields.add(decl);
	    }
	}
	for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl type = (TypeDecl)outerIter.next();
	    for(Iterator iter = type.unrestrictedFields().iterator(); 
		iter.hasNext(); ) {
		FieldDeclaration decl = (FieldDeclaration)iter.next();
		if ( !decl.isReflectiveDecl())
		    fields = fields.add(decl);
	    }
	}
	return fields;
    }
    
    eq InterfaceDecl.unrestrictedFields() {
	SimpleSet fields = super.unrestrictedFields();

	for(Iterator outerIter = superinterfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)outerIter.next();
	    for(Iterator iter = typeDecl.unrestrictedFields().iterator(); 
		iter.hasNext(); ) {
		FieldDeclaration f = (FieldDeclaration)iter.next();
		if ( !f.isReflectiveDecl())
		    fields = fields.add(f);
	    }
	}
	return fields;
    }

    syn lazy SimpleSet TypeDecl.memberFields(Identifier id) = fields(id);
    syn SimpleSet TypeDecl.localFields(Identifier id) {
	SimpleSet fields = SimpleSet.emptySet;
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if ( getBodyDecl(i) instanceof StaticForFieldDeclaration) {
		StaticForFieldDeclaration fd = (StaticForFieldDeclaration) getBodyDecl(i);
		if ( fd.getIteratorDecl().subsumes(id.enclosingRefIterator(), new HashMap()))
		    fields = fields.add(fd);
	    }
	}
	return fields;
    }

    syn SimpleSet TypeDecl.fields(Identifier id) = localFields(id);
    eq TypeVariable.fields(Identifier id) {
	// if type variable is the base type of nv's iterator decl,
	// then return the patternFieldDecl.
	IteratorDecl idIt = id.enclosingRefIterator();
	Pattern idPattern = idIt.getPattern();
	if ( idPattern.getBaseSet().type().subtype(this) &&
	     idPattern.isFieldPattern() &&
	     ((FieldPattern) idPattern).getID().equals(id.substitutedName())) {
	    return ((FieldPattern) idPattern).patternFieldDeclaration();
	}
	return null;
    }

    eq ClassDecl.fields(Identifier id) {
	SimpleSet fields = localFields(id);
	if ( !fields.isEmpty()) return fields;

	if ( hasSuperclass()) {
	    for(Iterator iter = superclass().fields(id).iterator(); iter.hasNext(); ) {
		FieldDeclaration decl = (FieldDeclaration)iter.next();
		if(!decl.isPrivate() && decl.accessibleFrom(this))
		    fields = fields.add(decl);
	    }
	}
	for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl type = (TypeDecl)outerIter.next();
	    for(Iterator iter = type.fields(id).iterator(); iter.hasNext(); ) {
		FieldDeclaration decl = (FieldDeclaration)iter.next();
		if(!decl.isPrivate() && decl.accessibleFrom(this))
		    fields = fields.add(decl);
	    }
	}
	return fields;
    }
    eq InterfaceDecl.fields(Identifier id) {
	SimpleSet fields = localFields(id);
	if (!fields.isEmpty()) return fields;
	for (Iterator outerIter = superinterfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)outerIter.next();
	    for(Iterator iter = typeDecl.fields(id).iterator(); iter.hasNext(); ) {
		FieldDeclaration f = (FieldDeclaration)iter.next();
		if(f.accessibleFrom(this) && !f.isPrivate()) {
		    fields = fields.add(f);
		}
	    }
	}
	return fields;
    }

    /*
    syn lazy SimpleSet TypeDecl.memberFields(PatternNameVariable name) = fields(name);
    
    syn SimpleSet TypeDecl.localFields(PatternNameVariable nv) {
	SimpleSet fields = SimpleSet.emptySet;
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if ( getBodyDecl(i) instanceof StaticForFieldDeclaration) {
		StaticForFieldDeclaration fd = (StaticForFieldDeclaration) getBodyDecl(i);
		if ( fd.getIteratorDecl().subsumes(nv.enclosingRefIterator(), new HashMap()))
		    fields = fields.add(fd);
	    }
	}
	return fields;
    }

    syn SimpleSet TypeDecl.fields(PatternNameVariable nv) = localFields(nv);
    eq TypeVariable.fields(PatternNameVariable nv) {
	// if type variable is the base type of nv's iterator decl,
	// then return the patternFieldDecl.
	IteratorDecl nvIt = nv.enclosingRefIterator();
	Pattern nvPattern = nvIt.getPattern();
	if ( nvPattern.getBaseSet().type().subtype(this) &&
	     nvPattern.isFieldPattern() &&
	     ((FieldPattern) nvPattern).getID().equals(nv.getID())) {
	    return ((FieldPattern) nvPattern).patternFieldDeclaration();
	}
	return null;
    }

    eq ClassDecl.fields(PatternNameVariable nv) {
	SimpleSet fields = localFields(nv);
	if ( !fields.isEmpty()) return fields;

	if ( hasSuperclass()) {
	    for(Iterator iter = superclass().fields(nv).iterator(); iter.hasNext(); ) {
		FieldDeclaration decl = (FieldDeclaration)iter.next();
		if(!decl.isPrivate() && decl.accessibleFrom(this))
		    fields = fields.add(decl);
	    }
	}
	for(Iterator outerIter = interfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl type = (TypeDecl)outerIter.next();
	    for(Iterator iter = type.fields(nv).iterator(); iter.hasNext(); ) {
		FieldDeclaration decl = (FieldDeclaration)iter.next();
		if(!decl.isPrivate() && decl.accessibleFrom(this))
		    fields = fields.add(decl);
	    }
	}
	return fields;
    }
    eq InterfaceDecl.fields(PatternNameVariable nv) {
	SimpleSet fields = localFields(nv);
	if (!fields.isEmpty()) return fields;
	for (Iterator outerIter = superinterfacesIterator(); outerIter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)outerIter.next();
	    for(Iterator iter = typeDecl.fields(nv).iterator(); iter.hasNext(); ) {
		FieldDeclaration f = (FieldDeclaration)iter.next();
		if(f.accessibleFrom(this) && !f.isPrivate()) {
		    fields = fields.add(f);
		}
	    }
	}
	return fields;
    }
    */
}
