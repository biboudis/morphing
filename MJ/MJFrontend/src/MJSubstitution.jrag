aspect MJSubstitution {
    public IteratorDecl IteratorDecl.substitute(ParTypeDecl parTypeDecl) {
	ParIteratorDecl pid =     new ParIteratorDecl();

	for ( int i=0; i<getNumPatternTypeParameter(); i++) {
	    TypeVariable t = getPatternTypeParameter(i).fullCopy();
	    pid.addPatternTypeParameter((PatternTypeVariable)t.substitute(parTypeDecl).type());
	}
	pid.setPatternNameParameterList(getPatternNameParameterList().fullCopy());

	// create the mapping to be used for pattern and nested pattern
	// substitution.
	HashMap map = new HashMap();
	for ( int i=0; i<getNumPatternTypeParameter(); i++)
	    map.put(getPatternTypeParameter(i), pid.getPatternTypeParameter(i));

	pid.setPattern(getPattern().substitute(map).substitute(parTypeDecl));
	//	pid.setPattern(getPattern().substitute(parTypeDecl));

	for ( int i=0; i<getNumNestedPattern(); i++)
	    pid.addNestedPattern(getNestedPattern(i).substitute(map).substitute(parTypeDecl));
	// pid.addNestedPattern(getNestedPattern(i).substitute(parTypeDecl));
	
	pid.original = this;
	return pid;
    }
    
    syn lazy TypeDecl PatternTypeVariable.substitute(ParTypeDecl parTypeDecl) {
	PatternTypeVariable tv = (PatternTypeVariable) fullCopy();
	// substitute the bounds.
	for ( int i=0; i<getNumTypeBound(); i++) 
	    tv.setTypeBound(getTypeBound(i).type().substitute(parTypeDecl), i);

	return tv;
    }

    public IteratorDecl ParIteratorDecl.original;

    public Pattern Pattern.substitute(ParTypeDecl parTypeDecl) {
	throw new Error("substitute(ParTypeDecl) unsupported by " +
			getClass().getName());
    }
    public MethodPattern MethodPattern.substitute(ParTypeDecl parTypeDecl) {
	return new MethodPattern(getBaseSet().substitute(parTypeDecl),
				 (Modifiers) getModifiers().fullCopy(),
				 getTypeAccess().type().substitute(parTypeDecl),
				 getID(),
				 getParameterList().substitute(parTypeDecl),
				 getExceptionList().substitute(parTypeDecl),
				 
				 new Opt());
    }
    
    public NestedMethodPattern NestedMethodPattern.substitute(ParTypeDecl parTypeDecl) {
	return new NestedMethodPattern(getBaseSet().substitute(parTypeDecl),
				       (Modifiers) getModifiers().fullCopy(),
				       getTypeAccess().type().substitute(parTypeDecl),
				       getID(),
				       getParameterList().substitute(parTypeDecl),
				       getExceptionList().substitute(parTypeDecl),
				       
				       new Opt(),
				       getIsPositive());
    }
    public TrueNestedPattern TrueNestedPattern.substitute(ParTypeDecl parTypeDecl) {
	TrueNestedPattern p = new TrueNestedPattern();
	p.bypassErrorChecking = true;
	return p;
    }

    public BaseSet BaseSet.substitute(ParTypeDecl parTypeDecl) {
	return new BaseSet(getTypeAccess().type().substitute(parTypeDecl),
			   (RefElmt) getRefElmt().fullCopy());
    }

    public ExpandedMethodDecl StaticForMethodDecl.substitute(Map substitution) {
	return new ExpandedMethodDecl((Modifiers) getModifiers().fullCopy(),
				      getTypeAccess().type().substitute(substitution),
				      isNameVariable(getID()) ?
				      (String) substitution.get(getNameVariable(getID())) : getID(),
				      getParameterList().expandParameterList(substitution),
				      getExceptionList().expandAccessList(substitution),
				      new Opt());
    }
    public Pattern Pattern.substitute(Map substitutions) {
	throw new Error("substitute(Map) unsupported by " +
			getClass().getName());
    }

    public MethodPattern MethodPattern.substitute(Map substitutions) {
	String name = getID();
	/*
	if ( isNameVariable(name) && 
	     substitutions.get(getNameVariable(name)) != null ) {
	    name = (String) substitutions.get(getNameVariable(name));
	}
	*/
	// TODO: this is aweful. Need to fix this by changing all
	// identifiers to an Identifier type.
	if ( isNameVariable(name)) {
	    PatternNameVariable nv = getNameVariable(name);
	    Object o = nv.substitute(substitutions);
	    if ( o != null ) {
		if ( o instanceof String ) name = (String) o;
		else name = ((PatternNameVariable) o).getID();
	    }
	}

	return new MethodPattern(getBaseSet().substitute(substitutions),
				 (Modifiers) getModifiers().fullCopy(),
				 getTypeAccess().type().substitute(substitutions),
				 name,
				 getParameterList().substituteAccessList(substitutions),
				 getExceptionList().substituteAccessList(substitutions),
				 new Opt());
    }
    public NestedMethodPattern NestedMethodPattern.substitute(Map substitutions) {
	String name = getID();
	// TODO: this is aweful. Need to fix this by changing all
	// identifiers to an Identifier type.
	if ( isNameVariable(name)) {
	    PatternNameVariable nv = getNameVariable(name);
	    Object o = nv.substitute(substitutions);
	    if ( o != null ) {
		if ( o instanceof String ) name = (String) o;
		else name = ((PatternNameVariable) o).getID();
	    }
	}
	/*
	if ( isNameVariable(name) && 
	     substitutions.get(getNameVariable(name)) != null ) {
	    name = (String) substitutions.get(getNameVariable(name));
	}
	*/
	return new NestedMethodPattern(getBaseSet().substitute(substitutions),
				       (Modifiers) getModifiers().fullCopy(),
				       getTypeAccess().type().substitute(substitutions),
				       name,
				       getParameterList().substituteAccessList(substitutions),
				       getExceptionList().substituteAccessList(substitutions),
				       new Opt(),
				       getIsPositive());	
    }
    public TrueNestedPattern TrueNestedPattern.substitute(Map substitutions) {
	TrueNestedPattern p = new TrueNestedPattern();
	p.bypassErrorChecking = true;
	return p;
    }

    public BaseSet BaseSet.substitute(Map substitutions) {
	return new BaseSet(getTypeAccess().type().substitute(substitutions), getRefElmt());
    }
    
    public java.util.List MethodPattern.substitutedParameterTypes(Map submap) {
	//	List list = getParameterList().expandAccessList(submap);
	List list = getParameterList().substituteAccessList(submap);
	// extract types.
	java.util.List paramTypes = new ArrayList();
	for ( int i=0; i<list.getNumChild(); i++)
	    paramTypes.add(((Access) list.getChild(i)).type());
	return paramTypes;
    }

    public List List.expandParameterList(Map submap) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    ParameterDeclaration node = (ParameterDeclaration) getChild(i);
	    TypeDecl argType = node.getTypeAccess().type();

	    // call substitution first.
	    Access argAccess = argType.substitute(submap);
	    TypeDecl subArgType = argAccess.type();

	    if ( subArgType.isVectorTypeVariable()) {
		List argTypes = subArgType.expandAccessList(submap);
		for ( int j=0; j<argTypes.getNumChild(); j++) {
		    ParameterDeclaration newNode = 
			new ParameterDeclaration((Modifiers) node.getModifiers().fullCopy(),
						 (Access) argTypes.getChild(j),
						 node.getID() + j);
		    list.add(newNode);
		}
	    } else {
		ParameterDeclaration newNode = 
		    new ParameterDeclaration((Modifiers) node.getModifiers().fullCopy(),
					     argAccess,
					     node.getID());
		list.add(newNode);
	    }
	}
	return list;
    }

    public List List.substituteAccessList(Map substitutions) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    Access node = (Access) getChild(i);
	    List vlist = node.type().substituteToList(substitutions);
	    for ( int j=0; j<vlist.getNumChild(); j++)
		list.add(vlist.getChild(j));
	    
	    //		list.add(node.type().substitute(substitutions));
	}
	return list;
    }

    public Access TypeDecl.substitute(Map submap) {
	return createBoundAccess();
    }
    public Access TypeVariable.substitute(Map submap) {
	if ( submap.containsKey(this))
	    return ((TypeDecl) submap.get(this)).substitute(submap);
	return createBoundAccess();
    }
    public Access ParTypeDecl.substitute(Map submap) {
	java.util.ArrayList list = new java.util.ArrayList();
	for ( int i=0; i<getNumArgument(); i++) 
	    list.add(getArgument(i).type().substitute(submap).type());
	return ((GenericTypeDecl) genericDecl()).lookupParTypeDecl(list).createBoundAccess();
    }
    
    public Access RawClassDecl.substitute(Map submap) { return createBoundAccess(); }
    public Access RawInterfaceDecl.substitute(Map submap) { return createBoundAccess(); }

    public List TypeDecl.substituteToList(Map submap) {
	return new List().add(substitute(submap));
    }
    public List VectorTypeVariable.substituteToList(Map submap) {
	List vlist = expandAccessList(submap);
	if ( vlist.getNumChild() == 0 && !isMapped(submap)) 
	    vlist.add(substitute(submap));
	return vlist;
    }

    public List List.expandAccessList(Map submap) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    Access node = (Access) getChild(i);
	    List subs = node.type().expandAccessList(submap);
	    for ( int j=0; j<subs.getNumChild(); j++)
		list.add(subs.getChild(j));
	}
	return list;
    }
    syn lazy List TypeDecl.expandAccessList(Map submap ) {
	return new List().add(substitute(submap));
    }
    eq VectorTypeVariable.expandAccessList(Map submap) {
	List subed = new List();

	// check whether there is a map for this type in submap.
	if ( submap.containsKey(this))
	    return ((TypeDecl) submap.get(this)).expandAccessList(submap);

	for ( int i=0; i<getNumMatchedVectorTypeVariable(); i++) {
	    MatchedVectorTypeVariable t = getMatchedVectorTypeVariable(i);
	    if ( submap.containsKey(t) && submap.get(t) != null )
		subed.add(((TypeDecl) submap.get(t)).substitute(submap));
	}

	return subed;
    }
    
    public Object PatternNameVariable.substitute(Map uniMap) {
	if ( uniMap.containsKey(this) ) {
	    if ( uniMap.get(this) instanceof String )
		return uniMap.get(this);
	    return ((PatternNameVariable) uniMap.get(this)).substitute(uniMap);
	} 
	return null;
    }

}
