aspect MJSubstitution {

    protected StaticForMethodDecl StaticForMethodDecl.original;
    protected StaticForFieldDeclaration StaticForFieldDeclaration.original;

    syn StaticForMethodDecl StaticForMethodDecl.original() = original != null ? original : this;

    HashMap StaticForMethodDecl.parMethodDeclMap = new HashMap();

    public BodyDecl StaticForMethodDecl.p(ParTypeDecl parTypeDecl) {
	// check that this substitution doesn't already exist.
	if ( parMethodDeclMap.get(parTypeDecl) != null)
	    return (BodyDecl) parMethodDeclMap.get(parTypeDecl);
	
	// TODO: this is not good enough for generic methods.
	// Might need a StaticForGenericMethodDecl...
	// What I really need is for StaticForMethodDecl to be a proxy for
	// the underlying MethodDecl. But it is simply too hard to duplicate
	// all the functionalities in MethodDecl.
	// May be a nice functionality for JastAdd.
	ParStaticForMethodDecl m = 
	    new ParStaticForMethodDecl((Modifiers)getModifiers().fullCopy(), 
				       getTypeAccess().type().substituteReturnType(parTypeDecl),
				       getID(),
				       // TODO: this list needs to be substituted with whatever IteratorDecl's substitutions are.
				       getParameterList().substitute(parTypeDecl),
				       getExceptionList().substitute(parTypeDecl),
				       new Opt(),
				       getIteratorDecl().substitute(parTypeDecl),
				       new List(), new List());
	m.original = this;

	m.is$Final = true;
	((TypeDecl)parTypeDecl).addBodyDecl(m);

	parMethodDeclMap.put(parTypeDecl, m);

	return m;
    }

    HashMap StaticForFieldDeclaration.parFieldDeclMap = new HashMap();
    public BodyDecl StaticForFieldDeclaration.p(ParTypeDecl parTypeDecl) {
	if ( parFieldDeclMap.get(parTypeDecl) != null )
	    return (BodyDecl) parFieldDeclMap.get(parTypeDecl);

	ParStaticForFieldDeclaration f =
	    new ParStaticForFieldDeclaration((Modifiers) getModifiers().fullCopy(),
					     getTypeAccess().type().substitute(parTypeDecl),
					     getID(), new Opt(),
					     getIteratorDecl().substitute(parTypeDecl),
					     new List());
	f.original = this;
	f.is$Final = true;
	((TypeDecl) parTypeDecl).addBodyDecl(f);
	parFieldDeclMap.put(parTypeDecl, f);
	return f;
    }

    public IteratorDecl IteratorDecl.substitute(ParTypeDecl parTypeDecl) {
	ParIteratorDecl pid =     new ParIteratorDecl();

	for ( int i=0; i<getNumPatternTypeParameter(); i++) {
	    TypeVariable t = getPatternTypeParameter(i).fullCopy();
	    pid.addPatternTypeParameter((PatternTypeVariable)t.substitute(parTypeDecl).type());
	}
	pid.setPatternNameParameterList(getPatternNameParameterList().fullCopy());

	// create the mapping to be used for pattern and nested pattern
	// substitution.
	HashMap map = new HashMap();
	for ( int i=0; i<getNumPatternTypeParameter(); i++)
	    map.put(getPatternTypeParameter(i), pid.getPatternTypeParameter(i));

	pid.setPattern(getPattern().substitute(map).substitute(parTypeDecl));
	//	pid.setPattern(getPattern().substitute(parTypeDecl));

	for ( int i=0; i<getNumNestedPattern(); i++)
	    pid.addNestedPattern(getNestedPattern(i).substitute(map).substitute(parTypeDecl));
	// pid.addNestedPattern(getNestedPattern(i).substitute(parTypeDecl));
	
	pid.original = this;
	return pid;
    }
    
    syn lazy TypeDecl PatternTypeVariable.substitute(ParTypeDecl parTypeDecl) {
	PatternTypeVariable tv = (PatternTypeVariable) fullCopy();
	// substitute the bounds.
	for ( int i=0; i<getNumTypeBound(); i++) 
	    tv.setTypeBound(getTypeBound(i).type().substitute(parTypeDecl), i);

	return tv;
    }

    public IteratorDecl ParIteratorDecl.original;

    public Pattern Pattern.substitute(ParTypeDecl parTypeDecl) {
	throw new Error("substitute(ParTypeDecl) unsupported by " +
			getClass().getName());
    }

    // TODO: need to recycle these substituted patterns. Might become
    // a memory sucker.
    public FieldPattern FieldPattern.substitute(ParTypeDecl parTypeDecl) {
	FieldPattern fp = new FieldPattern(getBaseSet().substitute(parTypeDecl),
					   (Modifiers) getModifiers().fullCopy(),
					   getTypeAccess().type().substitute(parTypeDecl),
					   getID(), new Opt(), new List());
	fp.is$Final = true;
	fp.bypassErrorChecking = true;
	this.addSubFieldPattern(fp);
	return fp;
    }
    public NestedFieldPattern NestedFieldPattern.substitute(ParTypeDecl parTypeDecl) {
	NestedFieldPattern nfp = 
	    new NestedFieldPattern(getBaseSet().substitute(parTypeDecl),
				   (Modifiers) getModifiers().fullCopy(),
				   getTypeAccess().type().substitute(parTypeDecl),
				   getID(), new Opt(), new List(),
				   getIsPositive());
	nfp.is$Final = true;
	nfp.bypassErrorChecking = true;
	addSubFieldPattern(nfp);
	return nfp;
    }

    public MethodPattern MethodPattern.substitute(ParTypeDecl parTypeDecl) {
	MethodPattern mp = 
	    new MethodPattern(getBaseSet().substitute(parTypeDecl),
			      (Modifiers) getModifiers().fullCopy(),
			      getTypeAccess().type().substitute(parTypeDecl),
			      getID(),
			      getParameterList().substitute(parTypeDecl),
			      getExceptionList().substitute(parTypeDecl),
			      new Opt(), new List());
	mp.is$Final = true;
	mp.bypassErrorChecking = true;
	this.addSubMethodPattern(mp);
	return mp;
    }
    
    public NestedMethodPattern NestedMethodPattern.substitute(ParTypeDecl parTypeDecl) {
	NestedMethodPattern nmp = 
	    new NestedMethodPattern(getBaseSet().substitute(parTypeDecl),
				    (Modifiers) getModifiers().fullCopy(),
				    getTypeAccess().type().substitute(parTypeDecl),
				    getID(),
				    getParameterList().substitute(parTypeDecl),
				    getExceptionList().substitute(parTypeDecl),
				    
				    new Opt(), new List(),
				    getIsPositive());
	nmp.is$Final = true;
	nmp.bypassErrorChecking = true;
	this.addSubMethodPattern(nmp);
	return nmp;
    }
    public TrueNestedPattern TrueNestedPattern.substitute(ParTypeDecl parTypeDecl) {
	TrueNestedPattern p = new TrueNestedPattern();
	p.bypassErrorChecking = true;
	return p;
    }

    public BaseSet BaseSet.substitute(ParTypeDecl parTypeDecl) {
	return new BaseSet(getTypeAccess().type().substitute(parTypeDecl),
			   (RefElmt) getRefElmt().fullCopy());
    }

    public MethodDecl MethodDecl.substitute(Map substitutions) {
	return (MethodDecl) fullCopy();
    }

    public ExpandedMethodDecl StaticForMethodDecl.substitute(Map substitution) {
	return new ExpandedMethodDecl((Modifiers) getModifiers().fullCopy(),
				      getTypeAccess().type().substitute(substitution),
				      substitutedName(getID(), substitution),
				      getParameterList().expandParameterList(substitution),
				      getExceptionList().expandAccessList(substitution),
				      new Opt());
    }
    public ExpandedFieldDeclaration StaticForFieldDeclaration.substitute(Map substitution) {
	return new ExpandedFieldDeclaration((Modifiers) getModifiers().fullCopy(),
					    getTypeAccess().type().substitute(substitution),
					    substitutedName(getID(), substitution),
					    new Opt());
    }

    public Pattern Pattern.substitute(Map substitutions) {
	throw new Error("substitute(Map) unsupported by " +
			getClass().getName());
    }
    public String Pattern.substitutedName(String name, Map substitutions) {
	Identifier nameId = new Identifier(name, enclosingRefIterator(),
					   substitutions);
	return nameId.substitutedName();
    }
    public String BodyDecl.substitutedName(String name, Map substitutions) {
	Identifier nameId = new Identifier(name, refIterator(), substitutions);
	return nameId.substitutedName();
    }
    
    public Object PatternNameVariable.substitute(Map uniMap) {
	if ( uniMap.containsKey(this) ) {
	    if ( uniMap.get(this) instanceof String )
		return uniMap.get(this);
	    return ((PatternNameVariable) uniMap.get(this)).substitute(uniMap);
	} 
	return this;
    }


    public FieldPattern FieldPattern.substitute(Map substitutions) {
	String name = substitutedName(getID(), substitutions);

	FieldPattern fp =
	    new FieldPattern(getBaseSet().substitute(substitutions),
			     (Modifiers) getModifiers().fullCopy(),
			     getTypeAccess().type().substitute(substitutions),
			     name, new Opt(), new List());
	fp.is$Final = true;
	fp.bypassErrorChecking = true;
	this.addSubFieldPattern(fp);
	return fp;
    }
    public NestedFieldPattern NestedFieldPattern.substitute(Map substitutions) {
	String name = substitutedName(getID(), substitutions);
	
	NestedFieldPattern nfp =
	    new NestedFieldPattern(getBaseSet().substitute(substitutions),
				   (Modifiers) getModifiers().fullCopy(),
				   getTypeAccess().type().substitute(substitutions),
				   name,new Opt(), new List(),
				   getIsPositive());	
	nfp.is$Final = true;
	nfp.bypassErrorChecking = true;
	addSubFieldPattern(nfp);
	return nfp;
    }
    
    public MethodPattern StaticMethodPattern.substitute(Map substitutions) {
	return this;
    }

    public MethodPattern MethodPattern.substitute(Map substitutions) {
	String name = substitutedName(getID(), substitutions);
	MethodPattern mp =
	    new MethodPattern(getBaseSet().substitute(substitutions),
			      (Modifiers) getModifiers().fullCopy(),
			      getTypeAccess().type().substitute(substitutions),
			      name,
			      getParameterList().substituteAccessList(substitutions),
			      getExceptionList().substituteAccessList(substitutions),
			      new Opt(), new List());
	mp.is$Final = true;
	mp.bypassErrorChecking = true;
	addSubMethodPattern(mp);
	return mp;
    }
    public NestedMethodPattern NestedMethodPattern.substitute(Map substitutions) {
	String name = substitutedName(getID(), substitutions);
	NestedMethodPattern nmp = 
	    new NestedMethodPattern(getBaseSet().substitute(substitutions),
				    (Modifiers) getModifiers().fullCopy(),
				    getTypeAccess().type().substitute(substitutions),
				    name,
				    getParameterList().substituteAccessList(substitutions),
				    getExceptionList().substituteAccessList(substitutions),
				    new Opt(), new List(),
				    getIsPositive());	
	nmp.is$Final = true;
	nmp.bypassErrorChecking = true;
	addSubMethodPattern(nmp);
	return nmp;
    }
    public TrueNestedPattern TrueNestedPattern.substitute(Map substitutions) {
	TrueNestedPattern p = new TrueNestedPattern();
	p.bypassErrorChecking = true;
	return p;
    }

    public BaseSet BaseSet.substitute(Map substitutions) {
	return new BaseSet(getTypeAccess().type().substitute(substitutions), getRefElmt());
    }
    
    public java.util.List MethodPattern.substitutedParameterTypes(Map submap) {
	//	List list = getParameterList().expandAccessList(submap);
	List list = getParameterList().substituteAccessList(submap);
	// extract types.
	java.util.List paramTypes = new ArrayList();
	for ( int i=0; i<list.getNumChild(); i++)
	    paramTypes.add(((Access) list.getChild(i)).type());
	return paramTypes;
    }

    public List List.expandParameterList(Map submap) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    ParameterDeclaration node = (ParameterDeclaration) getChild(i);
	    TypeDecl argType = node.getTypeAccess().type();

	    // call substitution first.
	    Access argAccess = argType.substitute(submap);
	    TypeDecl subArgType = argAccess.type();

	    if ( subArgType.isVectorTypeVariable()) {
		List argTypes = subArgType.expandAccessList(submap);
		for ( int j=0; j<argTypes.getNumChild(); j++) {
		    ParameterDeclaration newNode = 
			new ParameterDeclaration((Modifiers) node.getModifiers().fullCopy(),
						 (Access) argTypes.getChild(j),
						 node.getID() + j);
		    list.add(newNode);
		}
	    } else {
		ParameterDeclaration newNode = 
		    new ParameterDeclaration((Modifiers) node.getModifiers().fullCopy(),
					     argAccess,
					     node.getID());
		list.add(newNode);
	    }
	}
	return list;
    }

    public List List.substituteAccessList(Map substitutions) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    Access node = (Access) getChild(i);
	    List vlist = node.type().substituteToList(substitutions);
	    for ( int j=0; j<vlist.getNumChild(); j++)
		list.add(vlist.getChild(j));
	    
	    //		list.add(node.type().substitute(substitutions));
	}
	return list;
    }

    public Access TypeDecl.substitute(Map submap) {
	return createBoundAccess();
    }
    public Access TypeVariable.substitute(Map submap) {
	if ( submap.containsKey(this))
	    return ((TypeDecl) submap.get(this)).substitute(submap);
	return createBoundAccess();
    }
    public Access ParTypeDecl.substitute(Map submap) {
	java.util.ArrayList list = new java.util.ArrayList();
	for ( int i=0; i<getNumArgument(); i++) 
	    list.add(getArgument(i).type().substitute(submap).type());
	return ((GenericTypeDecl) genericDecl()).lookupParTypeDecl(list).createBoundAccess();
    }
    
    public Access RawClassDecl.substitute(Map submap) { return createBoundAccess(); }
    public Access RawInterfaceDecl.substitute(Map submap) { return createBoundAccess(); }

    public List TypeDecl.substituteToList(Map submap) {
	return new List().add(substitute(submap));
    }
    public List VectorTypeVariable.substituteToList(Map submap) {
	List vlist = expandAccessList(submap);
	if ( vlist.getNumChild() == 0 && !isMapped(submap)) 
	    vlist.add(substitute(submap));
	return vlist;
    }

    public List List.expandAccessList(Map submap) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    Access node = (Access) getChild(i);
	    List subs = node.type().expandAccessList(submap);
	    for ( int j=0; j<subs.getNumChild(); j++)
		list.add(subs.getChild(j));
	}
	return list;
    }
    syn lazy List TypeDecl.expandAccessList(Map submap ) {
	return new List().add(substitute(submap));
    }
    eq VectorTypeVariable.expandAccessList(Map submap) {
	List subed = new List();

	// check whether there is a map for this type in submap.
	if ( submap.containsKey(this))
	    return ((TypeDecl) submap.get(this)).expandAccessList(submap);

	for ( int i=0; i<getNumMatchedVectorTypeVariable(); i++) {
	    MatchedVectorTypeVariable t = getMatchedVectorTypeVariable(i);
	    if ( submap.containsKey(t) && submap.get(t) != null )
		subed.add(((TypeDecl) submap.get(t)).substitute(submap));
	}

	return subed;
    }
}
