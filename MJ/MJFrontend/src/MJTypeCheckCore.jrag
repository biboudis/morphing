aspect MJTypeCheckCore {

    /**
     * This method is unique from m if
     * 1. their signatures (method name + parameters) do not unify  OR
     * 2. if signatures unify, return types unify, and they are not defined
     *    in the same type. (i.e. defined in sub/super class) OR
     * 3. if 1 and 2 both fails, the unification mapping causing the
     *    non-uniqueness cause mutually exclusive pattern conditions.
     **/
    syn lazy boolean MethodDecl.isUniqueFrom(MethodDecl m) {
	if ( this == m) return false;

	Collection uniTypeVars = m.patternTypeVariables();
	uniTypeVars.addAll(patternTypeVariables());

	Collection uniNameVars = m.patternNameVariables();
	uniNameVars.addAll(patternNameVariables());

	HashMap uniMap = new HashMap();

	// unify signature.
	if (!canUnifySignature(m, uniMap, uniTypeVars, uniNameVars))
	    return true;
	
	// unify return type.	
	// if return type unifies and the host types are different, then
	// methods are still unique.
	if ( m.type().unifiesWith(this.type(), uniMap, uniTypeVars)) {
	    if (hostType() != m.hostType()) 
		return true;
	} else 
	    return true;
	
	// check whether unification mapping cause mutually exclusive
	// pattern conditions.
	Collection patternConditions = new ArrayList();
	if ( isReflectiveDecl())
	    patternConditions.addAll(refIterator().getPatternConditions());
	if ( m.isReflectiveDecl())
	    patternConditions.addAll(m.refIterator().getPatternConditions());
	if ( hasMutualExclusiveConditions(patternConditions, uniMap))
	    return true;

	return false;
    }

    syn lazy boolean MethodDecl.isSubsumedBy(IteratorDecl id, HashMap map) {
	// first, this method needs to fall within the base pattern
	// and the substitution mappings need to statisfy the nested conditions

	// 1.method's declaring type needs to be a supertype of pattern's base type
	TypeDecl baseType = id.getPattern().getBaseSet().type();
	if ( !baseType.subtype(hostType()))
	    return false;

	PatternMethodDecl md = id.getPattern().patternMethodDecl();
	// 2. we need to be able to unify the signature and the return type
	if ( !canUnifySignature(md, map, id.patternTypeVariables(),
				id.patternNameVariables()) ||
	     // check return type.
	     !type().unifiesWith(md.type(),map, id.patternTypeVariables()) ||
	     // check modifiers.
	     !getModifiers().unifiesWith(md.getModifiers()))
	    return false;
	
	// check each nested pattern condition is satisfied.
	for ( int i=0; i<id.getNumNestedPattern(); i++ ) {
	    if ( !id.getNestedPattern(i).satisfiedBy(map))
		return false;
	}

	return true;
    }

    syn lazy boolean NestedPattern.satisfiedBy(Map uniMap) {
	// expand the methods in the pattern after substitution.
	Map methods = substitute(uniMap).getBaseSet().type().unrestrictedMethodsSignatureMap();	
	int matched = 0;
	PatternMethodDecl pmd = patternMethodDecl();
	for ( Iterator mIt = methods.values().iterator(); mIt.hasNext(); ) {
	    MethodDecl md = (MethodDecl) mIt.next();
	    if ( md.canUnifySignature(pmd, uniMap, 
				      patternNameVariables(),
				      patternTypeVariables()) &&
		 md.type().unifiesWith(pmd.type(),
				       uniMap,patternTypeVariables()) &&
		 md.getModifiers().unifiesWith(pmd.getModifiers()))
		matched++;
	}
	return (getIsPositive() && matched > 0) ||
	    (!getIsPositive() && matched == 0 );
    }
    eq TrueNestedPattern.satisfiedBy(Map uniMap) = true;

    public boolean MethodDecl.hasMutualExclusiveConditions(Collection patternConditions, Map uniMap) {
	for ( Iterator outerIt = patternConditions.iterator(); outerIt.hasNext(); ) {
	    Pattern p1 = (Pattern) outerIt.next();
	    for ( Iterator innerIt = patternConditions.iterator(); innerIt.hasNext(); ) {
		Pattern p2 = (Pattern) innerIt.next();
		if ( p1 == p2) continue;
		
		// first, the patterns must be iterating over types in the same
		// hierarchy.
		if ( !p1.reflectiveBaseType().subtype(p2.reflectiveBaseType()) &&
		     !p2.reflectiveBaseType().subtype(p2.reflectiveBaseType()))
		    continue;

		if ( p1.isPositiveCondition() && p2.isPositiveCondition()) {
		    // if p1 and p2 have same method argument types, but
		    // different return types, then these conditions
		    // are disjoint.
		    List p1params = p1.substitutedParameters(uniMap);
		    List p2params = p2.substitutedParameters(uniMap);
		    
		    if ( sameParameterLists(p1params,p2params))
			continue;

		    if ( !p1.getTypeAccess().type().substituteUniMap(uniMap).equals(p2.getTypeAccess().type().substituteUniMap(uniMap)))
			return true;

		} else if ( p1.isPositiveCondition() || p2.isPositiveCondition()) {
		    // if p1 and p2 have exact same argument and return types.
		    // then these conditions are disjoint.
		    List p1params = p1.substitutedParameters(uniMap);
		    List p2params = p2.substitutedParameters(uniMap);
		    
		    if ( !sameParameterLists(p1params,p2params))
			continue;
		    
		    if ( p1.getTypeAccess().type().substituteUniMap(uniMap).equals(p2.getTypeAccess().type().substituteUniMap(uniMap)))
			return true;
		}
	    }
	}
	return false;
    }

    public boolean MethodDecl.sameParameterLists(List p1params, List p2params) {
	if ( p1params.getNumChild() != p2params.getNumChild())
	    return false;
	for ( int i=0; i<p1params.getNumChild(); i++) {
	    if (!p1params.getChild(i).equals(p2params.getChild(i)))
		return false;
	}
	return true;
    }

    public List Pattern.substitutedParameters(Map uniMap) {
	List l = new List();
	for ( int i=0; i<getNumParameter(); i++) {
	    List pl = getParameter(i).type().substituteUniMap(uniMap);
	    for ( int j=0; j<pl.getNumChild(); j++)
		l.add(pl.getChild(j));
	}
	return l;
    }

    syn List TypeDecl.substituteUniMap(Map uniMap) {
	if ( uniMap.containsKey(this)) 
	    return new List().add(((TypeDecl) uniMap.get(this)).substitute(uniMap));
	return new List().add(this);
    }
    eq VectorTypeVariable.substituteUniMap(Map uniMap) {
	if ( uniMap.containsKey(this)) {
	    List types = (List) uniMap.get(this);
	    for ( int i=0; i<types.getNumChild(); i++) {
		types.setChild(((TypeDecl) types.getChild(i)).substituteUniMap(uniMap), i);
	    }
	}
	return new List().add(this);
    }
    eq ParTypeDecl.substituteUniMap(Map uniMap) {
	GenericTypeDecl g = (GenericTypeDecl) genericDecl();
	ArrayList al = new ArrayList();
	for ( int i=0; i<getNumArgument(); i++) {
	    al.add(getArgument(i).type().substituteUniMap(uniMap));
	}
	return new List().add(g.lookupParTypeDecl(al));
    }


    syn lazy boolean MethodDecl.canOnewayUnifyTo(MethodDecl m) {
	return canUnifySignature(m, new HashMap(), 
				 patternTypeVariables(),
				 patternNameVariables());
    }

    syn lazy boolean MethodDecl.isNameVariable(String name, Collection uniNameVars) {
	for ( Iterator nameIt = uniNameVars.iterator(); nameIt.hasNext(); ) {
	    PatternNameVariable pv = (PatternNameVariable) nameIt.next();
	    if ( pv.getID().equals(name) && 
		 refIterator() == pv.enclosingRefIterator())
		return true;
	}
	return false;
    }

    syn lazy PatternNameVariable MethodDecl.getNameVariable(String name, Collection uniNameVars) {
	for ( Iterator nameIt = uniNameVars.iterator(); nameIt.hasNext(); ) {
	    PatternNameVariable pv = (PatternNameVariable) nameIt.next();
	    if ( pv.getID().equals(name) && 
		 refIterator() == pv.enclosingRefIterator())
		return pv;
	}
	return null;
    }
    syn lazy boolean Modifiers.declaredFromPattern() {
	ASTNode p = parent;
	while ( p != null ) {
	    if ( p instanceof Pattern ) return true;
	    else if ( p instanceof PatternMethodDecl) return true;
	    p = p.parent;
	}
	return false;
    }


    syn lazy boolean Modifiers.unifiesWith(Modifiers mods) {
	for ( int i=0; i<getNumModifier(); i++) {
	    int r = mods.unifiesWith(getModifier(i));
	    if ( r > 0 ) continue;
	    else if ( r < 0 ) return false;
	    else if ( !declaredFromPattern()) return false;
	}
	return true;
    }

    /**
     * returns:
     * 1 if Modifiers has exactly a modifier that matches m
     * 0 if Modifiers has no modifier that matches m, but no modifier that
     *   definitely excludes m, either (i.e. no(final))
     * -1 Modifiers definitely does not match m.
     **/
    syn lazy int Modifiers.unifiesWith(Modifier m) {
	/**
	 * m can be modifier with a list of modifiers if
	 * 1. there is a modifier in the list that unifies with m
	 * 2. there is not a modifier in the list that precludes m.
	 **/
	boolean foundUniMod = false;
	for ( int i=0; i<getNumModifier(); i++) {
	    if ( getModifier(i).unifiesWith(m)) 
		foundUniMod = true;
	    // if a preclude modifier is found, immediately return.
	    if ( getModifier(i).precludes(m)) return -1;
	}
	return foundUniMod ? 1 : 0;
    }

    syn lazy boolean MethodDecl.canUnifySignature(MethodDecl m, 
						  Map uniMap,
						  Collection uniTypeVars,
						  Collection uniNameVars ) {
	if ( this == m ) return true;
	// easiest thing to check is the names.
	if ( isNameVariable(getID(), uniNameVars)) {
	    if ( m.isNameVariable(m.getID(), uniNameVars))
		uniMap.put(getNameVariable(getID(), uniNameVars),
			   m.getNameVariable(m.getID(), uniNameVars));
	    else uniMap.put(getNameVariable(getID(), uniNameVars),m.getID());
	} else if ( m.isNameVariable(m.getID(), uniNameVars))
	    uniMap.put(m.getNameVariable(m.getID(), uniNameVars), 
		       getID());
	else return false;
	
	// unify parameter types.
	if ( !type().typeListUnifies(parameterTypes(), m.parameterTypes(), uniMap, uniTypeVars)) return false;

	return true;
    }

    syn lazy boolean NestedPattern.implies(NestedPattern p, Map uniMap ) {
	if ( this == p ) return true;
	if ( getIsPositive() ^ p.getIsPositive()) return false;
	
	if ( getIsPositive()) {
	    // +THIS implies +p iff p subsumes THIS
	    return p.subsumes(this, uniMap);
	} else
	    // -THIS implies -p iff THIS subsumes p
	    return subsumes(p, uniMap);
    }
    eq TrueNestedPattern.implies(NestedPattern p, Map uniMap) = true;

    syn lazy NestedPattern NestedPattern.difference(NestedPattern p, Map uniMap) {
	if ( getIsPositive() && p.subsumes(this, uniMap) ||
	     !getIsPositive() && this.subsumes(p, uniMap)) {
	    TrueNestedPattern tnp = new TrueNestedPattern(); 
	    tnp.bypassErrorChecking = true;
	    return tnp;
	}
	return this;
    }
    eq TrueNestedPattern.difference(NestedPattern p, Map uniMap) {
	if ( p instanceof TrueNestedPattern ) return this;

	// flip the sign of p, apply mapping to rest.
	NestedPattern np = p.substitute(uniMap);
	np.setIsPositive(!p.getIsPositive());
	return np;
    }

    syn lazy boolean Pattern.subsumes(Pattern p, Map uniMap) {
	if ( this == p ) return true;

	// this's base type must be a supertype of p's base type.
	if ( !p.reflectiveBaseType().subtype(this.reflectiveBaseType()))
	    return false;
	
	// signitures must unify using this' type and name variables.
	PatternMethodDecl thisMd = patternMethodDecl();
	PatternMethodDecl pMd = p.patternMethodDecl();

	// name + arg types unify
	if ( !thisMd.canUnifySignature(pMd, uniMap, patternTypeVariables(), patternNameVariables())) return false;

	// return types unify
	if ( !getTypeAccess().type().unifiesWith(pMd.type(), uniMap, patternTypeVariables()))
	    return false;

	// exceptions must unify.
	if ( !TypeDecl.typeListUnifies(exceptionTypes(),p.exceptionTypes(),
				       uniMap, patternTypeVariables()))
	    return false;

	return true;
    }

    public ArrayList MethodDecl.parameterTypes () { 
	ArrayList list = new ArrayList();
	for ( int i=0; i<getNumParameter(); i++ )
	    list.add(getParameter(i).type());
	return list;
    }
    public ArrayList MethodDecl.exceptionTypes () {
	ArrayList list = new ArrayList();
	for ( int i=0; i<getNumException(); i++) 
	    list.add(getException(i).type());
	return list;
    }

    public ArrayList Pattern.parameterTypes() {
	ArrayList list = new ArrayList();
	for ( int i=0; i<getNumParameter(); i++ )
	    list.add(getParameter(i).type());
	return list;	
    }
    public ArrayList Pattern.exceptionTypes () {
	ArrayList list = new ArrayList();
	for ( int i=0; i<getNumException(); i++) 
	    list.add(getException(i).type());
	return list;
    }


    refine Generics public void ParTypeAccess.typeCheck() {
	Generics.ParTypeAccess.typeCheck();

	TypeDecl td = genericDecl();
	if ( td instanceof GenericTypeDecl ) {
	    GenericTypeDecl decl = (GenericTypeDecl) td;
	    for ( int i=0; i<getNumTypeArgument(); i++) {
		TypeVariable tv = ((GenericTypeDecl) decl.original()).getTypeParameter(i);
		if (tv.isConstrainedTypeVariable()) {
		    if ( tv.mustbeClass() &&
			 (getTypeArgument(i).type().isTypeVariable() ? 
			  !((TypeVariable) getTypeArgument(i).type()).mustbeClass() : 
			  !getTypeArgument(i).type().isClassDecl()))
			error("type argument " + i + " is not a class.");
		    if ( tv.mustbeInterface() &&
			 (getTypeArgument(i).type().isTypeVariable() ?
			  !((TypeVariable) getTypeArgument(i).type()).mustbeInterface() : !getTypeArgument(i).type().isInterfaceDecl()))
			error("type argument " + i + " is not an interface.");
		}
	    }

	}
    }

    public void TypeAccess.typeCheck() {
	TypeDecl t = type();
	// Some types cannot be accessed as raw. But only report this
	// as an error if this is not a child of an import statement.
	if ( !fromImportDecl() && isRaw() && t instanceof ParTypeDecl && 
	     ((ParTypeDecl) t).genericDecl().needsExpansion())
	    error(((ParTypeDecl) t).genericDecl().fullName() + 
		  " cannot be used as raw type.");

	// type variables used in declaration must be bounded by the primary 
	// pattern.
	if ( t.isTypeVariable() && !bound((TypeVariable) t))
	    error(t.fullName() + " is not bounded.");
    }

    syn lazy boolean TypeAccess.fromImportDecl() {
	ASTNode parent = this.parent;
	while ( parent != null ) {
	    if ( parent instanceof ImportDecl ) return true;
	    parent = parent.parent;
	}
	return false;
    }
}
