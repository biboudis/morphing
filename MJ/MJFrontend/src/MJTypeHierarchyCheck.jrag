aspect MJTypeHierarchyCheck {
    // define attribute determining which type can be a superclass.
    syn boolean TypeDecl.canbeSuperclass() = false;
    eq ClassDecl.canbeSuperclass() = true;
    eq ConstrainedTypeVariable.canbeSuperclass() = getConstraint().equals("class");

    // attribute for which type can be a superinterface.
    syn boolean TypeDecl.canbeSuperinterface() = false;
    eq InterfaceDecl.canbeSuperinterface() = true;
    eq ConstrainedTypeVariable.canbeSuperinterface() = getConstraint().equals("interface");

    refine TypeHierarchyCheck public void ClassDecl.nameCheck() {
	super.nameCheck();
	if(hasSuperClassAccess() && 
	   !getSuperClassAccess().type().canbeSuperclass())
	    error("class may not inherit from " + getSuperClassAccess().type().typeName());
	if(isObject() && hasSuperClassAccess())
	    error("class Object may not have superclass");
	if(isObject() && getNumImplements() != 0)
	    error("class Object may not implement interfaces");
	
	// 8.1.3
	if(isCircular())
	    error("circular inheritance dependency in " + typeName()); 
      
	// 8.1.4
	HashSet set = new HashSet();
	for(int i = 0; i < getNumImplements(); i++) {
	    TypeDecl decl = getImplements(i).type();
	    if(!decl.canbeSuperinterface() && !decl.isUnknown())
		error("type " + fullName() + " tries to implement non interface type " + decl.fullName());
	    if(set.contains(decl))
		error("type " + decl.fullName() + " mentionened multiple times in implements clause");
	    set.add(decl);
	}

	// TODO: this needs to be fixed!  Does not yet take care of 
	// reflective declarations. -- ssh
	for(Iterator iter = interfacesMethodsIterator(); iter.hasNext(); ) {
	    MethodDecl m = (MethodDecl)iter.next();
	    if(localMethodsSignature(m.signature()).isEmpty()) {
		for(Iterator i2 = superclass().methodsSignature(m.signature()).iterator(); i2.hasNext(); ) {
		    MethodDecl n = (MethodDecl)i2.next();
		    if(n.accessibleFrom(this)) {
			interfaceMethodCompatibleWithInherited(m, n);
		    }
		}
		for(Iterator i2 = interfacesMethodsSignature(m.signature()).iterator(); i2.hasNext(); ) {
		    MethodDecl n = (MethodDecl)i2.next();
		    if(!n.mayOverrideReturn(m) && !m.mayOverrideReturn(n))
			error("the return type of method " + m.signature() + " in " + m.hostType().typeName() + 
			      " does not match the return type of method " + n.signature() + " in " + 
			      n.hostType().typeName() + " and may thus not be overriden");
		}
	    }
	}
    }
}
