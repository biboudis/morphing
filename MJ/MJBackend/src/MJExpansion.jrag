aspect MJExpansion {

    protected void ParClassDecl.expand(ClassNode cn) {
	// change name
	cn.name = expandedName();
	
	// inspect methods for reflectively declared ones.
	expandMethods(cn);
    }

    protected void ParClassDecl.expandMethods(ClassNode cn) {
	java.util.List methods = cn.methods;
	java.util.List newMethods = new ArrayList();
	
	for ( Iterator mIt = methods.iterator(); mIt.hasNext(); ) {
	    MethodNode mn = (MethodNode) mIt.next();
	    if ( reflectiveMemberNode(mn) ) {
		// find the corresponding method in gd.
		// we do this because gd's corresponding method already has
		// the reflective iteration info parsed with the appropriate
		// information.
		StaticForMethodDecl md = genericDecl().reflectiveMethod(mn);
		
		if ( md != null ) {
		    ParStaticForMethodDecl subMd = 
			(ParStaticForMethodDecl) md.p(this);
		    IteratorDecl id = subMd.getIteratorDecl();

		    // get the mappings for each element in the iterator decl
		    // 's range.
		    for ( Iterator subMaps = id.reflectiveElmts().values().iterator();
			  subMaps.hasNext(); ) {
			Map substitutions = (Map) subMaps.next();
			// put into the map the parameterization from this
			GenericClassDecl gcd = (GenericClassDecl) genericDecl();
			for ( int i=0; i<gcd.getNumTypeParameter(); i++) {
			    substitutions.put(gcd.getTypeParameter(i),
					      getArgument(i).type());
			}

			MethodNode newNode = copyMethodNode(mn);

			// see if we need to change name.
			if ( subMd.isNameVariable(subMd.getID()))
			    newNode.name = (String) substitutions.get(subMd.getNameVariable(subMd.getID()));
			else 
			    newNode.name = mn.name;

			// TODO: modify exceptions.
			// TODO: copy signature?	

			// TODO:change instructions.
			InsnTransformVisitor insnVisitor = new InsnTransformVisitor(new org.objectweb.asm.commons.EmptyVisitor(), subMd, substitutions);
			newNode.accept(insnVisitor);

			newNode.instructions = insnVisitor.instructions;
			newNode.localVariables = insnVisitor.localVariables;
			newNode.tryCatchBlocks = insnVisitor.tryCatchBlocks;

			newMethods.add(newNode);
		    }
		} else {
		    // something is seriously wrong.
		    throw new Error("Cannot find the definition for " +
				    "reflectively declared method " +
				    mn.name);
		}
	    } else
		newMethods.add(mn);
	}
	cn.methods = newMethods;
    }

    public MethodNode TypeDecl.copyMethodNode(MethodNode mn) {
	MethodNode newNode = new MethodNode();
	newNode.access = mn.access;
	newNode.name = mn.name;
	newNode.desc = mn.desc;
	newNode.signature = mn.signature;
	newNode.exceptions = mn.exceptions;
	newNode.visibleAnnotations = mn.visibleAnnotations;
	newNode.invisibleAnnotations = mn.invisibleAnnotations;
	newNode.attrs = mn.attrs;
	newNode.annotationDefault = mn.annotationDefault;
	newNode.visibleParameterAnnotations = mn.visibleParameterAnnotations;
	newNode.invisibleParameterAnnotations = mn.invisibleParameterAnnotations;
	newNode.instructions = mn.instructions;
	newNode.tryCatchBlocks = mn.tryCatchBlocks;
	newNode.localVariables = mn.localVariables;
	newNode.maxStack = mn.maxStack;
	newNode.maxLocals = mn.maxLocals;
	return newNode;
    }

    // A map from elements in the reflective range to the mappings 
    // resulting from the pattern variables to the concrete values in
    // the element.
    syn Map IteratorDecl.reflectiveElmts() {
	// in order to call this, base type must be fully grounded.
	if ( !getPattern().getBaseSet().getTypeAccess().type().grounded())
	    // this should never happen.
	    throw new Error("Cannot return the reflective elements of a " +
			    "reflective iterator when the base type is " +
			    "not grounded");

	Map refElmtsMap = new HashMap();

	if ( getPattern().getBaseSet().iterateMethods()) {
	    Map methods = getPattern().getBaseSet().type().allMethodsMap();
	    MethodDecl patternMd = getPattern().patternMethodDecl();

	    // find all methods that fall into the range of this
	    // iterator decl.
	    for ( Iterator mIt = methods.values().iterator(); 
		  mIt.hasNext(); ) {
		MethodDecl md = (MethodDecl) mIt.next();
		HashMap map = new HashMap();

		if ( md.canUnifySignature(patternMd, map,
					  patternTypeVariables(),
					  patternNameVariables()))
		    refElmtsMap.put(md, map);
	    }
	} else {
	    // iterate over fields.
	}

	return refElmtsMap;
    }

    syn lazy boolean BaseSet.iterateMethods () = getRefElmt().getElmtName().equals("methods");
    syn lazy boolean BaseSet.iterateFields () = getRefElmt().getElmtName().equals("fields");

    public StaticForMethodDecl TypeDecl.reflectiveMethod(MethodNode mn) {
	Collection rmethods = reflectiveMethods();
	for ( Iterator rmIt = rmethods.iterator(); rmIt.hasNext(); ) {
	    StaticForMethodDecl md = (StaticForMethodDecl) rmIt.next();
	    if ( md.getIteratorDecl().signature().equals(iteratorDeclAttribute(mn)))
		return md;
	}
	return null;
    }
    
    public String TypeDecl.iteratorDeclAttribute(MemberNode mn) {
	if ( mn.attrs != null ) {
	    for ( Iterator attrIt = mn.attrs.iterator(); attrIt.hasNext(); ) {
		org.objectweb.asm.Attribute a = (org.objectweb.asm.Attribute)attrIt.next();
		if ( a.type.equals("IteratorDecl"))
		    return ((ASMIteratorDeclAttribute) a).signature();
	    }
	}
	return "";
    }

    protected boolean TypeDecl.reflectiveMemberNode(MemberNode mn) {
	return !iteratorDeclAttribute(mn).equals("");
    }

    syn lazy String TypeDecl.expandedConstantPoolName () = constantPoolName();
    eq ParTypeDecl.expandedConstantPoolName () {
    	String cpName = genericDecl().constantPoolName();
	int lastSlash = 	cpName.lastIndexOf('/');
	
	StringBuffer buf = new StringBuffer(cpName.substring(0,lastSlash+1) + 
					    expandedName());
	return buf.toString();
    }
    eq RawClassDecl.expandedConstantPoolName() = genericDecl().expandedConstantPoolName();
    eq RawInterfaceDecl.expandedConstantPoolName() = genericDecl().expandedConstantPoolName();
    eq TypeVariable.expandedConstantPoolName() = getID();
	
    syn lazy String TypeDecl.expandedName() = name();
    eq ParTypeDecl.expandedName() {
	StringBuffer buf = new StringBuffer("$$");
	buf.append(name());
	// $$L for <
	buf.append("$$L");
	for ( int i=0; i<getNumArgument(); i++ ) {
	    TypeDecl argType = getArgument(i).type();
	    buf.append(TypeDecl.convertToExpandedName(argType.expandedConstantPoolName()));
	}	
	// $$R for >
	buf.append("$$R");
	return buf.toString();
    }
    eq RawClassDecl.expandedName() {
	throw new Error("Classes with reflective declarations cannot be " +
			"raw types.");
    }
    eq RawInterfaceDecl.expandedName() {
	throw new Error("Interfaces with reflective declarations cannot be " +
			"raw types.");
    }
    // $$S for /
    protected static String TypeDecl.convertToExpandedName ( String n ) {
	return n.replace("/", "$$S");
    }

    // TODO: not finished.
    syn lazy TypeDecl ParStaticForMethodDecl.parseConstantPoolName(String n) {
	// Package and Type Name
	StringBuffer packageName = new StringBuffer();
	
	int i, last = 0;
	while( (i = n.indexOf("/")) > 0 ) {
	    if ( last > 0 )
		packageName.append(".");
	    packageName.append(n.substring(last, i));
	}

	// what's left is the type name.
	String typeName = n.substring(last);

	TypeDecl t = null;

	// if it begins with $$, then it is an expanded constant pool name.
	if ( typeName.startsWith("$$")) {
	    
	} else {
	    /*
	    String[] names = typeName.split("\\$");
	    for(int i = 1; i < names.length; i++)
		t = t.lookupType(names[i]);
	    */
	    // TODO: i don't know if this works with innerclasess.
	    TypeAccess ta = new TypeAccess(packageName.toString(), typeName);
	    this.addAccess(ta);
	    t = ta.type();
	    /*
	    if ( packageName.length() == 0) 
		t = (TypeDecl) lookupType(typeName).iterator().next();
	    else
		t = lookupType(packageName.toString(), typeName);
	    */
	}

	return t;
    }

    public java.util.Set ASTNode.collectExpansionTypes() {
	java.util.Set types = new java.util.HashSet();
	for ( int i=0; i<getNumChild(); i++) 
	    types.addAll(getChild(i).collectExpansionTypes());
	return types;
    }

    public java.util.Set CompilationUnit.collectExpansionTypes() {
	java.util.Set types = new java.util.HashSet();
	for ( int i=0; i<getNumTypeDecl(); i++) {
	    types.addAll(getTypeDecl(i).collectExpansionTypes());
	}
	return types;
    }

    public java.util.Set ParTypeAccess.collectExpansionTypes() {
	java.util.Set types = new java.util.HashSet();

	boolean grounded = true;
	for ( int i=0; i<getNumTypeArgument(); i++) {
	    // regardless of whether all type arguments are grounded,
	    // we still need to check for the types they refer to which
	    // may need to be expanded.
	    types.addAll(getTypeArgument(i).collectExpansionTypes());
	    
	    // check whether type argument is grounded.
	    if (!getTypeArgument(i).type().grounded()) {
		grounded = false;
	    }
	}
	if ( grounded && genericDecl().needsExpansion()) {
	    // if all is grounded, and the generic type needs expansion.
	    // then add this type
	    types.add(type());
	}
	return types;
    }

    // determine whether a type is grounded.
    syn lazy boolean TypeDecl.grounded() = true;
    eq TypeVariable.grounded() = false;
    eq ParClassDecl.grounded() {
	for ( int i=0; i<getNumArgument(); i++) {
	    if ( !getArgument(i).type().grounded())
		return false;
	}
	return true;
    }
    eq ParInterfaceDecl.grounded() {
	for ( int i=0; i<getNumArgument(); i++) {
	    if ( !getArgument(i).type().grounded())
		return false;
	}
	return true;
    }

    // determine whether a type needs expansion.
    syn lazy boolean TypeDecl.needsExpansion() {
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if ( getBodyDecl(i).needsExpansion()) return true;
	}
	return false;
    }
    eq ClassDecl.needsExpansion() {
	if ( hasSuperclass() && superclass().needsExpansion())
	    return true;
	for ( Iterator ifIt = interfacesIterator(); ifIt.hasNext(); ) 
	    if (((TypeDecl) ifIt.next()).needsExpansion()) return true;

	return super.needsExpansion();
    }

    syn lazy boolean BodyDecl.needsExpansion() = false;
    eq StaticForMethodDecl.needsExpansion() = getIteratorDecl().needsExpansion();
    eq StaticForConstructorDecl.needsExpansion() = getIteratorDecl().needsExpansion();
    eq StaticForFieldDeclaration.needsExpansion() = getIteratorDecl().needsExpansion();

    syn lazy boolean IteratorDecl.needsExpansion() {
	if ( getPattern().needsExpansion()) return true;
	for ( int i=0; i<getNumNestedPattern(); i++) {
	    if ( getNestedPattern(i).needsExpansion()) return true;
	}	
	return false;
    }
    syn lazy boolean Pattern.needsExpansion() = getBaseSet().getTypeAccess().type().needsExpansion();
    
    eq TypeVariable.needsExpansion() = true;
    
}
