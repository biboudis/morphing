// Generated from parser/JavaParser.all
package parser;
 import AST.*;
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6
 * from the grammar specification "JavaParser.beaver".
 */
public class JavaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short BOOLEAN = 2;
		static public final short BYTE = 3;
		static public final short SHORT = 4;
		static public final short INT = 5;
		static public final short LONG = 6;
		static public final short CHAR = 7;
		static public final short FLOAT = 8;
		static public final short DOUBLE = 9;
		static public final short LPAREN = 10;
		static public final short VOID = 11;
		static public final short SUPER = 12;
		static public final short NEW = 13;
		static public final short THIS = 14;
		static public final short INTEGER_LITERAL = 15;
		static public final short LONG_LITERAL = 16;
		static public final short FLOATING_POINT_LITERAL = 17;
		static public final short DOUBLE_LITERAL = 18;
		static public final short BOOLEAN_LITERAL = 19;
		static public final short CHARACTER_LITERAL = 20;
		static public final short STRING_LITERAL = 21;
		static public final short NULL_LITERAL = 22;
		static public final short PLUSPLUS = 23;
		static public final short MINUSMINUS = 24;
		static public final short PLUS = 25;
		static public final short MINUS = 26;
		static public final short COMP = 27;
		static public final short NOT = 28;
		static public final short SEMICOLON = 29;
		static public final short LBRACE = 30;
		static public final short RPAREN = 31;
		static public final short SYNCHRONIZED = 32;
		static public final short AT = 33;
		static public final short COMMA = 34;
		static public final short LBRACK = 35;
		static public final short STATIC = 36;
		static public final short PUBLIC = 37;
		static public final short PROTECTED = 38;
		static public final short PRIVATE = 39;
		static public final short ABSTRACT = 40;
		static public final short FINAL = 41;
		static public final short NATIVE = 42;
		static public final short TRANSIENT = 43;
		static public final short VOLATILE = 44;
		static public final short STRICTFP = 45;
		static public final short CLASS = 46;
		static public final short DOT = 47;
		static public final short WHILE = 48;
		static public final short RBRACE = 49;
		static public final short DO = 50;
		static public final short FOR = 51;
		static public final short IF = 52;
		static public final short LT = 53;
		static public final short SWITCH = 54;
		static public final short BREAK = 55;
		static public final short CONTINUE = 56;
		static public final short ASSERT = 57;
		static public final short RETURN = 58;
		static public final short THROW = 59;
		static public final short TRY = 60;
		static public final short INTERFACE = 61;
		static public final short GT = 62;
		static public final short ENUM = 63;
		static public final short RSHIFT = 64;
		static public final short ELSE = 65;
		static public final short URSHIFT = 66;
		static public final short LSHIFT = 67;
		static public final short QUESTION = 68;
		static public final short THROWS = 69;
		static public final short COLON = 70;
		static public final short MULT = 71;
		static public final short EXTENDS = 72;
		static public final short RBRACK = 73;
		static public final short EQ = 74;
		static public final short DIV = 75;
		static public final short MOD = 76;
		static public final short LTEQ = 77;
		static public final short GTEQ = 78;
		static public final short INSTANCEOF = 79;
		static public final short AND = 80;
		static public final short IMPLEMENTS = 81;
		static public final short EQEQ = 82;
		static public final short NOTEQ = 83;
		static public final short XOR = 84;
		static public final short OR = 85;
		static public final short ANDAND = 86;
		static public final short IMPORT = 87;
		static public final short DEFAULT = 88;
		static public final short MULTEQ = 89;
		static public final short DIVEQ = 90;
		static public final short MODEQ = 91;
		static public final short PLUSEQ = 92;
		static public final short MINUSEQ = 93;
		static public final short LSHIFTEQ = 94;
		static public final short RSHIFTEQ = 95;
		static public final short URSHIFTEQ = 96;
		static public final short ANDEQ = 97;
		static public final short XOREQ = 98;
		static public final short OREQ = 99;
		static public final short ELLIPSIS = 100;
		static public final short CASE = 101;
		static public final short OROR = 102;
		static public final short CATCH = 103;
		static public final short PACKAGE = 104;
		static public final short FINALLY = 105;

		static public final String[] NAMES = {
			"EOF",
			"IDENTIFIER",
			"BOOLEAN",
			"BYTE",
			"SHORT",
			"INT",
			"LONG",
			"CHAR",
			"FLOAT",
			"DOUBLE",
			"LPAREN",
			"VOID",
			"SUPER",
			"NEW",
			"THIS",
			"INTEGER_LITERAL",
			"LONG_LITERAL",
			"FLOATING_POINT_LITERAL",
			"DOUBLE_LITERAL",
			"BOOLEAN_LITERAL",
			"CHARACTER_LITERAL",
			"STRING_LITERAL",
			"NULL_LITERAL",
			"PLUSPLUS",
			"MINUSMINUS",
			"PLUS",
			"MINUS",
			"COMP",
			"NOT",
			"SEMICOLON",
			"LBRACE",
			"RPAREN",
			"SYNCHRONIZED",
			"AT",
			"COMMA",
			"LBRACK",
			"STATIC",
			"PUBLIC",
			"PROTECTED",
			"PRIVATE",
			"ABSTRACT",
			"FINAL",
			"NATIVE",
			"TRANSIENT",
			"VOLATILE",
			"STRICTFP",
			"CLASS",
			"DOT",
			"WHILE",
			"RBRACE",
			"DO",
			"FOR",
			"IF",
			"LT",
			"SWITCH",
			"BREAK",
			"CONTINUE",
			"ASSERT",
			"RETURN",
			"THROW",
			"TRY",
			"INTERFACE",
			"GT",
			"ENUM",
			"RSHIFT",
			"ELSE",
			"URSHIFT",
			"LSHIFT",
			"QUESTION",
			"THROWS",
			"COLON",
			"MULT",
			"EXTENDS",
			"RBRACK",
			"EQ",
			"DIV",
			"MOD",
			"LTEQ",
			"GTEQ",
			"INSTANCEOF",
			"AND",
			"IMPLEMENTS",
			"EQEQ",
			"NOTEQ",
			"XOR",
			"OR",
			"ANDAND",
			"IMPORT",
			"DEFAULT",
			"MULTEQ",
			"DIVEQ",
			"MODEQ",
			"PLUSEQ",
			"MINUSEQ",
			"LSHIFTEQ",
			"RSHIFTEQ",
			"URSHIFTEQ",
			"ANDEQ",
			"XOREQ",
			"OREQ",
			"ELLIPSIS",
			"CASE",
			"OROR",
			"CATCH",
			"PACKAGE",
			"FINALLY"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGUS53KNVqdc#kqU7QJSmHszjwFtNcnOm8QANUm5xA82OaK55HKKx5r1KOeL1Mo0W0K" +
		"BAbR0heXYsSdtJoQxErjlT#$Exv3T#xrvcKoIztylBo$9xEmSqUXScYMUezdyDNgHDj8xuW" +
		"ds65rDruiCaIcoH3RTHBVGe$Iu4CAovlAB#INyKi7fU3f1Ijh6k$6Ul1VlpNlG7#JXbzDYV" +
		"uvrEo$aD$Fd#2ty1ZwBEbC7VZM$Xb$Bh#FNyvdyLZw7tyPlvtVmkNmUlvFVnUVp1VmcQay5" +
		"rZogHhFO$ZIRFKv3gIFDed#GBdBmMTUA0ch7UehNsHFiIRQGBM9FiQVPOlOCUvOjOKlv1Ei" +
		"wNblSJOl5Htnw0D#L2X#TplwaAJmlSOrP4tuLFujiHsD#9crZO#XsVZPleJHcFVaqa95XUy" +
		"MTgMZCcbCFre8To5hoOw3nV6XSapNaKwqJd7P5FQKnpOcbCRNaQwrbLZTQJ2$Hk$GUlK#Rw" +
		"0Fwa3vohCXNYhhGs1FKc4wDet5RfJ4$NN1xdRtEQaZRQ3zw7HeVgVku9hVT6bkTKzDOr6Cj" +
		"77JsEYwXyHhcfS$eG3gOrj4uFbvhl9u#LXWY$$W4iPTeo5SdhXMVmY$Zbr8DQBNMNYkyq6e" +
		"DB0s9IYj#ENzLNEtNYkRuVaz9guzfXsp7Sa7rxBMo7NLadrYtiKsiFVkGlQVyHsd5ZnPNAW" +
		"oHVrITMjdUfBHIledU4PmrjovJMl7lqLFVmeAgh$vK5WpqbSVEJsayxg0TB1T$zLWzBQyZT" +
		"PBxqHhhAjrVfVnitLVHVAzZSDHIwyIrWXR7qwjqBiRSLcWn3kUjw5ojYz9g5kDensWbVkJ7" +
		"fgALzl4J#A6i9vrhtSZsKnx8pzOQhQ5p54z4At5NCbfHTvf6Sz5NrqEBXt2kV7qkRwsrkfE" +
		"widq3iNDVIYsIZBS6yBNGOAxMP1oq6WVRmNAQpcL79QALrIKfhIwbXjG8Mhq3BTRWN4aUJa" +
		"$h#BYEhMSR0#EgCBLn1Rmx41zoTQzCXOoEElM24ybL3A6sq2fXp68whyKp44CutSwEfv6qp" +
		"UgFM30ESKtrXFAp5dxCR2BFJGbpTreZdH7IdNhuCVFM3bunXRebXvdNvXFuNk9oO9xFJXMV" +
		"mCvdq7ona4xNc9KdsG4xRoUP4kR#i79FZRC#lUB7x22s3kF5ujdaCBDHh8$beT62MtlpFjP" +
		"4scPlunvuvUH8EriPjYSbZ$yQCNS6ejDMjXspQ5TWLhOmc7s$ixv9OZw5kWFp3cLdteVz0p" +
		"lFiXv4NJrAxNfyTj3ELWwhaGfcsLQsKSJ$KaThDEQ9dgA1Wzct1L7wxoHzutJgoyzNc356v" +
		"lAjj4tKKbRW5phnqdhS5I#h#IvDpPzbQvglYFR1iIymZsOFmP$dYZgCMRt8LfZvtU6HHUJG" +
		"tVGoFK7tqREqX9RICbfEpz7pz08TJSTOVTW3R1XjvykfbLp8N#TzH2r#56$Fs$2sl1tlm3l" +
		"oJhmBxyfB#JXHZJ$6L$5rV16$Zv$6N#3lyG$vF$mJ$WN$cWsaqx1Al1YHu5Q$lUWuPI#wac" +
		"RGO$I8trvqA1r6fz1Hz0bz2YjzpZgpBl2Hr#WPkfckqhupZCw4h2GrOOEj5wrNh5UL9lm8f" +
		"OdkWQYQiDxyCL7VQ79Oc2R3wUpKDQ6Q0KsmAc1pRKyiJSJ3z8I8eGclIJliKxKcGxGcQlqN" +
		"NPEXqEHUHnD4pn1DafRx1dkBdKGNABdmuhWM5FFuOrQFPEJ6xZaxNqndP$0QYSYbuT3tOaS" +
		"kxIYVNFw#acEDrtQUgEIoBUoBw79vFd#CsXYF#Q2SSa$Yv$99Cbl95OsrlZNj#Z7qNGnz5p" +
		"XohSFBANSy$ixZJlzUfkJoDNnj37rRGUvyO#VBoodt8xa$lz4wNiijrNA$YIMN2Y7t7cFdp" +
		"UMK#ptVmRyLrsixpzHsdigtnT1tE$ovrDZvs7BA$GxQ$GnISZzr#bTiZg7lICZjwiWLKyid" +
		"LzmkSyLqQ1hmAsiWF3kwt6iWjxlft#j2vOP7lpXhJsV6t8JrHPk85UrCgsNaEjUPz#X6VZf" +
		"$I0mkUzxZLz3eAAqyB8Q8eMAO62v693tZrHINYJiSApdUI7VGxJ6Yt3lyCVQtiTAkLAraJx" +
		"AACKjVXHLDX2RiA6jQJ2lTPXNnUnEnKfGMIDXYTD1AYQErYiKwh6lVY8QMviJkKwirB9HGd" +
		"qQs8Fws9elzKq4hVCA7lTOyUE1D4MZlZ6FRsvc7FveQMkiOkaiSa0fQVWhTGmkmnefcsqYa" +
		"9sAN54IxC3MqT2zwT5nAdj217gIdn7k9eHMRBEwW5S#m1dnPYhOzoxB4qQdvBTPU#$1M2Tf" +
		"slDNO#ErKra0KfkYtqtsRnJ6feCL#UWLMyfT6HMlpNV3fbVmAgpVh91uHBz9gH2gDbXr5kq" +
		"Jp53rX1VjBd93IAEil1gbT6T1kv$k9LwnixAddOqU6Fynmiwchc28sOqtOck#B695bzJBxc" +
		"roWRPcgRSKySL9AdZ2C7y1RqNR1UIkxYMNnJ34JRKstszEtvAFlx6EiuNAxUDLgR0qHK#ad" +
		"dyzumYYWRPy8MhGrIKotHjXrSJmGI3VpyMAgE3qbjBMiUjR1rf68O4UZtVeqsJhIjvCMs$M" +
		"m5ju1Z8tvBY1VRDMnwWkRQbh51YtyNNHC3AsOpYTQLzAbsEakjcx1sNXcYJDJGklXfrWFMu" +
		"y1xIXQp0JyTAxrACiY7wlD6jDydsqzQTs5l5EGKygwMNSQj0zPrukkYQ1bFLW$De3cia7W$" +
		"TW8I5ZCzX7dfeHsaRNGUeaT0R#jYHXw23kQ7SvEH7kditFO97QNxnBQXzqjjrWl#owWqRwB" +
		"i1fpukrmtuMYMq9#EvmzuhkOBc3BQIJxYxrC#z1ejbfCJWKjUvNvcEGCViivl9PdyHpkvGM" +
		"yEjNaTNWzNfytu8ruOzwIDrMsvltCA1l0XudU2Qsc1l6XV3ZV7tG8sZmSesunnib5iT6MlV" +
		"E5PVNEbnyNsFdMvAVIHJI4Z#IZpFsmn6V8a#szD2RE9$Dp#6JVLxxFV1$xFg0TlY#n9xc7F" +
		"yZlvu$mn$cJ$2c#c3$BdpSsMCfVvFScSYU5lootybVu2ZQ9ly7VmXgmaAzdO$b0qEWa#kfG" +
		"kPKToZS0vplyNRw9Vym$GtjVYUVHuYLOTV$0VsATa9RyLzu2o0ysE7#3z4SJmjc2$w5h$ib" +
		"R2CRpsJcY1XjB2tb$FZWPdAoVQ6PVAxXe8sgB7gATw29woHnWt2xxoDwob#mfUzY7oCvY7x" +
		"6VE4YCCNFuA5dA5oPqPohnMMIiR2WE5OS3otXnbAmXZfTUMKtcYrF4QRAwz8XpP87C4nVQO" +
		"yNvuXfn1VQ#3fOPOXfVLh5OQB6uLjmYPWFBpKZDmVmmLzml7XGFYSV4u#99iKWyBHQB9R3w" +
		"Ch5Sl2nM62mhnMh#TWNRvJNnfbWhrW3BssA3s2ZU1veFnSV0#9tuIVmYVXQxn9$YBuk9V#n" +
		"pxNCiOMAgPPqa2YiMYvLdzxIg2xMUhYtcMNlnoLQ9LMWrjPfRJP1gPRMrsbkTh8xY6gklDT" +
		"WQYjdVmJ8IQ9jNC9Rzn2$M$jO1m69P1ubRh74MefPr1EWuwsJhLEiqwmph7EjSQv9rdiPvX" +
		"S5IOaqNBIiM2vyiFhLcuiYjMTRDiC2jG767YdGMLd7M8vXNdm1$obffhI3zCJC9Fg9z1Vkk" +
		"#M1MI$3ZmjAn2c7fMeMmTAj2M7gdWYM1cPhCFMeApDJg4tUcflFBR7Lmh5PfK42vFjGBnmf" +
		"1p0zY3sAcTZuLOuFUPTWWQgkyEMgUmeuierV7X9tlmyT6xClkZtU$YWwdyNGYdKpz#DxsQM" +
		"YX3sW4A6ArKaaUK5LQ7H6muO5HjI#dfmgfMrMUMfbZ89hN9jv#xoZjEnus1krFD#atmuuzG" +
		"rpm2$gAlWavJgApAFaU6eks1bQQhQQdv347GPShgXYcjS2qg8fXsW9CgweM9dOvJMBTgnYc" +
		"gS2qTnN3D1sOnbKnJEy3art5C7r0axYeOfW#0gRiAeJfRLrp4gzMTJ2nImockbK8qnI3gM4" +
		"LmlIvWqayK8KmVMamFLfbC1rYQauIJrKPJ4S4C2sjCfYE361wgJ8niOFHyWDEo#nvP$$CNc" +
		"0lkbjctxCVs2wd4hjFOwhKjOh83RQS1AQtAjLEwhSNGqpBWG$lB7w0$FkZFQr0Nc1QJq$Y#" +
		"bViC$OkMyjUPwlOA#mbjWoxcm#8B68BsAzi1$kEtSlkgGZqrWj#zEn#6iD6AlIYPW3kcq7a" +
		"KJ0vUuyAnrGXes62Kz4wgj8GdPSaecDLDL6zql1SMsajtr1PBRF#bTRoOPNMyfsLrlB3bTK" +
		"oBqhs6Ij$LVsC5V7FAUw7FmPodh6Y#CzOLPX63uYHbQcHK7Uereb3nDxX6ltdBFd4VqwZP$" +
		"vp6bNQYew$#P#prSPAQ$dJIclvoqfhsLTPBGlwVtdEdYQtqdgmzPvcoJrDRgLvJi$$bqR$h" +
		"rLVfLbot$#NHlyvInxydzFeY3tDD$OqkPNcEHFtD4lkQN8hpNCk#8zfT27DOcVJR7Pkaiyj" +
		"dONZja0hlz8V4Qf4$jub8Jk9LjfQdTLJOBGpwlS0WGzhGp$GR$Hxg61s70u$9l5#4RzazIJ" +
		"Z6BTU#jq6#Xv$uBqNAdspADRb#ua1vXv$yh#cxnlQD#ps08hkea$IjZFFu8cJ0xO3wZYsCz" +
		"zCX7$uqxkPrPuBe3WFLgl0v$hO$4ZhM2S6jN5$HEIzzF98ZlncEU5Vg8XF8vvFREAyTuTtD" +
		"#$ToKLFd67woV3G4e5UF9MsYK#j2TPeqwF4nmTxrCfNFOe#RquDh9xY4ls6gpCY#nm7Kq8t" +
		"sWHML4#s5bDJQXOXjwPJGd$y9Qgxtk#aFaNwkCsFta5czNF9LIKynXkxy5DPWRy4ZeSwMk1" +
		"Jb#hHNbIV6eVPvz10jmPBEBrV48Rtxp2F9weLgZrGE5T$zvTarKp9ikoav7aZ7D3z2RLJAi" +
		"y95uLuu2WZjL#2BTKXzMpmCI5sYlmzPcBF$HBrDJOfYQSoRrRUSSRcbBk55M5UaCppyjeBL" +
		"BnCp0j4aqWRLAeNxErlDaalEA5YlQ2Cpu3ozI6xfPprLwQk8TSMvb7czzsn1QjQH0jaZKsW" +
		"1qlqIhYpjOy#Qn7rxHtA2#SORsmGMjt2wjKQKzdIgNOywUNoylButxxba4pszdJj96kNJsh" +
		"ipuBTIn$dkQmOUmglrYV6ntakA#opgpnZWCqkL#tNTai$t4DhYvAKFNPBoZ8xfLpps9Hhdh" +
		"KxzawwTkgrAtlzOlTmYlz$LazsztZI$$NP#BzUByNvaFRVRJHCrqlNguBrs8$iP$OR#tst6" +
		"V5lL7MBfkkbwwNhxO7rKjtJt$2lIupsvicgQTDqlNIzgbmlrH7uvhykSSrkOzDqlNIzTBrq" +
		"lNIztMCdl#VLI#XEi$X67VrtccFyZmzrH$bgSsTvHe9tcYjKkjYIfFHANANG0IdMYtpFHsB" +
		"r8d#LcLYzo6UP4rk5pKYntjKfrejyOqHYzTvEiTw65EjjJh5UvEzr4ttsE#A9qUZFnefR8$" +
		"n$cvZbN8lp39nghwVulind3XmPNw7q3U1VYwt2F6TfdZc8VAur92Vm$#gsEtAjqtMPVD9Fw" +
		"eblGr26$1TYZJBBcg1GKZRbKfuV3U#BTiuKNxYCaEb7gRaBfT7q6fE84gcKhQnCKnCeXHfn" +
		"$xYVY7LGadblZlWiZgsCL6iA$UNevA0CUpuZ2WfTwdEvbS8#p1L7BVN4ujzEl1HVnegNx53" +
		"nQrG9bvXugLhj5EMfNxy47P7jzVRw619Kl$scMwdh#aN2QRg#bX2fHQWUmO#ztbozc5qQA3" +
		"c1Tcf#gC8G#KUN17#Hm8uDrCfZwbYBNOdZ5Q1fx38sJr#PR4gSpovaLx5hs7KCFSvciXlPp" +
		"UnMTfiBOwiGn7inU2cx8zAMPVt6WhLc6QP76vd6GiO4gv$44wtRc7uJak2nnh9ZMVuBtsba" +
		"5eTeuRAiC2E87KhHFvS4ao9Vj$gZgoLjML4KQbc#917BHlkaObaNlXQL#HPjsB0ys3gKqNf" +
		"Hg3#8fiduWr#N#B4zn1$AeqjfoDaDPUhIjk9qyJ$RBmPMKBzCIB9VEbU2Bi7HM3vTJanIbo" +
		"Ehi2vdKDnFX2x7LO8kWPcidBfCIbANKoj#x5jdYzy3kiJzM1SOVg5riNLHaYlLaw2BNZ45T" +
		"4lsFzvEZ8hf$2HRULZNkZJ9MXjYzj2E95jAScV03afgn#h$97jtO4#gbvpzatnd8hiWoV99" +
		"ZYEMv6yqsROaot#RPFcVaYp$IvBbToPP$e#aut7Ktrf6#KJwM$Yl3IbsX4rivnmMOPq8u#m" +
		"6O#m28#AHYh0H6fdVRfSXdS9$CUnWEJzIDdV$BYmgCk5VJzuOJxPuDowo#3h7lMhLZTUoNL" +
		"nPSkEt7FzgDD#19aj3f4VTYUjFbk4XTpzS7$$TXhjP3lesl9q8hQmbklHYK#iUwrxhFkj#S" +
		"lb8S4TVrhi1h6TqUVzEN0H1cPruPWZIdMMCoP$f5$Sx1jHEdFar1Zhcx4PxXBq18MG$Ps6l" +
		"xJi$j5cMxT#9wpEreqyizgZFAUpaGCqw4OX3vKJiwEEsUrfIfS#CwvzbHf6u$fdwc8dnY$P" +
		"4f2OQPODxs8GYUlGoHfRSv9SbRegGjSqlo$pIlKK8dXnLHjqJKsLYVqiH3O6uoMeMlEiMhO" +
		"pLGjn44L7QUi2Dm6eHYLA$CplCQbQxigrcpOuqd4QWRFH1kDNyUCHrKQpcbfM3ChV5$oOdU" +
		"YpKTu8fr4OAZmptjf1OQDNGDeeIEQsx5POolrNQPZsjIo$MaTCT2u55VcY5$R#jCZwMwY#$" +
		"7OpidVPXSNqbBEAf3yipTaX00vTtFE2s9iiEjIRBjm#FWZXYPb7M3BthhRI1DHFuVWxMVDv" +
		"OiuFRcWwEcFqU8Kz#gd1OooEHifAGEJ3odJY98YNIyu6rm7HS25ANr9rXwCAmXhyJHsxMx7" +
		"jIxyG9HHU9DRIjHBpL$$6tjJFuBY0WtndkhQ7e$6TgLgR0$LpMAtZcwg6TuICpNilcayKEq" +
		"6svUoZwo2JvIMIROPzjrhEwz0BMBcHakkmaFuvlfwWhza6KxumiLbA6jQEikbZJG2i1Fr7w" +
		"sEFBr8Uivnnzp5aKVUmZokXtRT5G3qmyKeHvO4ZFc5P2Uoio3fYUyITOey0wpCd37C2AtRx" +
		"EBmfPgVbZNHdV5TBVaNaO#IxPV4RmkqA3nVMs5zhcx69OKzTUv$88ALWfXdf8u4o$RuSLcj" +
		"RoNLAQXQmzGpqaoqWn$k9gEpEaxKpts8eP5IFQTfq5FrdEDvw1$D3LTl2JIHEnXpwLJgFJw" +
		"GmwaywYi#aSEfScqMGwZywd2#X2kWXhqKleKbh2whC6h25DrUyP8Qn5rNy7dKqtqtLOcyx1" +
		"cfm5SjRI49f3jz7jT0VDfNbq9zr5ysa1TkNtqBtObTzF3z23z10zZDNierZJFewz#fEq42r" +
		"yIzyPJAFe1EpRG$5zIA$GgrHAg$Jk$t0wWiRJaNGKTlKJiAy$5fY#HHllWduCnqSUMC#3lM" +
		"$Y6kVhRzix68s$H8kbr9wsKebkiPIMWlmoYbb1IXhtWvu3g8W6qTT8bK3ZGXg1jB$TNxJ67" +
		"M9g37dOmoYDENPP5kQlJFH#DaQ#rfDLPpMIrdY6I#C3w43QohfeZGkfKOLe$0iqzlVnC6Wy" +
		"01eFei7wtJN3QOpMU3Jj7QkFjKxl9gwLyTibHgjVeDK0M5f9X5Qi5Uk9kS#lLGSgJachKkZ" +
		"LoFJaABIn3ETBS9wlvIYvIgklMMaChTR2kiN9QALxIlNEL4ZwKcjr8dppP5XGzTK8RS50Nw" +
		"MeLJ$y3S3V8FmfUSkWezBoIwrLCUGfhMBuNa2BPBIQ0QintLTAY#4uLsTA5tNkjEFNgY#ib" +
		"efMIXCLPqhHyfTOiIWFtAer6e0pnIjUgnLekSHeLOHpvUibj4QVTw3rc862MdL8IQiYNSFl" +
		"sSEXrN3ee2odQ0bQhNYj9i8R2erM0t2k98#5fkfy7zgNzWjerIb53sG13nmCpGP0AvLoHtA" +
		"bLUAOXwBiAXtXsiDY1oEQT4Mxm#4B2hEoL8ah5doK4kOLm3bCuroXexk3UOr1kHwfv30pu5" +
		"s5tSDKO2l2tA3iNg9je30hJ#hWmboQ4kPYu2pLE1bQzsDsC3BqNdwIc6VG8lZ6GS3yDJL1w" +
		"pE0V1NiN1p5pgdwnd3unZ1WLQsDGklBj2tyc8kndaqMymfWxgVjt4HRtQcxnin#wrrsxfIY" +
		"dLNyBA8YbgLZyWXWBaLRZXpai9f9OoxKKNgg6lciCyuFqLOO4ILU7W$9gVbp8#rv9RG$C1O" +
		"2SoxMTsjmtad5hfYHHQqzdP5QGDMeEjMWcbIBQbCTFHz#Z$NT8jHL4QIG6iFYXvXtw3Md5j" +
		"IIMb5hQaDjgHr6wl7K4R8wKnVgYhcw6tMd7jIJUb5lwgFRIDnUK#WokfokWAnfD9skX8zSH" +
		"LVJDNIjjjfCO3u#QKr#PGFP83POQx94QwBQYge9omvgWjahN9EYScXI6D14hGfcmfOfQ0By" +
		"$O2YaLwDA4rKMsLhKXgcIR9obPGYbgFbbiIt84fKdDnYp0T5h5D2SiUwvFOhfrocvIpHSjU" +
		"M8NUHIswZyibbmhnlCjY$Qkn5byjSOow$dFgEeJ5iE1kXvKxKSbKCAbCkMYsldLMyNUBIDx" +
		"RSJXLdPwp4ZyDAt6rd5V6ZZwEQ5MXdfPsYO4mjZ1bJ3tRfMr9EkKhJeP0KrBTHJBygSSaT6" +
		"IOtyUZddp6dHi5Q0goHkSwyDn8pP6BptlvOlKIsuZn5y2AzH2#dPANb8LPQ17j4jz8wM6cY" +
		"iTAGbAsav9LWnencfGvnhFGHlP#WbI9RM8KPoMsbnD4kX#rAOBjaqRuF2wM8bkMotDJGiXQ" +
		"i1T2EJ1fj#zJH8kUZ56tx7J2DXCT5Gnjf5OwMou$sey1JDycYVL#lXPOdXXPZPQr1kweSQ7" +
		"$2g4pLRmiHBLY2QCV0QyhjjphQfeQs7poX1EMZ##rnk9OBRTITlbpy5K6EWxP3ET1sm5zgQ" +
		"5VelqP0g#xChGAjqFTDr9$QaQa$jITPe$SYdN3cZs3biMsgdl0Xi31znvZ1SeLw5rgessFm" +
		"QBNJ#nRsLr7kHr1nmBO$9ensg9ffMQPkTQts0kLFgVhjSdXzBj0MQOp5I2lyQYsi$40T5V9" +
		"r#3i4gUK6hVBtHD4gbEy3qmYqypxEni0EgQ5jX1Ws7BFbL5XBMLFXQmIyYpGfQpAiRzMUT1" +
		"6kvoA66R#5jH93MwJZUGbzfTjMHzMBgQ4ThbUUYu2sKDzf#WWjBzAurTymvEmFKkEY2EiCT" +
		"IVAGJiMwSJGZbMjOCyq5dKxWDHwPVyKqHwaHxgAO0uF7WjTwM7GePEsTQv1gwuaQ5jMXqQX" +
		"zYZjN#eUBqiv9lXtleLcvxiaiFDLtvtCf1leni0zZoI#tzA#xepTOatENpzzfdeibmPgE#J" +
		"glcqKi45kmlu5tLaFMD2nhDfnvD8te6r9u5IUNc96RIFpfn1rG8iTJ7#LWfVgICbWTmVd2c" +
		"YI6CuIfwO#DZB#Yhc0zMR9h3rBz3sZOS3P24TbloADMFdym92$N6DR1#Smf1B3cJYM8Ysba" +
		"SQYqaL6SYEJ2Xw7GU$b80TBCJo#eh6eiSJqtTpbUeOjH7JDrPPnhEEaS$KAoCbpiEGc71cI" +
		"YQcvMiPK8tMT7WCVwdspyjLQWLZW#DbF1aiXxQXmB9tmbwk$JLYdRQ8Yn7OjVMGWLSYOwPy" +
		"FKSR1yc72CIYPFd9qLz7x9zrRotNKKjG9kYkipDZCmUbWKQbAmA9rd1gmW8Da18uJjVmEXZ" +
		"EfFmuMdQfWBD9yQAfCy9F6iYTZyS$KQ5dFrE1cfjRIKfsf$VF$rDYj1dIxXMx5iK8GOwQUI" +
		"TjCknNJubSfsK39HwlnUvNr3JiVclJzAdLFkW4rPDqHROeWiuco0IYPrKgbUi2$sQfkEKNj" +
		"utkgQHMUMfbZ83MlzRSFJusqSAbEbshaJhfVw952uuppH83x#1GzZPPJwQ5ow5AMhLBq6AL" +
		"B6bCQKnfJ6bCQKmAOK3EDAOtfFul9r4nZsiqmcLfJqvXauAEULi0UqXFZQGM5QGQkDsA5h8" +
		"WrParOCIjXJLaprCG#bFgprgmDQylQiVOibQVr8j3JINxqm5HAgzox7FyEnFb4OdBs7hXIm" +
		"PWgU3HKAKHiIDN1asvv3sevoNjMWRgDg515BHdtGnr1#Xahy5IViTfTD4fRCgtHlwzHsbPL" +
		"mLRfbgk2v#nfSjCzc9QRcjoqvwGjcRPaMgFTnJVsDBbfpqdBJKtkVyzpAakZ59zRmd56e9N" +
		"hwFe8JLAsapxgxm5eQRJl0LmoNgStw4rwAqpoEw3tKdkIKJrV5AgNUSh8FEMbqtFeDitLkm" +
		"sSvukIxvjbCP$zMasl9Vq4NMcuxVHJKJ5jv$zc8lp3hDtQQXNwN5#aTTpQf6grX9ueJFqNA" +
		"eLbjhR3wIrztS#ZVXT78zGxFrWUZV2FRneJj06hgtjqHk0T7$fDPP5z3Z8bzFb2rIveCJr3" +
		"puRBrV5neP4UjGJoD#ZZ33zwWsnpKAugeP0PNniHB87ZpuuMEEwat#aFsaL$Xjddvu3#WHA" +
		"cbyFVwBOqFFunRwJs1eKfIHk3aJAUdRIyOP4UwFB543k5zs52FhCXr0DDUviJR4bPKZyRxB" +
		"9aYi$zEZslfHV7rRbJ1OopYcuXYNXfV7AgUxwCErfkYsUDol22GBl$LoyeG#VoUq5vwvTJG" +
		"$tEf$za2yZDIw07pKfOhV2YhrAelTFJfdnfM7tzf4TLavwuzShfVobBHksYTEtaQfTFQXml" +
		"7BbxwLFMUA6HCJNLuoKiBuMdV4B6G7e4xI6rzUzDqpMhQE#aQrTaxVJggT9ch$zwlPJdmzr" +
		"6mtIzTBrqlVI8JzTBrqlN#o$M#$SZMZg6fkkbwwN7V7hCf#kbwwNhfUkbwwNhLNgzHEyqw#" +
		"F$xJvtvKYlv5LAkbwwthzUJ$jxr6TZe$Z$3F$eY$qCdERgcT8oHv##kj0PVVvdu5oZBn9bg" +
		"BuXJuo2TkWoywJpVEbcDyhm$$AhvB8yZT8bL#6MajMblrmsMEb7gNb8QVLXrMBPoebKpBnZ" +
		"Hg5apIEUcTrihZhlpUaM9rBvdq4j3UZqLz1MiNlCZzB$rcUNPhckDE8bBJKeciTyIgH4lyy" +
		"wKiyEGHJ05$rvvE2pxIfIHdy$q0n$H7R$8e4wk7pYk70jGlLmvOuo734va5T4IpKlYV7VTJ" +
		"i4Vv4Gd17KV$kMwXS9wfdy0I3r7o#7w2l3JGdrdoMTP#BtnvdwBtK7qS4qreNcjn1iVzC$E" +
		"9wGxFo2lgd7zlBhOdY8jLdB96B23ERqsDHOOzcnRF2fvj0dMaCjQtX9jBxmzw59Eqz#htRb" +
		"QClIQw6MfRSJiMnKQIbOrbKxYV#k6AYJp5kqouMjZDR3VqNnTZB#uDUbxDXUyRgu$U7VrEM" +
		"$r2zfNTAw$7jZlmmqSNu9bC1AzJLfVYjaMab65zVxyS8m$PNIE#rgLuHitLAlfEsGRFaa$2" +
		"jWbIJl3knHzIgxlzBb$x$baxt34#Ezfn6H9ihEEN2j0dVEcaVkd6Fi0YDGRWZVF#ZSXAJBg" +
		"ByVHuIDr7okgqvKPAoskLeKLtRygt5rBkFgxYWtYkz86VpzgJwBwQsnxsU4zYsjrFTBmkzQ" +
		"HFRn1xhqnwRMPxI5FgSlOlX86Uy685iVpKwSPRXGcPru2DAbySTa#3i6r4wSDWQrL3jn6V4" +
		"613OWf0rrLoZi5pBqctydhi#meqyizkZIhl$Am#h9k9z4T$J#TfCi7SS$ouuYSVqpvJ4Jps" +
		"$Bb9f4b4r4LhmoWJ52WJjogoD#3pp3BylyZdsJ6myrqcNKFJ4LzUF4soXHUZNvmkxzXO$IJ" +
		"MfF7MuH6XU2O5CaIlNEx72haQzigpbbmYotsc#ZSAi5BH9fDRSiVMToK$mvALui3BFHQZSM" +
		"anUwKr4zD2wgVYiJ#LQ9PlXZeT4l40iL5lXAVvd4XspLNtux65zPYbRY#KgKjweWSZehWqG" +
		"q27h7EBSrTUHqMHCHByoIaTRKgIZMXEUlB0k7lXB3caQR6FqUHHvf77OaKbZJlNwAY1#98i" +
		"Mrg7DW#Eydm#UhY54RFbzf6vixqA7lQ8d46jfoWj#1klK6kc3Sx8ip5tAT5uBEVnOwAxlFN" +
		"BwqDDOg9LhB9c#XqTlTGr57PkIeZY8XbY#vtrWKTsI5HyM0dUOv8yl$3KhCaHLjnUvVYxX7" +
		"LaBwnFIu9FI9Pj4a8aMeFuPwNvJly6BDjL5dRUTj6qjZ#RevytjWMTyLBesP5#7vKT$sCiF" +
		"PnOJapOrYkxbXywR$MyTv#knlKtEUIyhV8TzrXSv52uqK$$j1WgDffRjjTHPeOLxCg1ZHTl" +
		"3CPT65vXjFlyoLCke7CibQTHcfpx2PE3Ga6juOT0BHYADLVZGYQlEomsaOKVERm7U17dNoM" +
		"cqdQjqoTbqXObsBNfuzwF1COCgy9qQPlnq##7qYlZ$ECQln7mt6yu3dnCWwBNu1bY#8MluM" +
		"VWs6sKRK8HDjl0DUZ7AjmVk1Vmn#66ps6lXa57qHV1PH3UZSuIt8vU1RmTiHTHJW3BmeL6x" +
		"7teQFS#MTO$WDHfzvhcl6hXrV2#PbTC7X950pf2#5VlU1FmHobR7geCwNnWR0qb4QE$Odyk" +
		"OYCT4vpye73KKRhuBV0jeOQQiij9sDzZerGFft9ozxECwxWtU8B9$To#XnADApWlbyDb7EE" +
		"2UTSwtXZnk#6lH5i6od0t60NdmkqcU4op1wVGbTye0T$PZR7ZGzU2tte6XrehUJYxxZ8vqq" +
		"cgCswBVSNumErqF#jUZZxy4nNbXly2qeVoyu$8pTGzIvNkAoEdTrsICRv$1NyJhwQr#aJqL" +
		"x7u5VXMk3GNyOJCr1JuCkXprd1kldpOFDYi3lTCwjqIR$cr2P37RCFWN#yPPpBXQZ37my7$" +
		"9puCSMnaA#ykiTuBr0naVpuVCvQqsTcc6s$njjsgZJnCY6F#OsDVK687sHaNrYMBqhqER1o" +
		"DzWoWu4mVzo7aDUXEz5sYyVTib1lB7kXmpqK#Puy0z06s4l#6IDdr1c8kWOz6DZy1EDJLgP" +
		"#iU1Jd3IRJ0MyliR$A#wP42N$9D1i9bbOai#ucD6TTGv7EcpGBDTEa5MtcLEklDz3kyx16N" +
		"HZ$at6raF8dsga#RmzO7lc7QdENpWJwOSng4uYcXGddEUYRuVrCAKVHRNbk5yiBa6kOEECc" +
		"rYZ7gmgyXU1$iWBkHS32mcJdVURFWkXtUfXVAmNvUEuC3LPM$ekG4SUcV01xjC0qTSwx80r" +
		"xy6VnvoQu33pg8kRBsVQUStehqGwxg2ci4Fko96Pzm6ZZxEFmtyBl3JmPU3dm6E#9n$DlYl" +
		"u9E8IhtWTuBc6$qmblBXg$cF00zabIBkviy0npoJZtPBeM$#ooXuSLb#4aweXp5SYbYPZ$7" +
		"Sjm0PE#5lH#Fy1kJV0Gvzyvz46ZREHnpCduCqV2e3CJu3uwFqH#Xu8L6t5k3GXsz16lK5VA" +
		"GRR2tW4xc7EB8OTEq6l9c8qzqmrZBL#Nfmn8nkY2DY5L5tZ3s1k9FvAD9DaUu3FW3yP#WE6" +
		"tS$mcch#$c6tnofK$U5Xgy9oz$cy1wMIt$WiAupwR#8scBCvN$Zd7ioaCPORgl6nhScBmU4" +
		"yTLsAl9#26q$znjSmxpXiN1TzHamv$yQMiQJXMihaB$3dCD$F9Xtsi9k#MOEwT4OQTYbHny" +
		"NpgrX$ROksRuEg$z7P5xk0y22iLmTFk3nuwtjy8pla2uoTT5NhOwFhD$gIepthgPUfiFpaD" +
		"VgmJ3Py1bF3woHC4uoCKTv6hhiWtaa0#FKqyUS5nW#m5K6zid47ESnSvFd9CElD1ppg#TgL" +
		"td4B0$yt7EASsvXB7bETUaD$yvz3dcdEUVPVP4#tNNT5qpdNOHh1vfspmotGR1Sra71j0TZ" +
		"AEl0M6NZ4UfY$cjWuehdElZ48U2OcneiDNbZaVxDf16BUvmBZl7OSBp9kn7R9CmB7epnjjW" +
		"pUQPWd2EEU12B6gvsoJ5nseFnsGDrF1ZddZkClR2MjT1d6KsDVH2Ryh36yIn2MSnF7fnxJA" +
		"po88uqEW8SySE3ED43SxZd9T0hplLCn0YFQqx9GXpqh0oUjyDQsxFAXUj3jF4L#6lc7Eqnw" +
		"90rn5NcJSC$8ngAzQa7ySEpphG$0kar8Cn$7gn1XyAFSrN$OstgLMFr#s0xFTNXBvDME7P4" +
		"zWUx6hR0sil26iFw7UNWnttDcgZdGKHzjhZQEnDjc7M2vrlG3v7jPLmTUbvuWR4JrjI3Jmd" +
		"czni7lDLm$HbJpiXi1z3UshYEUSkBjMZHOKv#qQqExu#5cnTnisYZSzxOQ$2WFtl2dxpra7" +
		"UUavUDsEJ5MZOFSwR0d3NqJwGHXwtwA8$OwC7QneErdSS7Gbpqm9#yM4CtnXeCKnPvOOkUg" +
		"Ej5t6u2#taH1vl0Nxs8cLwidtgk18UDcY3#UJ47U357DBiL7EEr7VpOYpL4VymNNgovYZ77" +
		"UQ5RCN1u4HFwRmA7NnKZhden9nH$2evnskuSSCn$0v3sJY0gmLh7Em0SyTcBDTG0p2rUnEy" +
		"I#A0NQwGIwE356iGx27YsW9#8yO7htc6E3Nf3Jo$M9zd6zqKNXtk76tuD27EuTscmRxmBYO" +
		"PWxP1bzYd3ceVsgHS#dxN5f9y1OIuTKW8Pi4ycTFFUQtm1VP89lRBg1#jcZNMrWpLEEunDh" +
		"#hhXvoyFBJH3l7BY$MAzn5JxdRWnhh52vtROTtZHHzwdt2kMPXVlQyW$mTmLUyfumzg3RKV" +
		"siESrnxZmeknxLriP3o1DCPK#pRWIq1VEFav2Zl6GFjHu6hFyPMH3nksHyprOZxqRW$YpyF" +
		"SwlqsU5u0BCtLtkfjSvxhy9xmiLwztJQCHsZJh17xm3Qy2TfH#7ysUMOzsTSAbX#Cs5Q0jK" +
		"w1ydUixRCHfxncJ#55h6o56EE5xnTWRix5si$hCxQhRlJePixDV59GAzXsU$XE0SPZU#o52" +
		"#2JGx2FoOQyFFXCGMkNBR3dAsZdiWNMcjb7W#y3cNDCNexhEjPwGx3#BUXiwYFM5nm0Vfkv" +
		"FXhNCPuB49VpODE2dav#9iPHbff$rWNRoivrjOlncMlibsTyFhiWrBu568$DNy1rrnnidOT" +
		"yiqV8mrgmO8AJvWe3naZ1wQOkveCyz4l1sQxsC9$alUIonH$8EozutWlpLzvNJZe7Q#Cyn9" +
		"k22zoOJ3jcti$lOSxDthtWbB1oYDK5DuDmceSrUy7KyBQYjBq0Te1l5DoDEcRjLu3rKTvt9" +
		"etrMSweq3fvM1SLc35Jy0wkesu1vfuXc2yAi0V9m$g#O7cOdETTQVHR7kQeWXVZOyll2aBy" +
		"oiTyKE2QImksW12Byuy7tMZopBmvuWM73yVSDt8C2Ek4UbX$3OUVZi0SCHAnPUHcbCTSct#" +
		"JgVjrTFb3ZBs7eT#78xRrNXOBgvJoUbVwI33qDRter6#EkDjyLpnTao6bdCCPvF3vySisNu" +
		"1oPWtkt1DpqZKwHfQjzh6vDZvwMzQVvdgMmrkOkQIbMP#sRkZm3aCTtgkTmsisDlK#S7ZTj" +
		"g7jrfri#Cl1lBsCZdlT68bZmBE6RmhD5mLg7sPaNUzmDZUqp5x7EZm3CQjfzs1#PcFOnwmv" +
		"CasShc7inbuFn#1gxz6mymzYbNMkPsC1aTqfnZKxCY$7jRwkX$rJpboZ#r$HswY7FRU5URf" +
		"cN#USzus79pvMiI2OhZaZz5gdVWxlPVg#feb9jPSxV63jnEKCx1LwNdDnCDthUCClTpXR4L" +
		"b$UDZ#TEIqnEJswHLCvrc6lu5nZxLP7kOtzeDQ5qQHvutTPlD5hZRH3tqU2vuFkILslP4Fk" +
		"UgPjSh8fnBHmoaxmepTuSQ7yn3dHlI9B5TpWwkEkOyaBWxcrSzmuNWWcCx0N6$DDFaFctht" +
		"ExnM0uUpa7iKQFzaXmyymDJ3MhhMyS7hzJk7bgzkzd9v7pcyXLbtD3qMiHhhjPQklUhGbWO" +
		"3rkRvMDyCTOsJeQxzH7wsuJaE7rJ3yDQ63t9u7SlmVHrUqpQwZJ1ybiDxcNkjlPOP$fx3UL" +
		"k7Tp7VLtJPul0sTpcyvVD69rElMOR3CuuqjZ3tyPh5Z3NEzUf6Z$hcNavpqqxUfdZrOhVNR" +
		"47q$1OV1TCjDmVJRLu8fallDjnLjfVPh$NsE9pF2LwhPUv3rcvk#9cchBatstjei6mTizwh" +
		"u$fEO93Pymqws$1h8d4FkiVmiFN78BCl7FHjQ7xsSIvyJqQsL#lFoBpQWyFpmgwRkITZJ9H" +
		"h4Vq47Pi4q$MDVpHl6rwkeaZTtuxCw$sXkVPnZ3f5mNJrpf7NgosCNg$wekZvR9Rvtc6QFm" +
		"$h9ZDcQ6DesVn7W#aSxB4pVWk$BuYs3dMryrJejSm6mNJ6Zw7NHYwJqludU4w7kA#ZhP3lK" +
		"f8bnAVLvQllt5zqqWsA7PxrYUlwOQxh$dj7JmJpcfgrJCEE3kzhOgedudjFK#vsX#UR#LQ$" +
		"LVmpyAkSS$wdkZTiogvsUEQzmVfUrvpQAEAxmVYwDZeYIfxh$cOcS8Xdm5twPUqRJFSrQxk" +
		"i$OsEPltfCVTgcwjxgQDCtZvXSfvrfRzC36#zWz3EqKwwzmIa9xYkhI#xFkq8FVTU5aotvC" +
		"5qFnDBlSRU1VaEBrnfhfllZmlCF5jWOcS$CwOBFdLujQR1Dei#DtaJGp7acdix$JOW7R7sZ" +
		"jGX#ynWkh6vBvrj$32dC7YjIHkJDocOryoi6PkOxyZwctrspXg3fSJactL6xeM6c#yEYnSv" +
		"V83vhYpFh0doffXyinV8Uz$X#Qxx42Nclcam$a1ET$YtwpwE9wGFyPdgyAomxpg6kUvTzGl" +
		"RatlMg$k3OUNDVZxBzez3ZB5R4HEnzXG71ik9nqFhrGbfs#Gz4vcNO#R0EZBycfDVTsJekR" +
		"SXR6hMDtLdnwZpIVJyUYsYv9qL1TFDwZwdEmywNugyJivrRkxjzxu4LEROYMo$$vr4Wqt$U" +
		"CntjWFC#dEmwpxZ005TRmgUPqyERQUwQwsJe#xP6f$gRTPdNhDMQRR1NS$9Qsw#BsbXv0yp" +
		"Qx#y8QZdMcFh#uEN1i#f3VO6No7l1E3f5bs$eMj3pzKzvUphWkV3XC4y2TVCCnQ4$J3lYha" +
		"nArZESiKeQqmmxLtWS1uI5vsyN7LlTQhh$3rrxpXuBlPs#4ZpVQBtWk2rlEeuloTuhk$Vkj" +
		"QBcUhUv6V1yxrSVKMzSVqvNFyycatyxSMwPh3U5anddnUlRB0SKxhyvDpFpZ7VfQfxp7dcE" +
		"rdM0zV$3AsJTwgw7sokmnT7cRbwcFbUCUzeNFyWj4v1KrTzz6VUSSYB64#XTQncfkwaiFpf" +
		"9Z$A$SDHbiD7N8jq7gWpnjuds2iUZxmTEEy9WazQnvGXUnMvFl8T#OPyNRvcNsaVZBF0DRb" +
		"C7n#NZyY7vKFoGVa0aNsDVRLzbRnVtYVlbVV8k#rfze7oChb2NgxB7Y8FbWV90#K1I8y9j7" +
		"Edd8VZN7cRd6DVP$AEb8VQS#qxR5ZOlWkq07GFw3wGalCmw4dGqw1dGSljDsr4LVjrq6lsQ" +
		"Xo1qrvflsgliTz2wXNG2ljbUtrGB$id#tlxMvtwnduLnzlj#VRRaFrPeCIFzdVsLdkTlTQ#" +
		"s$vDvsoqTsY#mVvLVY4$j#$rlQdEVM$Ol#ZyZv5M63Rht5M#bO6sNlAzx7l9zwBlXK3Ep$O" +
		"FSejzlxIbJ$uZ$vP$oJ$bBlc7$4qwCZwKMpH$pyPOiXy2FG5w2eIraRrC$Yf$aJ$Bd#IFyW" +
		"VvlVnEGXTxgVsSlGHyaRqOnyT1Zu4UbTjnh0cguVl7aUxx6$GZw3VV3lKSd9QKAxVABtMgb" +
		"ZvMjwlvVj2biHhqVU$xrVUBAPabjoBdEttj3z2tlfzzFvbh5cpubKxbs9csiFFiR3l3zvTl" +
		"bykdKDjUQ3yIi4L7K87zfVs5$Qa#XzVQMspqXFsrZRRipmCbkKqsq$M1qNvHzHZu9dryHnz" +
		"XOTzgtmhxUQFfTdqqElgswkCtlddssqfNXTG7J$B1Lhv7GR2p3nxcknTqDsW#w0xGRI3C4p" +
		"xCRxwRG3U0uAs#gq5NWgQ2BWjgw7l5bPxYyhhRx3dshVOjzitsR7kMVPDzets3FTE#teSHu" +
		"hl2zxplETzotpIaf$jcu7YLxneSh$LTZ#EDe9a#xATySq2tW6RxC3vy61U#1I2C4zzSqEq#" +
		"Z18VVCPtlm$Zn0UlyS4BV8$u5lgM#POY1G$nFUjxnWSVyM44#PxoBTBOFZ0Uzsu0ROT0gfF" +
		"lDT#hBfqs#gHlW$sHgV5#e5ndm#V9yR3k4V9mUHZuxV8EUPTSAL#Lho0Ql2nVaY$A5#JpyZ" +
		"cvt3vR$YvtscVPPzfdeDvHklRfe2DrQg8#dcoVP9zeds0VYpIYcNsSpZtQdc2VuY3GNhLKB" +
		"ZQf9#JN4hqgdvLFsGrrsKQW1iXP9By1#gzzNnWzj6VvFlLzOiu$rCVtVPZxVE$wtf5VWt#4" +
		"UllAVUJUShGS9KUYfHdseLhEQZb23fV3v50vH0wMW#H0EK3sb$raNuLATWaWwwwFtGBdZIZ" +
		"i8#jBpE2oK#2ybU4jPJ7iOwA6ROVLQg2F6TBIN4YkEPF#tj09ssV$OsC4sty4UWbZKLu5pT" +
		"ReyihJthB$jl$IrtxNnvsoe#mWswleXwZrCdBUzgrGHzbOZjMrYlInKBQG9R89KirbCzaKl" +
		"8xEpvHP1cCzK2qNvhr0jKswBgXc0DKuaplFESfzNRMsX5kiCZxIZs21d2qnmYHcKedHBQV9" +
		"wV8EVGKZKLujhvCOb$86UPCRcJJZN9ud9#CuIPxhZ$$od42Pizrpa3mhcBQxEh7CN3dJTQM" +
		"BAntm8RjKNgHBNY8lC7KmVgGUB$9aUO8yNXudZvN7o0dsTFiWUJHoZmhKHRIo4N7io#nBTV" +
		"axJFubRclOcATjz86z3sWqQBWzr4WAwdofl53pY#NvfbPx6#jSkyXkPyuRcznMmLfs2yERs" +
		"yrmR6gNw3RcoraIyLNUAgVAAqpxfyjJTKdjCV8KKyzSjSVO#o5tfhnHFceFiGVP$Um1EhyF" +
		"QB0zqEvhzxTxsLXVschKxWqQ0Hfb3xFtTsbziNsHVQ5zWNs#VPuzsPuIqAEjFhRMaa#I9yh" +
		"JT7wTK0lOBULZ4ZEoN2AVDh6cKBudtvLhvHhVUb#WJ#MRyYr$seULjcyjyW9nq$sH6q7hv0" +
		"QvNg8sdy7KVx2xi0oQQ#WqGwSREYCAdMdeEaCpz2FiZBu6NKzSqob8Ave8EfK46w296s8kh" +
		"WXAevoDUX#0Vu1h6IW$4DSK3G8D9a4VuvgYpv3UGXcq4ca$pTF4QGvuehIGCa4PXYmNLoJe" +
		"ExIt5bYwG7uNd2$Hn9aNvrvS#nbjk6bd5Dg0jZQWtdgaruEl0Ly3lW9y1RZwxQsYFz7UPfJ" +
		"TZ3o78i#$n$dtI2lQX3gRm5SZVpNuSk0g1QvIsAqhE8Z#mBNVmNTH5YZJK8QBAx9edIPXYB" +
		"C2oZ2KfOWMeznYb758q8zezqVm3pLnrWtoke5N0myZzPO0rXpblqBThr3U8Sww8xyxqhThu" +
		"lGkohuB$Wgudrx5#J9DWkx4UJIwAqbwBWejW7vtGyyNGFVXV3xaFG#w7xBLUtnYqGEmKG#o" +
		"GC8GPpsXLq$m6g3gI5T76x#WhL$0xu6S5q4FGiwzb0FADfJbueeowILSVmbv3cMvkA9CPg5" +
		"j4BqDUasJe8SqSNeO$67mHy0V0NyC$578VHpySVG3EEkC#fs1iIPqo4AP9t3j2PGv2stvwI" +
		"FG#SWx7p8ToWHbQ$e1rx3s0p5wIfEW2pHP0NwkGomRih8XurVaBm9V17vHW3BeF9Gx3sqxb" +
		"4qNuznFPwDjDqr2$SaWzJuFXxWXHfU0NmfIltM$J7CdFGKofg0jFxy2ULT0jf#cuNoQveAc" +
		"8prTSuVKs#Ilr3oKrF#cl4fpeV$FyDNWru1V0tuj#BNWCy5dWjy0VWFuZU0t0iCju8gceXz" +
		"oO9iaY6u57wBZ3TUaniwTe9LclAcOymnaF0ExrqB$reACNhZM2#dQ6C#ruJkrSHwDSX74Sy" +
		"5Rc3XwaujcmKzwwz#rCDP7as1reDCtkEQdRJZV1hcOvK6CzTKaQ3RQkndr1#3QWE1SeCUl6" +
		"dzFmhTU1hbrU1OwF8k#SaZGJoZ$a#QAB1TNbC7weMu$j5iNl2vqTKYuk2ABvOFdeKmUsjk1" +
		"QyE0THZE2s0NXx8LmG#pN9H3QgPz7xWsmqSt0vkVxyArNQZ3q3P3smvnygbf6kMt0zzsO5s" +
		"8TZ3VgDz#WHXJl$iIu9dWcIYt6EsfE3i3PHtAm3oQ2R9e5Tfx4sNUHBwYjt3#bkQ2$a7w7y" +
		"q5QmbzMcek67R486R6RGwzX$HxAFSE#3kulXTaxmNU7xm$ybz7lg8t3Ftc4Ald42s5dAKej" +
		"n5y8$ZVu5E0RmhQdm9xJO6CRv6t5TUseloNcWHz0lu9yZzrY0tN9DW8y17WzS7hGqO3y0RW" +
		"3S5RWR2JOUeDfFuv$tF8#WAqMizv5fs3l7EGFaUdtToVBrpd0M9jNTGkGDmGOsqqSKECDT8" +
		"aeb8XhXLg7gGYv1Lf7acDSQsnvcLJ4vHjedcGYf5NhBbW9KYNQ2vOKwIRQYvOCwIRQIwO1s" +
		"cFveArHxeznecY3aWhQWsRtF4$huSJRG==");
 // Generated from parser/JavaParser.all
class Events extends Parser.Events {
    public void scannerError(Scanner.Exception e) {
      errors.add(new Problem(null, e.getMessage(), e.line, e.column, Problem.Severity.ERROR, Problem.Kind.LEXICAL));
    }
    public void syntaxError(Symbol token) {
      int line = token.getLine(token.getStart());
      int column = token.getColumn(token.getStart());
      int endLine = token.getLine(token.getEnd());
      int endColumn = token.getColumn(token.getEnd());
      String value = token.value != null ? token.value.toString() : Terminals.NAMES[token.getId()];
      errors.add(new Problem(null, "unexpected token \"" + value + "\"", line, column, endLine, endColumn, Problem.Severity.ERROR, Problem.Kind.SYNTACTIC));
    }
    public void unexpectedTokenRemoved(Symbol token) {
    }
    public void missingTokenInserted(Symbol token) {
    }
    public void misspelledTokenReplaced(Symbol token) {
    }
    public void errorPhraseRemoved(Symbol error) {
    }
  }

        {
            report = new Events(); // Use error handler in parser
        }

   public CompilationUnit parse(java.io.InputStream is, String fileName) throws java.io.IOException, beaver.Parser.Exception {
     CompilationUnit cu;
     errors = new ArrayList();
     try {
       scanner.JavaScanner scanner = new scanner.JavaScanner(new scanner.Unicode(is));
       cu = (CompilationUnit)parse(scanner);
     } catch(Parser.Exception e) {
       // build empty compilation unit for failed error recovery
       cu = new CompilationUnit();
     }
     for(java.util.Iterator iter = errors.iterator(); iter.hasNext(); ) {
       Problem p = (Problem)iter.next();
       p.setFileName(fileName);
       cu.addParseError(p);
     }
     return cu;
   }
   protected java.util.Collection errors = new ArrayList();

	public JavaParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // goal = compilation_unit.cu
			{
					final Symbol _symbol_cu = _symbols[offset + 1];
					final CompilationUnit cu = (CompilationUnit) _symbol_cu.value;
					 return cu;
			}
			case 1: // literal = INTEGER_LITERAL.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new IntegerLiteral(((String)i.value));
			}
			case 2: // literal = LONG_LITERAL.l
			{
					final Symbol l = _symbols[offset + 1];
					 return new LongLiteral(((String)l.value));
			}
			case 3: // literal = FLOATING_POINT_LITERAL.f
			{
					final Symbol f = _symbols[offset + 1];
					 return new FloatingPointLiteral(((String)f.value));
			}
			case 4: // literal = DOUBLE_LITERAL.d
			{
					final Symbol d = _symbols[offset + 1];
					 return new DoubleLiteral(((String)d.value));
			}
			case 5: // literal = BOOLEAN_LITERAL.b
			{
					final Symbol b = _symbols[offset + 1];
					 return new BooleanLiteral(((String)b.value));
			}
			case 6: // literal = CHARACTER_LITERAL.c
			{
					final Symbol c = _symbols[offset + 1];
					 return new CharacterLiteral(((String)c.value));
			}
			case 7: // literal = STRING_LITERAL.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new StringLiteral(((String)s.value));
			}
			case 8: // literal = NULL_LITERAL.NULL_LITERAL
			{
					final Symbol NULL_LITERAL = _symbols[offset + 1];
					 return new NullLiteral("null");
			}
			case 9: // type = primitive_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 10: // type = reference_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 11: // primitive_type = numeric_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 12: // primitive_type = BOOLEAN.BOOLEAN
			{
					final Symbol BOOLEAN = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("boolean");
			}
			case 13: // numeric_type = integral_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 14: // numeric_type = floating_point_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 15: // integral_type = BYTE.BYTE
			{
					final Symbol BYTE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("byte");
			}
			case 16: // integral_type = SHORT.SHORT
			{
					final Symbol SHORT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("short");
			}
			case 17: // integral_type = INT.INT
			{
					final Symbol INT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("int");
			}
			case 18: // integral_type = LONG.LONG
			{
					final Symbol LONG = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("long");
			}
			case 19: // integral_type = CHAR.CHAR
			{
					final Symbol CHAR = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("char");
			}
			case 20: // floating_point_type = FLOAT.FLOAT
			{
					final Symbol FLOAT = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("float");
			}
			case 21: // floating_point_type = DOUBLE.DOUBLE
			{
					final Symbol DOUBLE = _symbols[offset + 1];
					 return new PrimitiveTypeAccess("double");
			}
			case 22: // reference_type = class_or_interface_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 23: // reference_type = array_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 24: // class_or_interface_type = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 25: // class_type = class_or_interface_type.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 26: // interface_type = class_or_interface_type.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 27: // array_type = primitive_type.t dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					 return new ArrayTypeAccess(t, d.getNumChild());
			}
			case 28: // array_type = name.n dims.d
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					 return new ArrayTypeAccess(n, d.getNumChild());
			}
			case 29: // name = simple_name.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Access s = (Access) _symbol_s.value;
					 return s;
			}
			case 30: // name = qualified_name.q
			{
					final Symbol _symbol_q = _symbols[offset + 1];
					final Access q = (Access) _symbol_q.value;
					 return q;
			}
			case 31: // simple_name = IDENTIFIER.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new ParseName(((String)i.value));
			}
			case 32: // qualified_name = name.n DOT.DOT simple_name.i
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return n.qualifiesAccess(i);
			}
			case 33: // compilation_unit = package_declaration.p import_declarations.i type_declarations.t
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit(p.getID(), i, t);
			}
			case 34: // compilation_unit = import_declarations.i type_declarations.t
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit("", i, t);
			}
			case 35: // compilation_unit = package_declaration.p type_declarations.t
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit(p.getID(), new List(), t);
			}
			case 36: // compilation_unit = type_declarations.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final List t = (List) _symbol_t.value;
					 return new CompilationUnit("", new List(), t);
			}
			case 37: // compilation_unit = package_declaration.p import_declarations.i
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					 return new CompilationUnit(p.getID(), i, new List());
			}
			case 38: // compilation_unit = import_declarations.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final List i = (List) _symbol_i.value;
					 return new CompilationUnit("", i, new List());
			}
			case 39: // compilation_unit = package_declaration.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final IdUse p = (IdUse) _symbol_p.value;
					 return new CompilationUnit(p.getID(), new List(), new List());
			}
			case 40: // compilation_unit = 
			{
					 return new CompilationUnit("", new List(), new List());
			}
			case 41: // import_declarations = import_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final ImportDecl i = (ImportDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 42: // import_declarations = import_declarations.l import_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final ImportDecl i = (ImportDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 43: // type_declarations = type_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TypeDecl t = (TypeDecl) _symbol_t.value;
					 return !(t instanceof EmptyType) ? new List().add(t) : new List() ;
			}
			case 44: // type_declarations = type_declarations.l type_declaration.t
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final TypeDecl t = (TypeDecl) _symbol_t.value;
					 return !(t instanceof EmptyType) ? l.add(t) : l;
			}
			case 45: // package_declaration = PACKAGE.PACKAGE name_decl.n SEMICOLON.SEMICOLON
			{
					final Symbol PACKAGE = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final IdUse n = (IdUse) _symbol_n.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return n;
			}
			case 46: // name_decl = simple_name_decl.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final IdUse s = (IdUse) _symbol_s.value;
					 return s;
			}
			case 47: // name_decl = qualified_name_decl.q
			{
					final Symbol _symbol_q = _symbols[offset + 1];
					final IdUse q = (IdUse) _symbol_q.value;
					 return q;
			}
			case 48: // simple_name_decl = IDENTIFIER.i
			{
					final Symbol i = _symbols[offset + 1];
					 return new IdUse(((String)i.value));
			}
			case 49: // qualified_name_decl = name_decl.n DOT.DOT IDENTIFIER.i
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final IdUse n = (IdUse) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol i = _symbols[offset + 3];
					 return new IdUse(n.getID() + "." + ((String)i.value));
			}
			case 50: // import_declaration = single_type_import_declaration.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ImportDecl s = (ImportDecl) _symbol_s.value;
					 return s;
			}
			case 51: // import_declaration = type_import_on_demand_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ImportDecl t = (ImportDecl) _symbol_t.value;
					 return t;
			}
			case 52: // single_type_import_declaration = IMPORT.IMPORT name.n SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new SingleTypeImportDecl(n);
			}
			case 53: // type_import_on_demand_declaration = IMPORT.IMPORT name.n DOT.DOT MULT.MULT SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol MULT = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new TypeImportOnDemandDecl(n);
			}
			case 54: // type_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return c;
			}
			case 55: // type_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return i;
			}
			case 56: // type_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyType(new Modifiers(), "EmptyType", new Opt(), new List());
			}
			case 57: // modifiers = modifier.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifier m = (Modifier) _symbol_m.value;
					 Modifiers ms = new Modifiers(); ms.addModifier(m); return ms;
			}
			case 58: // modifiers = modifiers.l modifier.m
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Modifiers l = (Modifiers) _symbol_l.value;
					final Symbol _symbol_m = _symbols[offset + 2];
					final Modifier m = (Modifier) _symbol_m.value;
					 l.addModifier(m); return l;
			}
			case 59: // modifier = PUBLIC.PUBLIC
			{
					final Symbol PUBLIC = _symbols[offset + 1];
					 return new Modifier("public");
			}
			case 60: // modifier = PROTECTED.PROTECTED
			{
					final Symbol PROTECTED = _symbols[offset + 1];
					 return new Modifier("protected");
			}
			case 61: // modifier = PRIVATE.PRIVATE
			{
					final Symbol PRIVATE = _symbols[offset + 1];
					 return new Modifier("private");
			}
			case 62: // modifier = STATIC.STATIC
			{
					final Symbol STATIC = _symbols[offset + 1];
					 return new Modifier("static");
			}
			case 63: // modifier = ABSTRACT.ABSTRACT
			{
					final Symbol ABSTRACT = _symbols[offset + 1];
					 return new Modifier("abstract");
			}
			case 64: // modifier = FINAL.FINAL
			{
					final Symbol FINAL = _symbols[offset + 1];
					 return new Modifier("final");
			}
			case 65: // modifier = NATIVE.NATIVE
			{
					final Symbol NATIVE = _symbols[offset + 1];
					 return new Modifier("native");
			}
			case 66: // modifier = SYNCHRONIZED.SYNCHRONIZED
			{
					final Symbol SYNCHRONIZED = _symbols[offset + 1];
					 return new Modifier("synchronized");
			}
			case 67: // modifier = TRANSIENT.TRANSIENT
			{
					final Symbol TRANSIENT = _symbols[offset + 1];
					 return new Modifier("transient");
			}
			case 68: // modifier = VOLATILE.VOLATILE
			{
					final Symbol VOLATILE = _symbols[offset + 1];
					 return new Modifier("volatile");
			}
			case 69: // modifier = STRICTFP.STRICTFP
			{
					final Symbol STRICTFP = _symbols[offset + 1];
					 return new Modifier("strictfp");
			}
			case 70: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.id super.s interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(m, ((String)id.value), s, i, b);
			}
			case 71: // class_declaration = CLASS.CLASS IDENTIFIER.id super.s interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(), ((String)id.value), s, i, b);
			}
			case 72: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.id interfaces.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(m, ((String)id.value), new Opt(), i, b);
			}
			case 73: // class_declaration = CLASS.CLASS IDENTIFIER.id interfaces.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(), ((String)id.value), new Opt(), i, b);
			}
			case 74: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.id super.s class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(m, ((String)id.value), s, new List(), b);
			}
			case 75: // class_declaration = CLASS.CLASS IDENTIFIER.id super.s class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(), ((String)id.value), s, new List(), b);
			}
			case 76: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.id class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(m, ((String)id.value), new Opt(), new List(), b);
			}
			case 77: // class_declaration = CLASS.CLASS IDENTIFIER.id class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new ClassDecl(new Modifiers(), ((String)id.value), new Opt(), new List(), b);
			}
			case 78: // super = EXTENDS.EXTENDS class_type.c
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final Access c = (Access) _symbol_c.value;
					 return new Opt(c);
			}
			case 79: // interfaces = IMPLEMENTS.IMPLEMENTS interface_type_list.i
			{
					final Symbol IMPLEMENTS = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					 return i;
			}
			case 80: // interface_type_list = interface_type.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Access i = (Access) _symbol_i.value;
					 return new List().add(i);
			}
			case 81: // interface_type_list = interface_type_list.l COMMA.COMMA interface_type.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return l.add(i);
			}
			case 82: // class_body = LBRACE.LBRACE class_body_declarations.c RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return c;
			}
			case 83: // class_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new List();
			}
			case 84: // class_body_declarations = class_body_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return new List().add(c);
			}
			case 85: // class_body_declarations = class_body_declarations.l class_body_declaration.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return l.add(c);
			}
			case 86: // class_body_declaration = class_member_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return c;
			}
			case 87: // class_body_declaration = instance_initializer.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InstanceInitializer i = (InstanceInitializer) _symbol_i.value;
					 return i;
			}
			case 88: // class_body_declaration = static_initializer.si
			{
					final Symbol _symbol_si = _symbols[offset + 1];
					final StaticInitializer si = (StaticInitializer) _symbol_si.value;
					 return si;
			}
			case 89: // class_body_declaration = constructor_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ConstructorDecl c = (ConstructorDecl) _symbol_c.value;
					 return c;
			}
			case 90: // class_member_declaration = field_declaration.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final BodyDecl f = (BodyDecl) _symbol_f.value;
					 return f;
			}
			case 91: // class_member_declaration = method_declaration.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					 return m;
			}
			case 92: // class_member_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new MemberClassDecl(c);
			}
			case 93: // class_member_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 94: // class_member_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new InstanceInitializer(new Block());
			}
			case 95: // field_declaration = modifiers.m type.t variable_declarators.v SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final List v = (List) _symbol_v.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					 return new FieldDecl(m, t, v);
			}
			case 96: // field_declaration = type.t variable_declarators.v SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new FieldDecl(new Modifiers(), t, v);
			}
			case 97: // variable_declarators = variable_declarator.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return new List().add(v);
			}
			case 98: // variable_declarators = variable_declarators.l COMMA.COMMA variable_declarator.v
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return l.add(v);
			}
			case 99: // variable_declarator = variable_declarator_id.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return v;
			}
			case 100: // variable_declarator = variable_declarator_id.v EQ.EQ variable_initializer.i
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Expr i = (Expr) _symbol_i.value;
					 v.setInit(i); return v;
			}
			case 101: // variable_declarator_id = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new VariableDecl(((String)id.value), new List(), new Opt());
			}
			case 102: // variable_declarator_id = variable_declarator_id.v LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol RBRACK = _symbols[offset + 3];
					 v.addEmptyBracket(new EmptyBracket()); return v;
			}
			case 103: // variable_initializer = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 104: // variable_initializer = array_initializer.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final ArrayInit a = (ArrayInit) _symbol_a.value;
					 return a;
			}
			case 105: // method_declaration = method_header.m method_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Opt b = (Opt) _symbol_b.value;
					 m.setBlockOpt(b); return m;
			}
			case 106: // method_header = modifiers.m type.t method_declarator.d throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final MethodDecl d = (MethodDecl) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 4];
					final List tl = (List) _symbol_tl.value;
					 d.setModifiers(m); d.setTypeAccess(t); d.setExceptionList(tl); return d;
			}
			case 107: // method_header = type.t method_declarator.d throws.tl
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final MethodDecl d = (MethodDecl) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 3];
					final List tl = (List) _symbol_tl.value;
					 d.setModifiers(new Modifiers()); d.setTypeAccess(t); d.setExceptionList(tl); return d;
			}
			case 108: // method_header = modifiers.m type.t method_declarator.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final MethodDecl d = (MethodDecl) _symbol_d.value;
					 d.setModifiers(m); d.setTypeAccess(t); d.setExceptionList(new List()); return d;
			}
			case 109: // method_header = type.t method_declarator.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final MethodDecl d = (MethodDecl) _symbol_d.value;
					 d.setModifiers(new Modifiers()); d.setTypeAccess(t); d.setExceptionList(new List()); return d;
			}
			case 110: // method_header = modifiers.m VOID.VOID method_declarator.d throws.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol VOID = _symbols[offset + 2];
					final Symbol _symbol_d = _symbols[offset + 3];
					final MethodDecl d = (MethodDecl) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 4];
					final List tl = (List) _symbol_tl.value;
					 d.setModifiers(m); d.setTypeAccess(new PrimitiveTypeAccess("void")); d.setExceptionList(tl); return d;
			}
			case 111: // method_header = VOID.VOID method_declarator.d throws.tl
			{
					final Symbol VOID = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final MethodDecl d = (MethodDecl) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 3];
					final List tl = (List) _symbol_tl.value;
					 d.setModifiers(new Modifiers()); d.setTypeAccess(new PrimitiveTypeAccess("void")); d.setExceptionList(tl); return d;
			}
			case 112: // method_header = modifiers.m VOID.VOID method_declarator.d
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol VOID = _symbols[offset + 2];
					final Symbol _symbol_d = _symbols[offset + 3];
					final MethodDecl d = (MethodDecl) _symbol_d.value;
					 d.setModifiers(m); d.setTypeAccess(new PrimitiveTypeAccess("void")); d.setExceptionList(new List()); return d;
			}
			case 113: // method_header = VOID.VOID method_declarator.d
			{
					final Symbol VOID = _symbols[offset + 1];
					final Symbol _symbol_d = _symbols[offset + 2];
					final MethodDecl d = (MethodDecl) _symbol_d.value;
					 d.setModifiers(new Modifiers()); d.setTypeAccess(new PrimitiveTypeAccess("void")); d.setExceptionList(new List()); return d;
			}
			case 114: // method_declarator = IDENTIFIER.id LPAREN.LPAREN formal_parameter_list.l RPAREN.RPAREN
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new MethodDecl(null, null, ((String)id.value), l, new List(), null, new Opt());
			}
			case 115: // method_declarator = IDENTIFIER.id LPAREN.LPAREN RPAREN.RPAREN
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol RPAREN = _symbols[offset + 3];
					 return new MethodDecl(null, null, ((String)id.value), new List(), new List(), null, new Opt());
			}
			case 116: // method_declarator = method_declarator.m LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol RBRACK = _symbols[offset + 3];
					 m.addEmptyBracket(new EmptyBracket()); return m;
			}
			case 117: // formal_parameter_list = formal_parameter.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ParameterDeclaration f = (ParameterDeclaration) _symbol_f.value;
					 return new List().add(f);
			}
			case 118: // formal_parameter_list = formal_parameter_list.l COMMA.COMMA formal_parameter.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_f = _symbols[offset + 3];
					final ParameterDeclaration f = (ParameterDeclaration) _symbol_f.value;
					 return l.add(f);
			}
			case 119: // formal_parameter = type.t variable_declarator_id.v
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 2];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return new ParameterDeclaration(new Modifiers(), t, v.getID(), v.getEmptyBracketList());
			}
			case 120: // formal_parameter = modifiers.m type.t variable_declarator_id.v
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return new ParameterDeclaration(m, t, v.getID(), v.getEmptyBracketList());
			}
			case 121: // throws = THROWS.THROWS class_type_list.l
			{
					final Symbol THROWS = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 122: // class_type_list = class_type.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Access c = (Access) _symbol_c.value;
					 return new List().add(c);
			}
			case 123: // class_type_list = class_type_list.l COMMA.COMMA class_type.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final Access c = (Access) _symbol_c.value;
					 return l.add(c);
			}
			case 124: // method_body = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return new Opt(b);
			}
			case 125: // method_body = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new Opt();
			}
			case 126: // static_initializer = STATIC.STATIC block.b
			{
					final Symbol STATIC = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new StaticInitializer(b);
			}
			case 127: // instance_initializer = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return new InstanceInitializer(b);
			}
			case 128: // constructor_declaration = modifiers.m IDENTIFIER.id LPAREN.LPAREN formal_parameter_list.pl RPAREN.RPAREN throws.tl constructor_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_pl = _symbols[offset + 4];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					final Symbol _symbol_b = _symbols[offset + 7];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setModifiers(m); b.setID(((String)id.value)); b.setParameterList(pl); b.setExceptionList(tl); return b;
			}
			case 129: // constructor_declaration = IDENTIFIER.id LPAREN.LPAREN formal_parameter_list.pl RPAREN.RPAREN throws.tl constructor_body.b
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setID(((String)id.value)); b.setParameterList(pl); b.setExceptionList(tl); return b;
			}
			case 130: // constructor_declaration = modifiers.m IDENTIFIER.id LPAREN.LPAREN RPAREN.RPAREN throws.tl constructor_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setModifiers(m); b.setID(((String)id.value)); b.setExceptionList(tl); return b;
			}
			case 131: // constructor_declaration = IDENTIFIER.id LPAREN.LPAREN RPAREN.RPAREN throws.tl constructor_body.b
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol _symbol_tl = _symbols[offset + 4];
					final List tl = (List) _symbol_tl.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setID(((String)id.value)); b.setExceptionList(tl); return b;
			}
			case 132: // constructor_declaration = modifiers.m IDENTIFIER.id LPAREN.LPAREN formal_parameter_list.pl RPAREN.RPAREN constructor_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_pl = _symbols[offset + 4];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_b = _symbols[offset + 6];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setModifiers(m); b.setID(((String)id.value)); b.setParameterList(pl); return b;
			}
			case 133: // constructor_declaration = IDENTIFIER.id LPAREN.LPAREN formal_parameter_list.pl RPAREN.RPAREN constructor_body.b
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_pl = _symbols[offset + 3];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setID(((String)id.value)); b.setParameterList(pl); return b;
			}
			case 134: // constructor_declaration = modifiers.m IDENTIFIER.id LPAREN.LPAREN RPAREN.RPAREN constructor_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setModifiers(m); b.setID(((String)id.value)); return b;
			}
			case 135: // constructor_declaration = IDENTIFIER.id LPAREN.LPAREN RPAREN.RPAREN constructor_body.b
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final ConstructorDecl b = (ConstructorDecl) _symbol_b.value;
					 b.setID(((String)id.value)); return b;
			}
			case 136: // constructor_body = LBRACE.LBRACE explicit_constructor_invocation.c block_statements.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 return new ConstructorDecl(new Modifiers(), null, new List(), new List(), new Opt(c), new Block(l));
			}
			case 137: // constructor_body = LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ConstructorDecl(new Modifiers(), null, new List(), new List(), new Opt(c), new Block(new List()));
			}
			case 138: // constructor_body = LBRACE.LBRACE block_statements.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ConstructorDecl(new Modifiers(), null, new List(), new List(), new Opt(), new Block(l));
			}
			case 139: // constructor_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new ConstructorDecl(new Modifiers(), null, new List(), new List(), new Opt(), new Block(new List()));
			}
			case 140: // explicit_constructor_invocation = THIS.THIS LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol THIS = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 ConstructorAccess c = new ConstructorAccess("this", l);
       c.setStart(THIS.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c);
			}
			case 141: // explicit_constructor_invocation = SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol SEMICOLON = _symbols[offset + 5];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(c);
			}
			case 142: // explicit_constructor_invocation = primary.p DOT.DOT SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(p.qualifiesAccess(c));
			}
			case 143: // explicit_constructor_invocation = name.n DOT.DOT SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 SuperConstructorAccess c = new SuperConstructorAccess("super", l);
       c.setStart(SUPER.getStart());
       c.setEnd(RPAREN.getEnd());
       return new ExprStmt(n.qualifiesAccess(c));
			}
			case 144: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.id extends_interfaces.i interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(m, ((String)id.value), i, b);
			}
			case 145: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.id extends_interfaces.i interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(), ((String)id.value), i, b);
			}
			case 146: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.id interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(m, ((String)id.value), new List(), b);
			}
			case 147: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.id interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new InterfaceDecl(new Modifiers(), ((String)id.value), new List(), b);
			}
			case 148: // extends_interfaces = EXTENDS.EXTENDS interface_type.i
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final Access i = (Access) _symbol_i.value;
					 return new List().add(i);
			}
			case 149: // extends_interfaces = extends_interfaces.l COMMA.COMMA interface_type.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final Access i = (Access) _symbol_i.value;
					 return l.add(i);
			}
			case 150: // interface_body = LBRACE.LBRACE interface_member_declarations.i RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return i;
			}
			case 151: // interface_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new List();
			}
			case 152: // interface_member_declarations = interface_member_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 153: // interface_member_declarations = interface_member_declarations.l interface_member_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 154: // interface_member_declaration = constant_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final BodyDecl c = (BodyDecl) _symbol_c.value;
					 return c;
			}
			case 155: // interface_member_declaration = abstract_method_declaration.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final BodyDecl a = (BodyDecl) _symbol_a.value;
					 return a;
			}
			case 156: // interface_member_declaration = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new MemberClassDecl(c);
			}
			case 157: // interface_member_declaration = interface_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final InterfaceDecl i = (InterfaceDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 158: // interface_member_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new StaticInitializer(new Block());
			}
			case 159: // constant_declaration = field_declaration.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final BodyDecl f = (BodyDecl) _symbol_f.value;
					 return f;
			}
			case 160: // abstract_method_declaration = method_header.m SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final MethodDecl m = (MethodDecl) _symbol_m.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return m;
			}
			case 161: // array_initializer = LBRACE.LBRACE variable_initializers.v COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return new ArrayInit(v);
			}
			case 162: // array_initializer = LBRACE.LBRACE variable_initializers.v RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_v = _symbols[offset + 2];
					final List v = (List) _symbol_v.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ArrayInit(v);
			}
			case 163: // array_initializer = LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ArrayInit(new List());
			}
			case 164: // array_initializer = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new ArrayInit(new List());
			}
			case 165: // variable_initializers = variable_initializer.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Expr v = (Expr) _symbol_v.value;
					 return new List().add(v);
			}
			case 166: // variable_initializers = variable_initializers.l COMMA.COMMA variable_initializer.v
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final Expr v = (Expr) _symbol_v.value;
					 return l.add(v);
			}
			case 167: // block = LBRACE.LBRACE block_statements.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 168: // block = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new Block(new List());
			}
			case 169: // block_statements = block_statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Stmt b = (Stmt) _symbol_b.value;
					 return new List().add(b);
			}
			case 170: // block_statements = block_statements.l block_statement.b
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return l.add(b);
			}
			case 171: // block_statement = local_variable_declaration_statement.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					 return l;
			}
			case 172: // block_statement = class_declaration.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ClassDecl c = (ClassDecl) _symbol_c.value;
					 return new LocalClassDeclStmt(c);
			}
			case 173: // block_statement = statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 174: // local_variable_declaration_statement = local_variable_declaration.l SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final VarDeclStmt l = (VarDeclStmt) _symbol_l.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return l;
			}
			case 175: // local_variable_declaration = type.t variable_declarators.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new VarDeclStmt(new Modifiers(), t, l);
			}
			case 176: // local_variable_declaration = modifiers.m type.t variable_declarators.l
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new VarDeclStmt(m, t, l);
			}
			case 177: // statement = statement_without_trailing_substatement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 178: // statement = labeled_statement.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final LabeledStmt l = (LabeledStmt) _symbol_l.value;
					 return l;
			}
			case 179: // statement = if_then_statement.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 180: // statement = if_then_else_statement.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 181: // statement = while_statement.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final WhileStmt w = (WhileStmt) _symbol_w.value;
					 return w;
			}
			case 182: // statement = for_statement.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ForStmt f = (ForStmt) _symbol_f.value;
					 return f;
			}
			case 183: // statement_without_trailing_substatement = block.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Block b = (Block) _symbol_b.value;
					 return b;
			}
			case 184: // statement_without_trailing_substatement = empty_statement.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final EmptyStmt e = (EmptyStmt) _symbol_e.value;
					 return e;
			}
			case 185: // statement_without_trailing_substatement = expression_statement.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return e;
			}
			case 186: // statement_without_trailing_substatement = switch_statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final SwitchStmt s = (SwitchStmt) _symbol_s.value;
					 return s;
			}
			case 187: // statement_without_trailing_substatement = do_statement.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final DoStmt d = (DoStmt) _symbol_d.value;
					 return d;
			}
			case 188: // statement_without_trailing_substatement = break_statement.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final BreakStmt b = (BreakStmt) _symbol_b.value;
					 return b;
			}
			case 189: // statement_without_trailing_substatement = continue_statement.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final ContinueStmt c = (ContinueStmt) _symbol_c.value;
					 return c;
			}
			case 190: // statement_without_trailing_substatement = return_statement.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final ReturnStmt r = (ReturnStmt) _symbol_r.value;
					 return r;
			}
			case 191: // statement_without_trailing_substatement = synchronized_statement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final SynchronizedStmt s = (SynchronizedStmt) _symbol_s.value;
					 return s;
			}
			case 192: // statement_without_trailing_substatement = throw_statement.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ThrowStmt t = (ThrowStmt) _symbol_t.value;
					 return t;
			}
			case 193: // statement_without_trailing_substatement = try_statement.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final TryStmt t = (TryStmt) _symbol_t.value;
					 return t;
			}
			case 194: // statement_without_trailing_substatement = assert_statement.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final AssertStmt a = (AssertStmt) _symbol_a.value;
					 return a;
			}
			case 195: // statement_no_short_if = statement_without_trailing_substatement.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return s;
			}
			case 196: // statement_no_short_if = labeled_statement_no_short_if.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final LabeledStmt l = (LabeledStmt) _symbol_l.value;
					 return l;
			}
			case 197: // statement_no_short_if = if_then_else_statement_no_short_if.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final IfStmt i = (IfStmt) _symbol_i.value;
					 return i;
			}
			case 198: // statement_no_short_if = while_statement_no_short_if.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final WhileStmt w = (WhileStmt) _symbol_w.value;
					 return w;
			}
			case 199: // statement_no_short_if = for_statement_no_short_if.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final ForStmt f = (ForStmt) _symbol_f.value;
					 return f;
			}
			case 200: // if_then_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new IfStmt(e, s, new Opt());
			}
			case 201: // if_then_else_statement = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(e, t, new Opt(els));
			}
			case 202: // if_then_else_statement_no_short_if = IF.IF LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.t ELSE.ELSE statement_no_short_if.els
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 5];
					final Stmt t = (Stmt) _symbol_t.value;
					final Symbol ELSE = _symbols[offset + 6];
					final Symbol _symbol_els = _symbols[offset + 7];
					final Stmt els = (Stmt) _symbol_els.value;
					 return new IfStmt(e, t, new Opt(els));
			}
			case 203: // empty_statement = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new EmptyStmt();
			}
			case 204: // labeled_statement = IDENTIFIER.id COLON.COLON statement.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(((String)id.value), s);
			}
			case 205: // labeled_statement_no_short_if = IDENTIFIER.id COLON.COLON statement_no_short_if.s
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new LabeledStmt(((String)id.value), s);
			}
			case 206: // expression_statement = statement_expression.e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return e;
			}
			case 207: // statement_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new ExprStmt(a);
			}
			case 208: // statement_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 209: // statement_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 210: // statement_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 211: // statement_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 212: // statement_expression = method_invocation.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Access i = (Access) _symbol_i.value;
					 return new ExprStmt(i);
			}
			case 213: // statement_expression = class_instance_creation_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
			}
			case 214: // switch_statement = SWITCH.SWITCH LPAREN.LPAREN expression.e RPAREN.RPAREN switch_block.l
			{
					final Symbol SWITCH = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final Block l = (Block) _symbol_l.value;
					 return new SwitchStmt(e, l);
			}
			case 215: // switch_block = LBRACE.LBRACE switch_block_statement_groups.l switch_labels.s RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final List s = (List) _symbol_s.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 for(int ii = 0; ii < s.getNumChild(); ii++) l.add(s.getChildNoTransform(ii)); return new Block(l);
			}
			case 216: // switch_block = LBRACE.LBRACE switch_block_statement_groups.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 217: // switch_block = LBRACE.LBRACE switch_labels.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new Block(l);
			}
			case 218: // switch_block = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new Block(new List());
			}
			case 219: // switch_block_statement_groups = switch_block_statement_group.g
			{
					final Symbol _symbol_g = _symbols[offset + 1];
					final List g = (List) _symbol_g.value;
					 return g;
			}
			case 220: // switch_block_statement_groups = switch_block_statement_groups.l switch_block_statement_group.g
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_g = _symbols[offset + 2];
					final List g = (List) _symbol_g.value;
					 for(int ii = 0; ii < g.getNumChild(); ii++)
           l.add(g.getChildNoTransform(ii));
         return l;
			}
			case 221: // switch_block_statement_group = switch_labels.l block_statements.bl
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_bl = _symbols[offset + 2];
					final List bl = (List) _symbol_bl.value;
					 for(int ii = 0; ii < bl.getNumChild(); ii++)
          l.add(bl.getChildNoTransform(ii));
          return l;
			}
			case 222: // switch_labels = switch_label.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Case s = (Case) _symbol_s.value;
					 return new List().add(s);
			}
			case 223: // switch_labels = switch_labels.l switch_label.s
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_s = _symbols[offset + 2];
					final Case s = (Case) _symbol_s.value;
					 return l.add(s);
			}
			case 224: // switch_label = CASE.CASE constant_expression.e COLON.COLON
			{
					final Symbol CASE = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol COLON = _symbols[offset + 3];
					 return new ConstCase(e);
			}
			case 225: // switch_label = DEFAULT.DEFAULT COLON.COLON
			{
					final Symbol DEFAULT = _symbols[offset + 1];
					final Symbol COLON = _symbols[offset + 2];
					 return new DefaultCase();
			}
			case 226: // while_statement = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(e, s);
			}
			case 227: // while_statement_no_short_if = WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new WhileStmt(e, s);
			}
			case 228: // do_statement = DO.DO statement.s WHILE.WHILE LPAREN.LPAREN expression.e RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol DO = _symbols[offset + 1];
					final Symbol _symbol_s = _symbols[offset + 2];
					final Stmt s = (Stmt) _symbol_s.value;
					final Symbol WHILE = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new DoStmt(s, e);
			}
			case 229: // for_statement = FOR.FOR LPAREN.LPAREN for_init.i SEMICOLON.SEMICOLON expression.e SEMICOLON.SEMICOLON_ for_update.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, new Opt(e), u, s);
			}
			case 230: // for_statement = FOR.FOR LPAREN.LPAREN SEMICOLON.SEMICOLON expression.e SEMICOLON.SEMICOLON_ for_update.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 5];
					final Symbol _symbol_u = _symbols[offset + 6];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(new List(), new Opt(e), u, s);
			}
			case 231: // for_statement = FOR.FOR LPAREN.LPAREN for_init.i SEMICOLON.SEMICOLON SEMICOLON.SEMICOLON_ for_update.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol SEMICOLON_ = _symbols[offset + 5];
					final Symbol _symbol_u = _symbols[offset + 6];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, new Opt(), u, s);
			}
			case 232: // for_statement = FOR.FOR LPAREN.LPAREN SEMICOLON.SEMICOLON SEMICOLON.SEMICOLON_ for_update.u RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					final Symbol SEMICOLON_ = _symbols[offset + 4];
					final Symbol _symbol_u = _symbols[offset + 5];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(new List(), new Opt(), u, s);
			}
			case 233: // for_statement = FOR.FOR LPAREN.LPAREN for_init.i SEMICOLON.SEMICOLON expression.e SEMICOLON.SEMICOLON_ RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, new Opt(e), new List(), s);
			}
			case 234: // for_statement = FOR.FOR LPAREN.LPAREN SEMICOLON.SEMICOLON expression.e SEMICOLON.SEMICOLON_ RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 5];
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(new List(), new Opt(e), new List(), s);
			}
			case 235: // for_statement = FOR.FOR LPAREN.LPAREN for_init.i SEMICOLON.SEMICOLON SEMICOLON.SEMICOLON_ RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol SEMICOLON_ = _symbols[offset + 5];
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, new Opt(), new List(), s);
			}
			case 236: // for_statement = FOR.FOR LPAREN.LPAREN SEMICOLON.SEMICOLON SEMICOLON.SEMICOLON_ RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					final Symbol SEMICOLON_ = _symbols[offset + 4];
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_s = _symbols[offset + 6];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(new List(), new Opt(), new List(), s);
			}
			case 237: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN for_init.i SEMICOLON.SEMICOLON expression.e SEMICOLON.SEMICOLON_ for_update.u RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol _symbol_u = _symbols[offset + 7];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, new Opt(e), u, s);
			}
			case 238: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN SEMICOLON.SEMICOLON expression.e SEMICOLON.SEMICOLON_ for_update.u RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 5];
					final Symbol _symbol_u = _symbols[offset + 6];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(new List(), new Opt(e), u, s);
			}
			case 239: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN for_init.i SEMICOLON.SEMICOLON SEMICOLON.SEMICOLON_ for_update.u RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol SEMICOLON_ = _symbols[offset + 5];
					final Symbol _symbol_u = _symbols[offset + 6];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, new Opt(), u, s);
			}
			case 240: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN SEMICOLON.SEMICOLON SEMICOLON.SEMICOLON_ for_update.u RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					final Symbol SEMICOLON_ = _symbols[offset + 4];
					final Symbol _symbol_u = _symbols[offset + 5];
					final List u = (List) _symbol_u.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(new List(), new Opt(), u, s);
			}
			case 241: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN for_init.i SEMICOLON.SEMICOLON expression.e SEMICOLON.SEMICOLON_ RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 6];
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, new Opt(e), new List(), s);
			}
			case 242: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN SEMICOLON.SEMICOLON expression.e SEMICOLON.SEMICOLON_ RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON_ = _symbols[offset + 5];
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(new List(), new Opt(e), new List(), s);
			}
			case 243: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN for_init.i SEMICOLON.SEMICOLON SEMICOLON.SEMICOLON_ RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol SEMICOLON = _symbols[offset + 4];
					final Symbol SEMICOLON_ = _symbols[offset + 5];
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(i, new Opt(), new List(), s);
			}
			case 244: // for_statement_no_short_if = FOR.FOR LPAREN.LPAREN SEMICOLON.SEMICOLON SEMICOLON.SEMICOLON_ RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					final Symbol SEMICOLON_ = _symbols[offset + 4];
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_s = _symbols[offset + 6];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new ForStmt(new List(), new Opt(), new List(), s);
			}
			case 245: // for_init = statement_expression_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 246: // for_init = local_variable_declaration.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final VarDeclStmt d = (VarDeclStmt) _symbol_d.value;
					 return new List().add(d);
			}
			case 247: // for_update = statement_expression_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 248: // statement_expression_list = statement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return new List().add(e);
			}
			case 249: // statement_expression_list = statement_expression_list.l COMMA.COMMA statement_expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final ExprStmt e = (ExprStmt) _symbol_e.value;
					 return l.add(e);
			}
			case 250: // break_statement = BREAK.BREAK IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new BreakStmt(((String)id.value));
			}
			case 251: // break_statement = BREAK.BREAK SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new BreakStmt("");
			}
			case 252: // continue_statement = CONTINUE.CONTINUE IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ContinueStmt(((String)id.value));
			}
			case 253: // continue_statement = CONTINUE.CONTINUE SEMICOLON.SEMICOLON
			{
					final Symbol CONTINUE = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new ContinueStmt("");
			}
			case 254: // return_statement = RETURN.RETURN expression.e SEMICOLON.SEMICOLON
			{
					final Symbol RETURN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ReturnStmt(new Opt(e));
			}
			case 255: // return_statement = RETURN.RETURN SEMICOLON.SEMICOLON
			{
					final Symbol RETURN = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new ReturnStmt(new Opt());
			}
			case 256: // throw_statement = THROW.THROW expression.e SEMICOLON.SEMICOLON
			{
					final Symbol THROW = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ThrowStmt(e);
			}
			case 257: // synchronized_statement = SYNCHRONIZED.SYNCHRONIZED LPAREN.LPAREN expression.e RPAREN.RPAREN block.b
			{
					final Symbol SYNCHRONIZED = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new SynchronizedStmt(e, b);
			}
			case 258: // try_statement = TRY.TRY block.b catches.c
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final List c = (List) _symbol_c.value;
					 return new TryStmt(b, c, new Opt());
			}
			case 259: // try_statement = TRY.TRY block.b catches.c finally.f
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final List c = (List) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 4];
					final Block f = (Block) _symbol_f.value;
					 return new TryStmt(b, c, new Opt(f));
			}
			case 260: // try_statement = TRY.TRY block.b finally.f
			{
					final Symbol TRY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Block f = (Block) _symbol_f.value;
					 return new TryStmt(b, new List(), new Opt(f));
			}
			case 261: // catches = catch_clause.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final CatchClause c = (CatchClause) _symbol_c.value;
					 return new List().add(c);
			}
			case 262: // catches = catches.l catch_clause.c
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_c = _symbols[offset + 2];
					final CatchClause c = (CatchClause) _symbol_c.value;
					 return l.add(c);
			}
			case 263: // catch_clause = CATCH.CATCH LPAREN.LPAREN formal_parameter.p RPAREN.RPAREN block.b
			{
					final Symbol CATCH = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParameterDeclaration p = (ParameterDeclaration) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return new CatchClause(p, b);
			}
			case 264: // finally = FINALLY.FINALLY block.b
			{
					final Symbol FINALLY = _symbols[offset + 1];
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return b;
			}
			case 265: // assert_statement = ASSERT.ASSERT expression.e SEMICOLON.SEMICOLON
			{
					final Symbol ASSERT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new AssertStmt(e, new Opt());
			}
			case 266: // assert_statement = ASSERT.ASSERT expression.e COLON.COLON expression.s SEMICOLON.SEMICOLON
			{
					final Symbol ASSERT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol COLON = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final Expr s = (Expr) _symbol_s.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new AssertStmt(e, new Opt(s));
			}
			case 267: // primary = primary_no_new_array.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 268: // primary = array_creation_init.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 269: // primary = array_creation_uninit.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 270: // class_literal = CLASS.CLASS
			{
					final Symbol CLASS = _symbols[offset + 1];
					 return new ClassAccess();
			}
			case 271: // class_instance_creation_expression = NEW.NEW class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new ClassInstanceExpr(t, l, new Opt());
			}
			case 272: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 ClassInstanceExpr e = new ClassInstanceExpr(id, l, new Opt());
       e.setStart(NEW.getStart());
       e.setEnd(RPAREN.getEnd());
       return n.qualifiesAccess(e);
			}
			case 273: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 ClassInstanceExpr e = new ClassInstanceExpr(id, l, new Opt());
       e.setStart(NEW.getStart());
       e.setEnd(RPAREN.getEnd());
       return n.qualifiesAccess(e);
			}
			case 274: // class_instance_creation_expression = NEW.NEW class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body.b
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_b = _symbols[offset + 6];
					final Opt b = (Opt) _symbol_b.value;
					 return new ClassInstanceExpr(t, l, b);
			}
			case 275: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_b = _symbols[offset + 8];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(id, l, b);
       e.setStart(NEW.getStart());
       e.setEnd(b.getEnd());
       return n.qualifiesAccess(e);
			}
			case 276: // class_instance_creation_expression = name.n DOT.DOT NEW.NEW simple_name.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_id = _symbols[offset + 4];
					final Access id = (Access) _symbol_id.value;
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_b = _symbols[offset + 8];
					final Opt b = (Opt) _symbol_b.value;
					 ClassInstanceExpr e = new ClassInstanceExpr(id, l, b);
       e.setStart(NEW.getStart());
       e.setEnd(b.getEnd());
       return n.qualifiesAccess(e);
			}
			case 277: // subclass_body = class_body.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final List b = (List) _symbol_b.value;
					 return new Opt(new AnonymousDecl(new Modifiers(), "Anonymous", b));
			}
			case 278: // argument_list_opt = 
			{
					 return new List();
			}
			case 279: // argument_list_opt = argument_list.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return a;
			}
			case 280: // argument_list = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new List().add(e);
			}
			case 281: // argument_list = argument_list.l COMMA.COMMA expression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return l.add(e);
			}
			case 282: // array_creation_uninit = NEW.NEW primitive_type.t dim_exprs.d
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new ArrayCreationExpr(t, d, new Opt());
			}
			case 283: // array_creation_uninit = NEW.NEW primitive_type.t dim_exprs.d dims.e
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final List e = (List) _symbol_e.value;
					 for(int i = 0; i < e.getNumChild(); i++) d.add(e.getChildNoTransform(i)); return new ArrayCreationExpr(t, d, new Opt());
			}
			case 284: // array_creation_uninit = NEW.NEW class_or_interface_type.t dim_exprs.d
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					 return new ArrayCreationExpr(t, d, new Opt());
			}
			case 285: // array_creation_uninit = NEW.NEW class_or_interface_type.t dim_exprs.d dims.e
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final List e = (List) _symbol_e.value;
					 for(int i = 0; i < e.getNumChild(); i++) d.add(e.getChildNoTransform(i)); return new ArrayCreationExpr(t, d, new Opt());
			}
			case 286: // array_creation_init = NEW.NEW primitive_type.t dims.d array_initializer.i
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayInit i = (ArrayInit) _symbol_i.value;
					 return new ArrayCreationExpr(t, d, new Opt(i));
			}
			case 287: // array_creation_init = NEW.NEW class_or_interface_type.t dims.d array_initializer.i
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayInit i = (ArrayInit) _symbol_i.value;
					 return new ArrayCreationExpr(t, d, new Opt(i));
			}
			case 288: // dim_exprs = dim_expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Dims e = (Dims) _symbol_e.value;
					 return new List().add(e);
			}
			case 289: // dim_exprs = dim_exprs.l dim_expr.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final Dims e = (Dims) _symbol_e.value;
					 return l.add(e);
			}
			case 290: // dim_expr = LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return new Dims(new Opt(e));
			}
			case 291: // dims = LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol RBRACK = _symbols[offset + 2];
					 return new List().add(new Dims(new Opt()));
			}
			case 292: // dims = dims.l LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol RBRACK = _symbols[offset + 3];
					 return l.add(new Dims(new Opt()));
			}
			case 293: // field_access = primary.p DOT.DOT simple_name.id
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_id = _symbols[offset + 3];
					final Access id = (Access) _symbol_id.value;
					 return p.qualifiesAccess(id);
			}
			case 294: // field_access = SUPER.SUPER DOT.DOT simple_name.id
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_id = _symbols[offset + 3];
					final Access id = (Access) _symbol_id.value;
					 SuperAccess s = new SuperAccess("super");
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return s.qualifiesAccess(id);
			}
			case 295: // field_access = name.n DOT.DOT SUPER.SUPER DOT.DOT_ simple_name.id
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol DOT_ = _symbols[offset + 4];
					final Symbol _symbol_id = _symbols[offset + 5];
					final Access id = (Access) _symbol_id.value;
					 SuperAccess s = new SuperAccess("super");
       s.setStart(SUPER.getStart());
       s.setEnd(SUPER.getEnd());
       return n.qualifiesAccess(s).qualifiesAccess(id);
			}
			case 296: // method_invocation = name.n LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 if(n instanceof AbstractDot) {    
                                                               AbstractDot d = (AbstractDot)n; 
                                                               ParseName pn = (ParseName)d.extractLast();
                                                               MethodAccess m = new MethodAccess(pn.getID(), l);
                                                               m.setStart(n.getStart()); // add location information
                                                               m.setEnd(RPAREN.getEnd()); // add location information
                                                               d.replaceLast(m);
                                                               return d;
                                                             }
                                                             else {
                                                               ParseName pn = (ParseName)n;
                                                               return new MethodAccess(pn.getID(), l);
                                                             }
			}
			case 297: // method_invocation = primary.p DOT.DOT IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 String id = (String)IDENTIFIER.value; // extract token value
        MethodAccess m = new MethodAccess(id, l);
        m.setStart(IDENTIFIER.getStart()); // add location information
        m.setEnd(RPAREN.getEnd()); // add location information
        return p.qualifiesAccess(m);
			}
			case 298: // method_invocation = SUPER.SUPER DOT.DOT IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol IDENTIFIER = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 String id = (String)IDENTIFIER.value; // extract token value
        SuperAccess s = new SuperAccess("super");
        s.setStart(SUPER.getStart());
        s.setEnd(SUPER.getEnd());
        MethodAccess m = new MethodAccess(id, l);
        m.setStart(IDENTIFIER.getStart());
        m.setEnd(RPAREN.getEnd());
        return s.qualifiesAccess(m);
			}
			case 299: // method_invocation = name.n DOT.DOT SUPER.SUPER DOT.DOT_ IDENTIFIER.IDENTIFIER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol DOT_ = _symbols[offset + 4];
					final Symbol IDENTIFIER = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					 String id = (String)IDENTIFIER.value; // extract token value
        SuperAccess s = new SuperAccess("super");
        s.setStart(SUPER.getStart());
        s.setEnd(SUPER.getEnd());
        MethodAccess m = new MethodAccess(id, l);
        m.setStart(IDENTIFIER.getStart());
        m.setEnd(RPAREN.getEnd());
        return n.qualifiesAccess(s).qualifiesAccess(m);
			}
			case 300: // array_access = name.n LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 4];
					 ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return n.qualifiesAccess(a);
			}
			case 301: // array_access = primary_no_new_array.p LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 4];
					 ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return p.qualifiesAccess(a);
			}
			case 302: // array_access = array_creation_init.i LBRACK.LBRACK expression.e RBRACK.RBRACK
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final Expr i = (Expr) _symbol_i.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RBRACK = _symbols[offset + 4];
					 ArrayAccess a = new ArrayAccess(e);
                                                         a.setStart(LBRACK.getStart());
                                                         a.setEnd(RBRACK.getEnd());
                                                         return i.qualifiesAccess(a);
			}
			case 303: // postfix_expression = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 304: // postfix_expression = name.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return n;
			}
			case 305: // postfix_expression = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 306: // postfix_expression = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 307: // postincrement_expression = postfix_expression.e PLUSPLUS.PLUSPLUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol PLUSPLUS = _symbols[offset + 2];
					 return new PostIncExpr(e);
			}
			case 308: // postdecrement_expression = postfix_expression.e MINUSMINUS.MINUSMINUS
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol MINUSMINUS = _symbols[offset + 2];
					 return new PostDecExpr(e);
			}
			case 309: // unary_expression = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 310: // unary_expression = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 311: // unary_expression = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 312: // unary_expression = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 313: // unary_expression = unary_expression_not_plus_minus.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 314: // preincrement_expression = PLUSPLUS.PLUSPLUS unary_expression.e
			{
					final Symbol PLUSPLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreIncExpr(e);
			}
			case 315: // predecrement_expression = MINUSMINUS.MINUSMINUS unary_expression.e
			{
					final Symbol MINUSMINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PreDecExpr(e);
			}
			case 316: // unary_expression_not_plus_minus = postfix_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 317: // unary_expression_not_plus_minus = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 318: // unary_expression_not_plus_minus = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 319: // unary_expression_not_plus_minus = cast_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 320: // cast_expression = LPAREN.LPAREN primitive_type.t dims.d RPAREN.RPAREN unary_expression.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayTypeAccess a = new ArrayTypeAccess(t, d.getNumChild());
                                                                     a.setStart(t.getStart()); a.setEnd(d.getEnd());
                                                                     return new CastExpr(a, e);
			}
			case 321: // cast_expression = LPAREN.LPAREN primitive_type.t RPAREN.RPAREN unary_expression.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(t, e);
			}
			case 322: // cast_expression = LPAREN.LPAREN name.n dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayTypeAccess a = new ArrayTypeAccess(n, d.getNumChild());
                                                                     a.setStart(n.getStart()); a.setEnd(d.getEnd());
                                                                     return new CastExpr(a, e);
			}
			case 323: // cast_expression = LPAREN.LPAREN name.n RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(n, e);
			}
			case 324: // multiplicative_expression = unary_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 325: // multiplicative_expression = multiplicative_expression.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 326: // multiplicative_expression = multiplicative_expression.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 327: // multiplicative_expression = multiplicative_expression.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 328: // additive_expression = multiplicative_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 329: // additive_expression = additive_expression.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 330: // additive_expression = additive_expression.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 331: // shift_expression = additive_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 332: // shift_expression = shift_expression.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 333: // shift_expression = shift_expression.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 334: // shift_expression = shift_expression.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 335: // relational_expression = shift_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 336: // relational_expression = relational_expression.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 337: // relational_expression = relational_expression.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 338: // relational_expression = relational_expression.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 339: // relational_expression = relational_expression.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 340: // relational_expression = relational_expression.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 341: // equality_expression = relational_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 342: // equality_expression = equality_expression.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 343: // equality_expression = equality_expression.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 344: // and_expression = equality_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 345: // and_expression = and_expression.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 346: // exclusive_or_expression = and_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 347: // exclusive_or_expression = exclusive_or_expression.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 348: // inclusive_or_expression = exclusive_or_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 349: // inclusive_or_expression = inclusive_or_expression.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 350: // conditional_and_expression = inclusive_or_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 351: // conditional_and_expression = conditional_and_expression.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 352: // conditional_or_expression = conditional_and_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 353: // conditional_or_expression = conditional_or_expression.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 354: // conditional_expression = conditional_or_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 355: // conditional_expression = conditional_or_expression.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 356: // assignment_expression = conditional_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 357: // assignment_expression = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 358: // assignment = postfix_expression.dest assignment_operator.e assignment_expression.source
			{
					final Symbol _symbol_dest = _symbols[offset + 1];
					final Expr dest = (Expr) _symbol_dest.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final AssignExpr e = (AssignExpr) _symbol_e.value;
					final Symbol _symbol_source = _symbols[offset + 3];
					final Expr source = (Expr) _symbol_source.value;
					 e.setDest(dest); e.setSource(source);
                                                                                  e.setStart(dest.getStart()); e.setEnd(source.getEnd());
                                                                                  return e;
			}
			case 359: // assignment_operator = EQ.EQ
			{
					final Symbol EQ = _symbols[offset + 1];
					 return new AssignSimpleExpr(null, null);
			}
			case 360: // assignment_operator = MULTEQ.MULTEQ
			{
					final Symbol MULTEQ = _symbols[offset + 1];
					 return new AssignMulExpr(null, null);
			}
			case 361: // assignment_operator = DIVEQ.DIVEQ
			{
					final Symbol DIVEQ = _symbols[offset + 1];
					 return new AssignDivExpr(null, null);
			}
			case 362: // assignment_operator = MODEQ.MODEQ
			{
					final Symbol MODEQ = _symbols[offset + 1];
					 return new AssignModExpr(null, null);
			}
			case 363: // assignment_operator = PLUSEQ.PLUSEQ
			{
					final Symbol PLUSEQ = _symbols[offset + 1];
					 return new AssignPlusExpr(null, null);
			}
			case 364: // assignment_operator = MINUSEQ.MINUSEQ
			{
					final Symbol MINUSEQ = _symbols[offset + 1];
					 return new AssignMinusExpr(null, null);
			}
			case 365: // assignment_operator = LSHIFTEQ.LSHIFTEQ
			{
					final Symbol LSHIFTEQ = _symbols[offset + 1];
					 return new AssignLShiftExpr(null, null);
			}
			case 366: // assignment_operator = RSHIFTEQ.RSHIFTEQ
			{
					final Symbol RSHIFTEQ = _symbols[offset + 1];
					 return new AssignRShiftExpr(null, null);
			}
			case 367: // assignment_operator = URSHIFTEQ.URSHIFTEQ
			{
					final Symbol URSHIFTEQ = _symbols[offset + 1];
					 return new AssignURShiftExpr(null, null);
			}
			case 368: // assignment_operator = ANDEQ.ANDEQ
			{
					final Symbol ANDEQ = _symbols[offset + 1];
					 return new AssignAndExpr(null, null);
			}
			case 369: // assignment_operator = XOREQ.XOREQ
			{
					final Symbol XOREQ = _symbols[offset + 1];
					 return new AssignXorExpr(null, null);
			}
			case 370: // assignment_operator = OREQ.OREQ
			{
					final Symbol OREQ = _symbols[offset + 1];
					 return new AssignOrExpr(null, null);
			}
			case 371: // expression = assignment_expression.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 372: // constant_expression = expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 373: // class_body_declaration = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new InstanceInitializer(new Block());
			}
			case 374: // class_body_declaration = error.error LBRACE.LBRACE
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol LBRACE = _symbols[offset + 2];
					 return new InstanceInitializer(new Block());
			}
			case 375: // block = error.error RBRACE.RBRACE
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new Block(new List());
			}
			case 376: // statement = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new EmptyStmt();
			}
			case 377: // type_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return i;
			}
			case 378: // interface_member_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 379: // class_member_declaration = annotation_type_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final AnnotationDecl i = (AnnotationDecl) _symbol_i.value;
					 return new MemberInterfaceDecl(i);
			}
			case 380: // annotation_type_declaration = modifiers.m AT.AT INTERFACE.INTERFACE IDENTIFIER.id annotation_type_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol AT = _symbols[offset + 2];
					final Symbol INTERFACE = _symbols[offset + 3];
					final Symbol id = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new AnnotationDecl(m, ((String)id.value), b);
			}
			case 381: // annotation_type_declaration = AT.AT INTERFACE.INTERFACE IDENTIFIER.id annotation_type_body.b
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					 return new AnnotationDecl(new Modifiers(new List()), ((String)id.value), b);
			}
			case 382: // annotation_type_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new List();
			}
			case 383: // annotation_type_body = LBRACE.LBRACE annotation_type_element_declarations.i RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_i = _symbols[offset + 2];
					final List i = (List) _symbol_i.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return i;
			}
			case 384: // annotation_type_element_declarations = annotation_type_element_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return new List().add(i);
			}
			case 385: // annotation_type_element_declarations = annotation_type_element_declarations.l annotation_type_element_declaration.i
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final BodyDecl i = (BodyDecl) _symbol_i.value;
					 return l.add(i);
			}
			case 386: // annotation_type_element_declaration = modifiers.m type.t IDENTIFIER.id LPAREN.LPAREN RPAREN.RPAREN default_value_opt.default_value_opt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol id = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_default_value_opt = _symbols[offset + 6];
					final Opt default_value_opt = (Opt) _symbol_default_value_opt.value;
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new AnnotationMethodDecl(m, t, ((String)id.value), new List(), new List(), new List(), new Opt(), default_value_opt);
			}
			case 387: // annotation_type_element_declaration = type.t IDENTIFIER.id LPAREN.LPAREN RPAREN.RPAREN default_value_opt.default_value_opt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol RPAREN = _symbols[offset + 4];
					final Symbol _symbol_default_value_opt = _symbols[offset + 5];
					final Opt default_value_opt = (Opt) _symbol_default_value_opt.value;
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new AnnotationMethodDecl(new Modifiers(new List()), t, ((String)id.value), new List(), new List(), new List(), new Opt(), default_value_opt);
			}
			case 389: // annotation_type_element_declaration = class_declaration.class_declaration
			{
					final Symbol _symbol_class_declaration = _symbols[offset + 1];
					final ClassDecl class_declaration = (ClassDecl) _symbol_class_declaration.value;
					 return new MemberClassDecl(class_declaration);
			}
			case 390: // annotation_type_element_declaration = interface_declaration.interface_declaration
			{
					final Symbol _symbol_interface_declaration = _symbols[offset + 1];
					final InterfaceDecl interface_declaration = (InterfaceDecl) _symbol_interface_declaration.value;
					 return new MemberInterfaceDecl(interface_declaration);
			}
			case 391: // annotation_type_element_declaration = enum_declaration.enum_declaration
			{
					final Symbol _symbol_enum_declaration = _symbols[offset + 1];
					final EnumDecl enum_declaration = (EnumDecl) _symbol_enum_declaration.value;
					 return new MemberClassDecl(enum_declaration);
			}
			case 392: // annotation_type_element_declaration = annotation_type_declaration.annotation_type_declaration
			{
					final Symbol _symbol_annotation_type_declaration = _symbols[offset + 1];
					final AnnotationDecl annotation_type_declaration = (AnnotationDecl) _symbol_annotation_type_declaration.value;
					 return new MemberInterfaceDecl(annotation_type_declaration);
			}
			case 393: // annotation_type_element_declaration = SEMICOLON.SEMICOLON
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					 return new StaticInitializer(new Block());
			}
			case 394: // default_value_opt = 
			{
					 return new Opt();
			}
			case 395: // default_value_opt = default_value.default_value
			{
					final Symbol _symbol_default_value = _symbols[offset + 1];
					final ElementValue default_value = (ElementValue) _symbol_default_value.value;
					 return new Opt(default_value);
			}
			case 396: // default_value = DEFAULT.DEFAULT element_value.element_value
			{
					final Symbol DEFAULT = _symbols[offset + 1];
					final Symbol _symbol_element_value = _symbols[offset + 2];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return element_value;
			}
			case 401: // normal_annotation = AT.AT type.type LPAREN.LPAREN element_value_pairs_opt.element_value_pairs_opt RPAREN.RPAREN
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_element_value_pairs_opt = _symbols[offset + 4];
					final List element_value_pairs_opt = (List) _symbol_element_value_pairs_opt.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new Annotation("annotation", type, element_value_pairs_opt);
			}
			case 402: // element_value_pairs_opt = 
			{
					 return new List();
			}
			case 403: // element_value_pairs_opt = element_value_pairs.element_value_pairs
			{
					final Symbol _symbol_element_value_pairs = _symbols[offset + 1];
					final List element_value_pairs = (List) _symbol_element_value_pairs.value;
					 return element_value_pairs;
			}
			case 404: // element_value_pairs = element_value_pair.element_value_pair
			{
					final Symbol _symbol_element_value_pair = _symbols[offset + 1];
					final ElementValuePair element_value_pair = (ElementValuePair) _symbol_element_value_pair.value;
					 return new List().add(element_value_pair);
			}
			case 405: // element_value_pairs = element_value_pairs.element_value_pairs COMMA.COMMA element_value_pair.element_value_pair
			{
					final Symbol _symbol_element_value_pairs = _symbols[offset + 1];
					final List element_value_pairs = (List) _symbol_element_value_pairs.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_element_value_pair = _symbols[offset + 3];
					final ElementValuePair element_value_pair = (ElementValuePair) _symbol_element_value_pair.value;
					 return element_value_pairs.add(element_value_pair);
			}
			case 406: // element_value_pair = IDENTIFIER.id EQ.EQ element_value.element_value
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_element_value = _symbols[offset + 3];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return new ElementValuePair(((String)id.value), element_value);
			}
			case 407: // element_value = conditional_expression.conditional_expression
			{
					final Symbol _symbol_conditional_expression = _symbols[offset + 1];
					final Expr conditional_expression = (Expr) _symbol_conditional_expression.value;
					 return new ElementConstantValue(conditional_expression);
			}
			case 408: // element_value = annotation.annotation
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return new ElementAnnotationValue(annotation);
			}
			case 409: // element_value = element_value_array_initializer.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final ElementArrayValue e = (ElementArrayValue) _symbol_e.value;
					 return e;
			}
			case 410: // element_value_array_initializer = LBRACE.LBRACE element_values_opt.element_values_opt RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_element_values_opt = _symbols[offset + 2];
					final List element_values_opt = (List) _symbol_element_values_opt.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ElementArrayValue(element_values_opt);
			}
			case 411: // element_value_array_initializer = LBRACE.LBRACE element_values_opt.element_values_opt COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_element_values_opt = _symbols[offset + 2];
					final List element_values_opt = (List) _symbol_element_values_opt.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return new ElementArrayValue(element_values_opt);
			}
			case 412: // element_values_opt = 
			{
					 return new List();
			}
			case 413: // element_values_opt = element_values.element_values
			{
					final Symbol _symbol_element_values = _symbols[offset + 1];
					final List element_values = (List) _symbol_element_values.value;
					 return element_values;
			}
			case 414: // element_values = element_value.element_value
			{
					final Symbol _symbol_element_value = _symbols[offset + 1];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return new List().add(element_value);
			}
			case 415: // element_values = element_values.element_values COMMA.COMMA element_value.element_value
			{
					final Symbol _symbol_element_values = _symbols[offset + 1];
					final List element_values = (List) _symbol_element_values.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_element_value = _symbols[offset + 3];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					 return element_values.add(element_value);
			}
			case 416: // marker_annotation = AT.AT type.type
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					 return new Annotation("annotation", type, new List());
			}
			case 417: // single_element_annotation = AT.AT type.type LPAREN.LPAREN element_value.element_value RPAREN.RPAREN
			{
					final Symbol AT = _symbols[offset + 1];
					final Symbol _symbol_type = _symbols[offset + 2];
					final Access type = (Access) _symbol_type.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_element_value = _symbols[offset + 4];
					final ElementValue element_value = (ElementValue) _symbol_element_value.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new Annotation("annotation", type, new List().add(new ElementValuePair("value", element_value)));
			}
			case 418: // compilation_unit = modifiers.a package_declaration.p import_declarations.i type_declarations.t
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Modifiers a = (Modifiers) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final List t = (List) _symbol_t.value;
					 return new AnnotatedCompilationUnit(p.getID(), i, t, a);
			}
			case 419: // compilation_unit = modifiers.a package_declaration.p type_declarations.t
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Modifiers a = (Modifiers) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final List t = (List) _symbol_t.value;
					 return new AnnotatedCompilationUnit(p.getID(), new List(), t, a);
			}
			case 420: // compilation_unit = modifiers.a package_declaration.p import_declarations.i
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Modifiers a = (Modifiers) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final List i = (List) _symbol_i.value;
					 return new AnnotatedCompilationUnit(p.getID(), i, new List(), a);
			}
			case 421: // compilation_unit = modifiers.a package_declaration.p
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Modifiers a = (Modifiers) _symbol_a.value;
					final Symbol _symbol_p = _symbols[offset + 2];
					final IdUse p = (IdUse) _symbol_p.value;
					 return new AnnotatedCompilationUnit(p.getID(), new List(), new List(), a);
			}
			case 422: // statement = enhanced_for_statement.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Stmt f = (Stmt) _symbol_f.value;
					 return f;
			}
			case 423: // statement_no_short_if = enhanced_for_statement_no_short_if.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Stmt f = (Stmt) _symbol_f.value;
					 return f;
			}
			case 424: // enhanced_for_statement = FOR.FOR LPAREN.LPAREN formal_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParameterDeclaration p = (ParameterDeclaration) _symbol_p.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new EnhancedForStmt(p, e, s);
			}
			case 425: // enhanced_for_statement_no_short_if = FOR.FOR LPAREN.LPAREN formal_parameter.p COLON.COLON expression.e RPAREN.RPAREN statement_no_short_if.s
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final ParameterDeclaration p = (ParameterDeclaration) _symbol_p.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new EnhancedForStmt(p, e, s);
			}
			case 426: // type_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return i;
			}
			case 427: // interface_member_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return new MemberClassDecl(i);
			}
			case 428: // class_member_declaration = enum_declaration.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final EnumDecl i = (EnumDecl) _symbol_i.value;
					 return new MemberClassDecl(i);
			}
			case 429: // enum_declaration = modifiers.modifiers ENUM.ENUM IDENTIFIER.id interfaces.interfaces enum_body.enum_body
			{
					final Symbol _symbol_modifiers = _symbols[offset + 1];
					final Modifiers modifiers = (Modifiers) _symbol_modifiers.value;
					final Symbol ENUM = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_interfaces = _symbols[offset + 4];
					final List interfaces = (List) _symbol_interfaces.value;
					final Symbol _symbol_enum_body = _symbols[offset + 5];
					final List enum_body = (List) _symbol_enum_body.value;
					 return new EnumDecl(modifiers, ((String)id.value), interfaces, enum_body);
			}
			case 430: // enum_declaration = ENUM.ENUM IDENTIFIER.id interfaces.interfaces enum_body.enum_body
			{
					final Symbol ENUM = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_interfaces = _symbols[offset + 3];
					final List interfaces = (List) _symbol_interfaces.value;
					final Symbol _symbol_enum_body = _symbols[offset + 4];
					final List enum_body = (List) _symbol_enum_body.value;
					 return new EnumDecl(new Modifiers(new List()), ((String)id.value), interfaces, enum_body);
			}
			case 431: // enum_declaration = modifiers.modifiers ENUM.ENUM IDENTIFIER.id enum_body.enum_body
			{
					final Symbol _symbol_modifiers = _symbols[offset + 1];
					final Modifiers modifiers = (Modifiers) _symbol_modifiers.value;
					final Symbol ENUM = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_enum_body = _symbols[offset + 4];
					final List enum_body = (List) _symbol_enum_body.value;
					 return new EnumDecl(modifiers, ((String)id.value), new List(), enum_body);
			}
			case 432: // enum_declaration = ENUM.ENUM IDENTIFIER.id enum_body.enum_body
			{
					final Symbol ENUM = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_enum_body = _symbols[offset + 3];
					final List enum_body = (List) _symbol_enum_body.value;
					 return new EnumDecl(new Modifiers(new List()), ((String)id.value), new List(), enum_body);
			}
			case 433: // enum_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new List();
			}
			case 434: // enum_body = LBRACE.LBRACE enum_constants.enum_constants RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_constants = _symbols[offset + 2];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return enum_constants;
			}
			case 435: // enum_body = LBRACE.LBRACE COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol RBRACE = _symbols[offset + 3];
					 return new List();
			}
			case 436: // enum_body = LBRACE.LBRACE enum_constants.enum_constants COMMA.COMMA RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_constants = _symbols[offset + 2];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol RBRACE = _symbols[offset + 4];
					 return enum_constants;
			}
			case 437: // enum_body = LBRACE.LBRACE enum_body_declarations.enum_body_declarations RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_enum_body_declarations = _symbols[offset + 2];
					final List enum_body_declarations = (List) _symbol_enum_body_declarations.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return enum_body_declarations;
			}
			case 438: // enum_body = LBRACE.LBRACE enum_constants.c enum_body_declarations.d RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 3];
					final List d = (List) _symbol_d.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 for(int i = 0; i < d.getNumChild(); i++) c.add(d.getChildNoTransform(i)); return c;
			}
			case 439: // enum_body = LBRACE.LBRACE COMMA.COMMA enum_body_declarations.enum_body_declarations RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_enum_body_declarations = _symbols[offset + 3];
					final List enum_body_declarations = (List) _symbol_enum_body_declarations.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 return enum_body_declarations;
			}
			case 440: // enum_body = LBRACE.LBRACE enum_constants.c COMMA.COMMA enum_body_declarations.d RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final List c = (List) _symbol_c.value;
					final Symbol COMMA = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					final Symbol RBRACE = _symbols[offset + 5];
					 for(int i = 0; i < d.getNumChild(); i++) c.add(d.getChildNoTransform(i)); return c;
			}
			case 441: // enum_constants = enum_constant.enum_constant
			{
					final Symbol _symbol_enum_constant = _symbols[offset + 1];
					final BodyDecl enum_constant = (BodyDecl) _symbol_enum_constant.value;
					 return new List().add(enum_constant);
			}
			case 442: // enum_constants = enum_constants.enum_constants COMMA.COMMA enum_constant.enum_constant
			{
					final Symbol _symbol_enum_constants = _symbols[offset + 1];
					final List enum_constants = (List) _symbol_enum_constants.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_enum_constant = _symbols[offset + 3];
					final BodyDecl enum_constant = (BodyDecl) _symbol_enum_constant.value;
					 return enum_constants.add(enum_constant);
			}
			case 443: // enum_constant = IDENTIFIER.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), new List(), new List());
			}
			case 444: // enum_constant = annotations.annotations IDENTIFIER.id
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), new List(), new List());
			}
			case 445: // enum_constant = IDENTIFIER.id arguments.arguments
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_arguments = _symbols[offset + 2];
					final List arguments = (List) _symbol_arguments.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), arguments, new List());
			}
			case 446: // enum_constant = annotations.annotations IDENTIFIER.id arguments.arguments
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_arguments = _symbols[offset + 3];
					final List arguments = (List) _symbol_arguments.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), arguments, new List());
			}
			case 447: // enum_constant = IDENTIFIER.id class_body.class_body
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_class_body = _symbols[offset + 2];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), new List(), class_body);
			}
			case 448: // enum_constant = annotations.annotations IDENTIFIER.id class_body.class_body
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_class_body = _symbols[offset + 3];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), new List(), class_body);
			}
			case 449: // enum_constant = IDENTIFIER.id arguments.arguments class_body.class_body
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_arguments = _symbols[offset + 2];
					final List arguments = (List) _symbol_arguments.value;
					final Symbol _symbol_class_body = _symbols[offset + 3];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(new List()), ((String)id.value), arguments, class_body);
			}
			case 450: // enum_constant = annotations.annotations IDENTIFIER.id arguments.arguments class_body.class_body
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_arguments = _symbols[offset + 3];
					final List arguments = (List) _symbol_arguments.value;
					final Symbol _symbol_class_body = _symbols[offset + 4];
					final List class_body = (List) _symbol_class_body.value;
					 return new EnumConstant(new Modifiers(annotations), ((String)id.value), arguments, class_body);
			}
			case 451: // arguments = LPAREN.LPAREN argument_list.argument_list RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_argument_list = _symbols[offset + 2];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return argument_list;
			}
			case 452: // annotations = annotation.annotation
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return new List().add(annotation);
			}
			case 453: // annotations = annotations.annotations annotation.annotation
			{
					final Symbol _symbol_annotations = _symbols[offset + 1];
					final List annotations = (List) _symbol_annotations.value;
					final Symbol _symbol_annotation = _symbols[offset + 2];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					 return annotations.add(annotation);
			}
			case 454: // enum_body_declarations = SEMICOLON.SEMICOLON class_body_declarations_opt.class_body_declarations_opt
			{
					final Symbol SEMICOLON = _symbols[offset + 1];
					final Symbol _symbol_class_body_declarations_opt = _symbols[offset + 2];
					final List class_body_declarations_opt = (List) _symbol_class_body_declarations_opt.value;
					 return class_body_declarations_opt;
			}
			case 455: // class_body_declarations_opt = 
			{
					 return new List();
			}
			case 456: // class_body_declarations_opt = class_body_declarations.d
			{
					final Symbol _symbol_d = _symbols[offset + 1];
					final List d = (List) _symbol_d.value;
					 return d;
			}
			case 457: // explicit_constructor_invocation = type_arguments.a THIS.THIS LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol THIS = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new ExprStmt(new ParConstructorAccess("this", l, a));
			}
			case 458: // explicit_constructor_invocation = type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_l = _symbols[offset + 4];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new ExprStmt(new ParSuperConstructorAccess("super", l, a));
			}
			case 459: // explicit_constructor_invocation = primary.p DOT.DOT type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new ExprStmt(p.qualifiesAccess(new ParSuperConstructorAccess("super", l, a)));
			}
			case 460: // explicit_constructor_invocation = name.n DOT.DOT type_arguments.a SUPER.SUPER LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol SUPER = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new ExprStmt(n.qualifiesAccess(new ParSuperConstructorAccess("super", l, a)));
			}
			case 461: // method_invocation = primary.p DOT.DOT type_arguments.a IDENTIFIER.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol id = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return p.qualifiesAccess(new ParMethodAccess(((String)id.value), l, a));
			}
			case 462: // method_invocation = name.n DOT.DOT type_arguments.a IDENTIFIER.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol id = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return n.qualifiesAccess(new ParMethodAccess(((String)id.value), l, a));
			}
			case 463: // method_invocation = SUPER.SUPER DOT.DOT type_arguments.a IDENTIFIER.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol SUPER = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final List a = (List) _symbol_a.value;
					final Symbol id = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_l = _symbols[offset + 6];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 7];
					 return new SuperAccess("super").qualifiesAccess(
		                    new ParMethodAccess(((String)id.value), l, a));
			}
			case 464: // method_invocation = name.n DOT.d1 SUPER.SUPER DOT.d2 type_arguments.a IDENTIFIER.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol d1 = _symbols[offset + 2];
					final Symbol SUPER = _symbols[offset + 3];
					final Symbol d2 = _symbols[offset + 4];
					final Symbol _symbol_a = _symbols[offset + 5];
					final List a = (List) _symbol_a.value;
					final Symbol id = _symbols[offset + 6];
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_l = _symbols[offset + 8];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 9];
					 return n.qualifiesAccess(new SuperAccess("super")).qualifiesAccess(
                            new ParMethodAccess(((String)id.value), l, a));
			}
			case 465: // throws_opt = 
			{
					 return new List();
			}
			case 466: // throws_opt = throws.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final List t = (List) _symbol_t.value;
					 return t;
			}
			case 467: // method_header = modifiers.m LT.LT type_parameter_list_1.l type.t par_method_declarator.d throws_opt.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 5];
					final GenericMethodDecl d = (GenericMethodDecl) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					 d.setModifiers(m); d.setTypeAccess(t); d.setExceptionList(tl); 
		   d.setTypeParameterList(l); return d;
			}
			case 468: // method_header = LT.LT type_parameter_list_1.l type.t par_method_declarator.d throws_opt.tl
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 4];
					final GenericMethodDecl d = (GenericMethodDecl) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					 d.setModifiers(new Modifiers(new List())); d.setTypeAccess(t); d.setExceptionList(tl); 
		   d.setTypeParameterList(l); return d;
			}
			case 469: // method_header = modifiers.m LT.LT type_parameter_list_1.l VOID.VOID par_method_declarator.d throws_opt.tl
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol VOID = _symbols[offset + 4];
					final Symbol _symbol_d = _symbols[offset + 5];
					final GenericMethodDecl d = (GenericMethodDecl) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 6];
					final List tl = (List) _symbol_tl.value;
					 d.setModifiers(m); d.setTypeAccess(new PrimitiveTypeAccess("void"));
		   d.setExceptionList(tl); d.setTypeParameterList(l); return d;
			}
			case 470: // method_header = LT.LT type_parameter_list_1.l VOID.VOID par_method_declarator.d throws_opt.tl
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol VOID = _symbols[offset + 3];
					final Symbol _symbol_d = _symbols[offset + 4];
					final GenericMethodDecl d = (GenericMethodDecl) _symbol_d.value;
					final Symbol _symbol_tl = _symbols[offset + 5];
					final List tl = (List) _symbol_tl.value;
					 d.setModifiers(new Modifiers(new List())); d.setTypeAccess(new PrimitiveTypeAccess("void"));
		   d.setExceptionList(tl); d.setTypeParameterList(l); return d;
			}
			case 471: // constructor_declaration = modifiers.m LT.LT type_parameter_list_1.l IDENTIFIER.id LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl generic_constructor_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol id = _symbols[offset + 4];
					final Symbol LPAREN = _symbols[offset + 5];
					final Symbol _symbol_pl = _symbols[offset + 6];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_tl = _symbols[offset + 8];
					final List tl = (List) _symbol_tl.value;
					final Symbol _symbol_b = _symbols[offset + 9];
					final GenericConstructorDecl b = (GenericConstructorDecl) _symbol_b.value;
					 b.setModifiers(m); b.setID(((String)id.value)); b.setParameterList(pl); b.setExceptionList(tl);  
		   b.setTypeParameterList(l); return b;
			}
			case 472: // constructor_declaration = LT.LT type_parameter_list_1.l IDENTIFIER.id LPAREN.LPAREN formal_parameter_list_opt.pl RPAREN.RPAREN throws_opt.tl generic_constructor_body.b
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol id = _symbols[offset + 3];
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_pl = _symbols[offset + 5];
					final List pl = (List) _symbol_pl.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_tl = _symbols[offset + 7];
					final List tl = (List) _symbol_tl.value;
					final Symbol _symbol_b = _symbols[offset + 8];
					final GenericConstructorDecl b = (GenericConstructorDecl) _symbol_b.value;
					 b.setModifiers(new Modifiers(new List())); b.setID(((String)id.value)); b.setParameterList(pl); b.setExceptionList(tl);  
		   b.setTypeParameterList(l); return b;
			}
			case 473: // generic_constructor_body = LBRACE.LBRACE explicit_constructor_invocation.c block_statements.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 4];
					 return new GenericConstructorDecl(null, null, null, null, new Opt(c), new Block(l), null, new List());
			}
			case 474: // generic_constructor_body = LBRACE.LBRACE explicit_constructor_invocation.c RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 2];
					final ExprStmt c = (ExprStmt) _symbol_c.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new GenericConstructorDecl(null, null, null, null, new Opt(c), new Block(new List()), null, new List());
			}
			case 475: // generic_constructor_body = LBRACE.LBRACE block_statements.l RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new GenericConstructorDecl(null, null, null, null, new Opt(), new Block(l), null, new List());
			}
			case 476: // generic_constructor_body = LBRACE.LBRACE RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol RBRACE = _symbols[offset + 2];
					 return new GenericConstructorDecl(null, null, null, null, new Opt(), new Block(new List()), null, new List());
			}
			case 477: // formal_parameter_list_opt = 
			{
					 return new List();
			}
			case 478: // formal_parameter_list_opt = formal_parameter_list.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 479: // par_method_declarator = IDENTIFIER.id LPAREN.LPAREN formal_parameter_list_opt.p RPAREN.RPAREN
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new GenericMethodDecl(null, null, ((String)id.value), p, new List(), null, new Opt(), null, new List());
			}
			case 480: // par_method_declarator = par_method_declarator.m LBRACK.LBRACK RBRACK.RBRACK
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final GenericMethodDecl m = (GenericMethodDecl) _symbol_m.value;
					final Symbol LBRACK = _symbols[offset + 2];
					final Symbol RBRACK = _symbols[offset + 3];
					 m.addEmptyBracket(new EmptyBracket()); return m;
			}
			case 481: // class_declaration = modifiers.m CLASS.CLASS IDENTIFIER.id type_parameters.p super_opt.s interfaces_opt.i class_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol CLASS = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 6];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 7];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(m, ((String)id.value), s, i, b, p, new List());
			}
			case 482: // class_declaration = CLASS.CLASS IDENTIFIER.id type_parameters.p super_opt.s interfaces_opt.i class_body.b
			{
					final Symbol CLASS = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_s = _symbols[offset + 4];
					final Opt s = (Opt) _symbol_s.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericClassDecl(new Modifiers(new List()), ((String)id.value), s, i, b, p, new List());
			}
			case 483: // super_opt = 
			{
					 return new Opt();
			}
			case 484: // super_opt = super.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final Opt s = (Opt) _symbol_s.value;
					 return s;
			}
			case 485: // interfaces_opt = 
			{
					 return new List();
			}
			case 486: // interfaces_opt = interfaces.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final List i = (List) _symbol_i.value;
					 return i;
			}
			case 487: // extends_interfaces_opt = 
			{
					 return new List();
			}
			case 488: // extends_interfaces_opt = extends_interfaces.extends_interfaces
			{
					final Symbol _symbol_extends_interfaces = _symbols[offset + 1];
					final List extends_interfaces = (List) _symbol_extends_interfaces.value;
					 return extends_interfaces;
			}
			case 489: // interface_declaration = modifiers.m INTERFACE.INTERFACE IDENTIFIER.id type_parameters.p extends_interfaces_opt.i interface_body.b
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol INTERFACE = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol _symbol_p = _symbols[offset + 4];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 5];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(m, ((String)id.value), i, b, p, new List());
			}
			case 490: // interface_declaration = INTERFACE.INTERFACE IDENTIFIER.id type_parameters.p extends_interfaces_opt.i interface_body.b
			{
					final Symbol INTERFACE = _symbols[offset + 1];
					final Symbol id = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final List p = (List) _symbol_p.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final List i = (List) _symbol_i.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final List b = (List) _symbol_b.value;
					 return new GenericInterfaceDecl(new Modifiers(new List()), ((String)id.value), i, b, p, new List());
			}
			case 491: // class_or_interface_type = name.t LT.LT type_argument_list_1.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(t, l);
			}
			case 492: // class_or_interface_type = class_or_interface_type.t DOT.DOT IDENTIFIER.id
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					 return t.qualifiesAccess(new ParseName(((String)id.value)));
			}
			case 493: // class_or_interface_type = class_or_interface_type.t DOT.DOT IDENTIFIER.id LT.LT type_argument_list_1.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol id = _symbols[offset + 3];
					final Symbol LT = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(t.qualifiesAccess(new ParseName(((String)id.value))), l);
			}
			case 494: // array_type = name.t LT.LT type_argument_list_1.l DOT.DOT name.n dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol _symbol_n = _symbols[offset + 5];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 6];
					final List d = (List) _symbol_d.value;
					 return new ArrayTypeAccess(new ParTypeAccess(t, l).qualifiesAccess(n), d.getNumChild());
			}
			case 495: // array_type = name.t LT.LT type_argument_list_1.l dims.d
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_d = _symbols[offset + 4];
					final List d = (List) _symbol_d.value;
					 return new ArrayTypeAccess(new ParTypeAccess(t, l), d.getNumChild());
			}
			case 496: // type_arguments = LT.LT type_argument_list_1.l
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 497: // wildcard = QUESTION.QUESTION
			{
					final Symbol QUESTION = _symbols[offset + 1];
					 return new Wildcard();
			}
			case 498: // wildcard = QUESTION.QUESTION EXTENDS.EXTENDS reference_type.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 499: // wildcard = QUESTION.QUESTION SUPER.SUPER reference_type.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 500: // wildcard_1 = QUESTION.QUESTION GT.GT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol GT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 501: // wildcard_1 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_1.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 502: // wildcard_1 = QUESTION.QUESTION SUPER.SUPER reference_type_1.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 503: // wildcard_2 = QUESTION.QUESTION RSHIFT.RSHIFT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol RSHIFT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 504: // wildcard_2 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_2.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 505: // wildcard_2 = QUESTION.QUESTION SUPER.SUPER reference_type_2.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 506: // wildcard_3 = QUESTION.QUESTION URSHIFT.URSHIFT
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol URSHIFT = _symbols[offset + 2];
					 return new Wildcard();
			}
			case 507: // wildcard_3 = QUESTION.QUESTION EXTENDS.EXTENDS reference_type_3.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol EXTENDS = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardExtends(t);
			}
			case 508: // wildcard_3 = QUESTION.QUESTION SUPER.SUPER reference_type_3.t
			{
					final Symbol QUESTION = _symbols[offset + 1];
					final Symbol SUPER = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new WildcardSuper(t);
			}
			case 509: // subclass_body_opt = 
			{
					 return new Opt();
			}
			case 510: // subclass_body_opt = subclass_body.subclass_body
			{
					final Symbol _symbol_subclass_body = _symbols[offset + 1];
					final Opt subclass_body = (Opt) _symbol_subclass_body.value;
					 return subclass_body;
			}
			case 511: // class_instance_creation_expression = NEW.NEW type_arguments.a class_or_interface_type.t LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN subclass_body_opt.b
			{
					final Symbol NEW = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_l = _symbols[offset + 5];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_b = _symbols[offset + 7];
					final Opt b = (Opt) _symbol_b.value;
					 return new ParClassInstanceExpr(t, l, b, a);
			}
			case 512: // class_instance_creation_expression = primary.n DOT.DOT NEW.NEW type_arguments.ca IDENTIFIER.id LPAREN.LPAREN argument_list_opt.l RPAREN.RPAREN class_body_opt.b
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Expr n = (Expr) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol NEW = _symbols[offset + 3];
					final Symbol _symbol_ca = _symbols[offset + 4];
					final List ca = (List) _symbol_ca.value;
					final Symbol id = _symbols[offset + 5];
					final Symbol LPAREN = _symbols[offset + 6];
					final Symbol _symbol_l = _symbols[offset + 7];
					final List l = (List) _symbol_l.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_b = _symbols[offset + 9];
					final Opt b = (Opt) _symbol_b.value;
					 return n.qualifiesAccess(new ParClassInstanceExpr(new ParseName(((String)id.value)), l, b, ca));
			}
			case 513: // type_argument_list = type_argument.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 514: // type_argument_list = type_argument_list.l COMMA.COMMA type_argument.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 515: // type_argument_list_1 = type_argument_1.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 516: // type_argument_list_1 = type_argument_list.l COMMA.COMMA type_argument_1.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 517: // type_argument_list_2 = type_argument_2.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 518: // type_argument_list_2 = type_argument_list.l COMMA.COMMA type_argument_2.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 519: // type_argument_list_3 = type_argument_3.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return new List().add(a);
			}
			case 520: // type_argument_list_3 = type_argument_list.l COMMA.COMMA type_argument_3.a
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					 return l.add(a);
			}
			case 521: // type_argument = reference_type.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 522: // type_argument = wildcard.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 523: // type_argument_1 = reference_type_1.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 524: // type_argument_1 = wildcard_1.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 525: // type_argument_2 = reference_type_2.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 526: // type_argument_2 = wildcard_2.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 527: // type_argument_3 = reference_type_3.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 528: // type_argument_3 = wildcard_3.w
			{
					final Symbol _symbol_w = _symbols[offset + 1];
					final Access w = (Access) _symbol_w.value;
					 return w;
			}
			case 529: // reference_type_1 = reference_type.t GT.GT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol GT = _symbols[offset + 2];
					 return t;
			}
			case 530: // reference_type_1 = name.t LT.LT type_argument_list_2.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(t, l);
			}
			case 531: // reference_type_2 = reference_type.t RSHIFT.RSHIFT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					 return t;
			}
			case 532: // reference_type_2 = name.t LT.LT type_argument_list_3.l
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 return new ParTypeAccess(t, l);
			}
			case 533: // reference_type_3 = reference_type.t URSHIFT.URSHIFT
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					 return t;
			}
			case 534: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 5];
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a), e);
			}
			case 535: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_d = _symbols[offset + 5];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_e = _symbols[offset + 7];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ArrayTypeAccess(new ParTypeAccess(n, a), d.getNumChild()), e);
			}
			case 536: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 5];
					final Symbol _symbol_t = _symbols[offset + 6];
					final Access t = (Access) _symbol_t.value;
					final Symbol RPAREN = _symbols[offset + 7];
					final Symbol _symbol_e = _symbols[offset + 8];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t), e);
			}
			case 537: // cast_expression = LPAREN.LPAREN name.n LT.LT type_argument_list_1.a DOT.DOT class_or_interface_type.t dims.d RPAREN.RPAREN unary_expression_not_plus_minus.e
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol LT = _symbols[offset + 3];
					final Symbol _symbol_a = _symbols[offset + 4];
					final List a = (List) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 5];
					final Symbol _symbol_t = _symbols[offset + 6];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_d = _symbols[offset + 7];
					final List d = (List) _symbol_d.value;
					final Symbol RPAREN = _symbols[offset + 8];
					final Symbol _symbol_e = _symbols[offset + 9];
					final Expr e = (Expr) _symbol_e.value;
					 return new CastExpr(new ArrayTypeAccess(new ParTypeAccess(n, a).qualifiesAccess(t), d.getNumChild()), e);
			}
			case 538: // type_parameters = LT.LT type_parameter_list_1.l
			{
					final Symbol LT = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return l;
			}
			case 539: // type_parameter_list = type_parameter_list.l COMMA.COMMA type_parameter.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return l.add(p);
			}
			case 540: // type_parameter_list = type_parameter.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return new List().add(p);
			}
			case 541: // type_parameter_list_1 = type_parameter_1.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return new List().add(p);
			}
			case 542: // type_parameter_list_1 = type_parameter_list.l COMMA.COMMA type_parameter_1.p
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_p = _symbols[offset + 3];
					final TypeVariable p = (TypeVariable) _symbol_p.value;
					 return l.add(p);
			}
			case 543: // type_parameter = IDENTIFIER.v
			{
					final Symbol v = _symbols[offset + 1];
					 return new TypeVariable(new Modifiers(), ((String)v.value), new List(), new List());
			}
			case 544: // type_parameter = IDENTIFIER.v type_bound.l
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new TypeVariable(new Modifiers(), ((String)v.value), new List(), l);
			}
			case 545: // type_parameter_1 = IDENTIFIER.v GT.GT
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol GT = _symbols[offset + 2];
					 return new TypeVariable(new Modifiers(), ((String)v.value), new List(), new List());
			}
			case 546: // type_parameter_1 = IDENTIFIER.v type_bound_1.l
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 return new TypeVariable(new Modifiers(), ((String)v.value), new List(), l);
			}
			case 547: // type_bound = EXTENDS.EXTENDS reference_type.t
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return new List().add(t);
			}
			case 548: // type_bound = EXTENDS.EXTENDS reference_type.t additional_bound_list.l
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 l.insertChild(t,0); return l;
			}
			case 549: // type_bound_1 = EXTENDS.EXTENDS reference_type_1.t
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return new List().add(t);
			}
			case 550: // type_bound_1 = EXTENDS.EXTENDS reference_type.t additional_bound_list_1.l
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol _symbol_l = _symbols[offset + 3];
					final List l = (List) _symbol_l.value;
					 l.insertChild(t,0); return l;
			}
			case 551: // additional_bound_list = additional_bound.b additional_bound_list.l
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 l.insertChild(b,0); return l;
			}
			case 552: // additional_bound_list = additional_bound.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					 return new List().add(b);
			}
			case 553: // additional_bound_list_1 = additional_bound.b additional_bound_list_1.l
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final List l = (List) _symbol_l.value;
					 l.insertChild(b,0); return l;
			}
			case 554: // additional_bound_list_1 = additional_bound_1.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Access b = (Access) _symbol_b.value;
					 return new List().add(b);
			}
			case 555: // additional_bound = AND.AND interface_type.t
			{
					final Symbol AND = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 556: // additional_bound_1 = AND.AND reference_type_1.t
			{
					final Symbol AND = _symbols[offset + 1];
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					 return t;
			}
			case 557: // class_body_opt = 
			{
					 return new Opt();
			}
			case 558: // class_body_opt = class_body.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final List b = (List) _symbol_b.value;
					 return new Opt(b);
			}
			case 559: // import_declaration = single_static_import_declaration.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final ImportDecl s = (ImportDecl) _symbol_s.value;
					 return s;
			}
			case 560: // import_declaration = static_import_on_demand_declaration.t
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final ImportDecl t = (ImportDecl) _symbol_t.value;
					 return t;
			}
			case 561: // single_static_import_declaration = IMPORT.IMPORT STATIC.STATIC name.n DOT.DOT IDENTIFIER.id SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol STATIC = _symbols[offset + 2];
					final Symbol _symbol_n = _symbols[offset + 3];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol id = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new SingleStaticImportDecl(n, ((String)id.value));
			}
			case 562: // static_import_on_demand_declaration = IMPORT.IMPORT STATIC.STATIC name.n DOT.DOT MULT.MULT SEMICOLON.SEMICOLON
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol STATIC = _symbols[offset + 2];
					final Symbol _symbol_n = _symbols[offset + 3];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 4];
					final Symbol MULT = _symbols[offset + 5];
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new StaticImportOnDemandDecl(n);
			}
			case 563: // formal_parameter = type.t ELLIPSIS.ELLIPSIS variable_declarator_id.v
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Access t = (Access) _symbol_t.value;
					final Symbol ELLIPSIS = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return new VariableArityParameterDeclaration(new Modifiers(new List()), t, v.getID(), v.getEmptyBracketList());
			}
			case 564: // formal_parameter = modifiers.m type.t ELLIPSIS.ELLIPSIS variable_declarator_id.v
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Modifiers m = (Modifiers) _symbol_m.value;
					final Symbol _symbol_t = _symbols[offset + 2];
					final Access t = (Access) _symbol_t.value;
					final Symbol ELLIPSIS = _symbols[offset + 3];
					final Symbol _symbol_v = _symbols[offset + 4];
					final VariableDecl v = (VariableDecl) _symbol_v.value;
					 return new VariableArityParameterDeclaration(
                                                                   m,
                                                                   t,
                                                                   v.getID(),
                                                                   v.getEmptyBracketList()
                                                                 );
			}
			case 565: // primary_no_new_array = literal.l
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final Expr l = (Expr) _symbol_l.value;
					 return l;
			}
			case 566: // primary_no_new_array = primitive_type.n DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.qualifiesAccess(c);
			}
			case 567: // primary_no_new_array = primitive_type.n dims.d DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 ArrayTypeAccess a = new ArrayTypeAccess(n, d.getNumChild());
                                                   a.setStart(n.getStart());
                                                   a.setEnd(d.getEnd());
                                                   return a.qualifiesAccess(c);
			}
			case 568: // primary_no_new_array = name.n DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 return n.qualifiesAccess(c);
			}
			case 569: // primary_no_new_array = name.n dims.d DOT.DOT class_literal.c
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol _symbol_d = _symbols[offset + 2];
					final List d = (List) _symbol_d.value;
					final Symbol DOT = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 ArrayTypeAccess a = new ArrayTypeAccess(n, d.getNumChild());
                                                  a.setStart(n.getStart());
                                                  a.setEnd(d.getEnd());
                                                  return a.qualifiesAccess(c);
			}
			case 570: // primary_no_new_array = VOID.VOID DOT.DOT class_literal.c
			{
					final Symbol VOID = _symbols[offset + 1];
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ClassAccess c = (ClassAccess) _symbol_c.value;
					 PrimitiveTypeAccess v = new PrimitiveTypeAccess("void");
                                                  v.setStart(VOID.getStart());
                                                  v.setEnd(VOID.getEnd());
                                                  return v.qualifiesAccess(c);
			}
			case 571: // primary_no_new_array = THIS.THIS
			{
					final Symbol THIS = _symbols[offset + 1];
					 return new ThisAccess("this");
			}
			case 572: // primary_no_new_array = name.n DOT.DOT THIS.THIS
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol THIS = _symbols[offset + 3];
					 ThisAccess t = new ThisAccess("this");
                                                  t.setStart(THIS.getStart()); t.setEnd(THIS.getEnd());
                                                  return n.qualifiesAccess(t);
			}
			case 573: // primary_no_new_array = LPAREN.LPAREN expression_nn.e RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new ParExpr(e);
			}
			case 574: // primary_no_new_array = LPAREN.LPAREN name.n RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_n = _symbols[offset + 2];
					final Access n = (Access) _symbol_n.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new ParExpr(n);
			}
			case 575: // primary_no_new_array = class_instance_creation_expression.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 576: // primary_no_new_array = field_access.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Access f = (Access) _symbol_f.value;
					 return f;
			}
			case 577: // primary_no_new_array = method_invocation.m
			{
					final Symbol _symbol_m = _symbols[offset + 1];
					final Access m = (Access) _symbol_m.value;
					 return m;
			}
			case 578: // primary_no_new_array = array_access.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Access a = (Access) _symbol_a.value;
					 return a;
			}
			case 579: // postfix_expression_nn = primary.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final Expr p = (Expr) _symbol_p.value;
					 return p;
			}
			case 580: // postfix_expression_nn = postincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 581: // postfix_expression_nn = postdecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 582: // unary_expression_nn = preincrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 583: // unary_expression_nn = predecrement_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 584: // unary_expression_nn = PLUS.PLUS unary_expression.e
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new PlusExpr(e);
			}
			case 585: // unary_expression_nn = MINUS.MINUS unary_expression.e
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new MinusExpr(e);
			}
			case 586: // unary_expression_nn = unary_expression_not_plus_minus_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 587: // unary_expression_not_plus_minus_nn = postfix_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 588: // unary_expression_not_plus_minus_nn = COMP.COMP unary_expression.e
			{
					final Symbol COMP = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new BitNotExpr(e);
			}
			case 589: // unary_expression_not_plus_minus_nn = NOT.NOT unary_expression.e
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new LogNotExpr(e);
			}
			case 590: // unary_expression_not_plus_minus_nn = cast_expression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 591: // multiplicative_expression_nn = unary_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 592: // multiplicative_expression_nn = name.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 593: // multiplicative_expression_nn = multiplicative_expression_nn.e1 MULT.MULT unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new MulExpr(e1, e2);
			}
			case 594: // multiplicative_expression_nn = name.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 595: // multiplicative_expression_nn = multiplicative_expression_nn.e1 DIV.DIV unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new DivExpr(e1, e2);
			}
			case 596: // multiplicative_expression_nn = name.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 597: // multiplicative_expression_nn = multiplicative_expression_nn.e1 MOD.MOD unary_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MOD = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ModExpr(e1, e2);
			}
			case 598: // additive_expression_nn = multiplicative_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 599: // additive_expression_nn = name.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 600: // additive_expression_nn = additive_expression_nn.e1 PLUS.PLUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AddExpr(e1, e2);
			}
			case 601: // additive_expression_nn = name.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 602: // additive_expression_nn = additive_expression_nn.e1 MINUS.MINUS multiplicative_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new SubExpr(e1, e2);
			}
			case 603: // shift_expression_nn = additive_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 604: // shift_expression_nn = name.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 605: // shift_expression_nn = shift_expression_nn.e1 LSHIFT.LSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LShiftExpr(e1, e2);
			}
			case 606: // shift_expression_nn = name.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 607: // shift_expression_nn = shift_expression_nn.e1 RSHIFT.RSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol RSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new RShiftExpr(e1, e2);
			}
			case 608: // shift_expression_nn = name.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 609: // shift_expression_nn = shift_expression_nn.e1 URSHIFT.URSHIFT additive_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol URSHIFT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new URShiftExpr(e1, e2);
			}
			case 610: // relational_expression_nn = shift_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 611: // relational_expression_nn = name.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 612: // relational_expression_nn = shift_expression_nn.e1 LT.LT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LTExpr(e1, e2);
			}
			case 613: // relational_expression_nn = name.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 614: // relational_expression_nn = shift_expression_nn.e1 GT.GT shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GTExpr(e1, e2);
			}
			case 615: // relational_expression_nn = name.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 616: // relational_expression_nn = relational_expression_nn.e1 LTEQ.LTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol LTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new LEExpr(e1, e2);
			}
			case 617: // relational_expression_nn = name.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 618: // relational_expression_nn = relational_expression_nn.e1 GTEQ.GTEQ shift_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol GTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new GEExpr(e1, e2);
			}
			case 619: // relational_expression_nn = name.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Access e = (Access) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 620: // relational_expression_nn = relational_expression_nn.e INSTANCEOF.INSTANCEOF reference_type.t
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol INSTANCEOF = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final Access t = (Access) _symbol_t.value;
					 return new InstanceOfExpr(e, t);
			}
			case 621: // equality_expression_nn = relational_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 622: // equality_expression_nn = name.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 623: // equality_expression_nn = equality_expression_nn.e1 EQEQ.EQEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol EQEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new EQExpr(e1, e2);
			}
			case 624: // equality_expression_nn = name.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 625: // equality_expression_nn = equality_expression_nn.e1 NOTEQ.NOTEQ relational_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol NOTEQ = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new NEExpr(e1, e2);
			}
			case 626: // and_expression_nn = equality_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 627: // and_expression_nn = name.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 628: // and_expression_nn = and_expression_nn.e1 AND.AND equality_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndBitwiseExpr(e1, e2);
			}
			case 629: // exclusive_or_expression_nn = and_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 630: // exclusive_or_expression_nn = name.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 631: // exclusive_or_expression_nn = exclusive_or_expression_nn.e1 XOR.XOR and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol XOR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new XorBitwiseExpr(e1, e2);
			}
			case 632: // inclusive_or_expression_nn = exclusive_or_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 633: // inclusive_or_expression_nn = name.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 634: // inclusive_or_expression_nn = inclusive_or_expression_nn.e1 OR.OR exclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrBitwiseExpr(e1, e2);
			}
			case 635: // conditional_and_expression_nn = inclusive_or_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 636: // conditional_and_expression_nn = name.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 637: // conditional_and_expression_nn = conditional_and_expression_nn.e1 ANDAND.ANDAND inclusive_or_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol ANDAND = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new AndLogicalExpr(e1, e2);
			}
			case 638: // conditional_or_expression_nn = conditional_and_expression_nn.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 639: // conditional_or_expression_nn = name.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Access e1 = (Access) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 640: // conditional_or_expression_nn = conditional_or_expression_nn.e1 OROR.OROR conditional_and_expression.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol OROR = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new OrLogicalExpr(e1, e2);
			}
			case 641: // conditional_expression_nn = conditional_or_expression_nn.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 642: // conditional_expression_nn = name.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Access c = (Access) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 643: // conditional_expression_nn = conditional_or_expression_nn.c QUESTION.QUESTION expression.e1 COLON.COLON conditional_expression.e2
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					final Symbol QUESTION = _symbols[offset + 2];
					final Symbol _symbol_e1 = _symbols[offset + 3];
					final Expr e1 = (Expr) _symbol_e1.value;
					final Symbol COLON = _symbols[offset + 4];
					final Symbol _symbol_e2 = _symbols[offset + 5];
					final Expr e2 = (Expr) _symbol_e2.value;
					 return new ConditionalExpr(c, e1, e2);
			}
			case 644: // assignment_expression_nn = conditional_expression_nn.c
			{
					final Symbol _symbol_c = _symbols[offset + 1];
					final Expr c = (Expr) _symbol_c.value;
					 return c;
			}
			case 645: // assignment_expression_nn = assignment.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 388: // annotation_type_element_declaration = constant_declaration.constant_declaration
			case 397: // modifier = annotation.annotation
			case 398: // annotation = normal_annotation.normal_annotation
			case 399: // annotation = marker_annotation.marker_annotation
			case 400: // annotation = single_element_annotation.single_element_annotation
			case 646: // expression_nn = assignment_expression_nn.assignment_expression_nn
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
