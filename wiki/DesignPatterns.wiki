#summary This is a listing of design patterns MorphJ allows that produce interesting effects.

*The Removal Pattern*
This pattern creates a class parameterized on a class X that possesses all members of X matching a primary pattern without any matching a secondary pattern based upon the same variables.  By separating out the patterns into two different morphed classes, the programmer creates a boundary that allows MorphJ's unification of patterns to avoid collisions.

{{{
class AllGetters<class T> {
	T instance;

	public AllGetters ( T t ) { instance = t; }

	<R,A*,E*>[m] for(public R get_#m(A) throws E : T.methods)
	public R get_#m(A args) {
		return instance.get_#m(args);
	}
}

public class AntiGetter<class T> {
	T instance;

	public AntiGetter ( T t ) { instance = t; }

	<R,A*,E*>[m] for(public R m(A) throws E : T.methods; 
			 no R m(A) throws E : AllGetters<T>.methods)
	public R m(A args) {
		 return instance.m(args);
	}
	/*
	public static void main(String argv[]) {
	    AntiGetter<Foo> baz = new AntiGetter<Foo>(new Foo());
	    System.out.println(baz.givefour());
	    //This following line should cause compilation to fail if not commented out.
	    //System.out.println(baz.get_bar());
	}
	*/
}
}}}

***The Modifier Pattern*** This pattern simply reproduces a class with a new modifier added to each public method.  As seen in the following example, this can allow the addition of useful behavior to classes, including forwards-compatibility with future additions to the Java language.

{{{
class Synchronized<class T> extends T {
    <R1,A1*,E1*>[m1] for (!private R1 m1 (A1) throws E1 : T.methods ; no final R1 m1(A1) throws E1 : T.methods)
	synchronized public R1 m1(A1 args) throws E1 {
		return super.m1(args);
	    }
    
    <A2*,E2*>[m2] for (!private void m2 (A2) throws E2 : T.methods ; no final void m2(A2) throws E2 : T.methods)
	 synchronized public void m2(A2 args) throws E2 {
		 super.m2(args);
	   }
}
}}}