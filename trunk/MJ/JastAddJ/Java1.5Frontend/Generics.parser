ClassDecl class_declaration =
		modifiers.m CLASS IDENTIFIER.id type_parameters.p super_opt.s interfaces_opt.i class_body.b 
		{:  return new GenericClassDecl(m, id, s, i, b, p, new List());  :}
	|	            CLASS IDENTIFIER.id type_parameters.p super_opt.s interfaces_opt.i class_body.b 
		{:  return new GenericClassDecl(new Modifiers(new List()), id, s, i, b, p, new List());  :}
	;

Opt super_opt =
  {: return new Opt(); :}
  | super.s {: return s; :}
  ;

List interfaces_opt =
    {: return new List(); :}
  | interfaces.i {: return i; :}
  ;

List extends_interfaces_opt =
                       {: return new List(); :}
  | extends_interfaces {: return extends_interfaces; :}
  ;
  
InterfaceDecl interface_declaration =
		modifiers.m INTERFACE IDENTIFIER.id type_parameters.p extends_interfaces_opt.i interface_body.b 
		{:  return new GenericInterfaceDecl(m, id, i, b, p, new List());  :}
	|             INTERFACE IDENTIFIER.id type_parameters.p extends_interfaces_opt.i interface_body.b 
		{:  return new GenericInterfaceDecl(new Modifiers(new List()), id, i, b, p, new List());  :}
	;

Access class_or_interface_type =
		name.t LT type_argument_list_1.l {:  return new ParTypeAccess(t, l);  :}
  | class_or_interface_type.t DOT IDENTIFIER.id {: return t.qualifiesAccess(new ParseName(id)); :}
  | class_or_interface_type.t DOT IDENTIFIER.id LT type_argument_list_1.l 
    {: return new ParTypeAccess(t.qualifiesAccess(new ParseName(id)), l); :}
	;
Access array_type =
    	name.t LT type_argument_list_1.l DOT name.n dims.d 
    	{:  return new ArrayTypeAccess(new ParTypeAccess(t, l).qualifiesAccess(n), d.getNumChild());  :}
	|	name.t LT type_argument_list_1.l dims.d 
		{:  return new ArrayTypeAccess(new ParTypeAccess(t, l), d.getNumChild());  :}
	;

List type_arguments =
		LT type_argument_list_1.l {:  return l;  :}
	;
      
Access wildcard =
		QUESTION                             {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type.t    {: return new WildcardExtends(t); :}
    |	QUESTION SUPER reference_type.t    {: return new WildcardSuper(t); :}
    ;
   
Access wildcard_1 =
		QUESTION GT                          {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_1.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_1.t    {: return new WildcardSuper(t); :}
	;
	
Access wildcard_2 =
		QUESTION RSHIFT                      {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_2.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_2.t    {: return new WildcardSuper(t); :}
	;
	
Access wildcard_3 =
		QUESTION URSHIFT                     {: return new Wildcard(); :}
	|	QUESTION EXTENDS reference_type_3.t  {: return new WildcardExtends(t); :}
	|	QUESTION SUPER reference_type_3.t    {: return new WildcardSuper(t); :}
	;

Opt subclass_body_opt =
    {: return new Opt(); :}
  | subclass_body {: return subclass_body; :}
  ;

Expr class_instance_creation_expression =
	 	NEW type_arguments.a class_or_interface_type.t LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
		{:  return new ParClassInstanceExpr(t, l, b, a); :}
    /*
	|	primary.n DOT NEW IDENTIFIER.id type_arguments.a LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
        {:  return new NestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(id), a), l, b ); :}	
        */
	|	primary.n DOT NEW type_arguments.ca IDENTIFIER.id LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return n.qualifiesAccess(new ParClassInstanceExpr(new ParseName(id), l, b, ca)); :}
    /*
	|	primary.n DOT NEW type_arguments.ca IDENTIFIER.id type_arguments.ta LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(id), ta), l, b, ca); :}
	|	name.n DOT NEW IDENTIFIER.id type_arguments.a LPAREN argument_list_opt.l RPAREN subclass_body_opt.b
		{:  return new NestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(id), a), l, b);  :}
	|	name.n DOT NEW type_arguments.ca IDENTIFIER.id LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParseName(id), l, b, ca);  :}
	|	name.n DOT NEW type_arguments.ca IDENTIFIER.id type_arguments.ta LPAREN argument_list_opt.l RPAREN class_body_opt.b
		{:  return new ParNestedClassInstanceExpr(n, new ParTypeAccess(new ParseName(id), ta), l, b, ca);  :}
    */
	;

List type_argument_list =
		type_argument.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument.a {:  return l.add(a);  :}
	;
	
List type_argument_list_1 =
		type_argument_1.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_1.a {:  return l.add(a);  :}
	;
	
List type_argument_list_2 =
		type_argument_2.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_2.a {:  return l.add(a);  :}
	;
	
List type_argument_list_3 =
		type_argument_3.a {:  return new List().add(a);  :}
	|	type_argument_list.l COMMA type_argument_3.a {:  return l.add(a);  :}
	;
	
Access type_argument =
		reference_type.t {:  return t;  :}
	|	wildcard.w {: return w; :}
	;
	
Access type_argument_1 =
		reference_type_1.t {:  return t;  :}
	|	wildcard_1.w {: return w; :}
	;
	
Access type_argument_2 =
		reference_type_2.t {:  return t;  :}
	|	wildcard_2.w {: return w; :}
	;
	
Access type_argument_3 =
		reference_type_3.t {:  return t;  :}
	|	wildcard_3.w {: return w; :}
	;
  
Access reference_type_1 =
		reference_type.t GT {:  return t;  :}
	|	name.t LT type_argument_list_2.l {:  return new ParTypeAccess(t, l);  :}
	;
	
Access reference_type_2 =
		reference_type.t RSHIFT {:  return t;  :}
	|	name.t LT type_argument_list_3.l {:  return new ParTypeAccess(t, l);  :}
	;
	
Access reference_type_3 =
		reference_type.t URSHIFT {:  return t;  :}
	;
Expr cast_expression =
		LPAREN name.n LT type_argument_list_1.a RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ParTypeAccess(n, a), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a dims.d RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ArrayTypeAccess(new ParTypeAccess(n, a), d.getNumChild()), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a DOT class_or_interface_type.t RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ParTypeAccess(n, a).qualifiesAccess(t), e);  :}
	|	LPAREN name.n LT type_argument_list_1.a DOT class_or_interface_type.t dims.d RPAREN unary_expression_not_plus_minus.e 
		{:  return new CastExpr(new ArrayTypeAccess(new ParTypeAccess(n, a).qualifiesAccess(t), d.getNumChild()), e);  :}
  ;
List type_parameters =
		LT type_parameter_list_1.l {:  return l;  :}
	;
	
List type_parameter_list =
		type_parameter_list.l COMMA type_parameter.p {:  return l.add(p);  :}
	|	type_parameter.p {:  return new List().add(p);  :}
	;
	
List type_parameter_list_1 =
		type_parameter_1.p {:  return new List().add(p);  :}
	|	type_parameter_list.l COMMA type_parameter_1.p {:  return l.add(p);  :}
	;
	
TypeVariable type_parameter =
		IDENTIFIER.v              {:  return new TypeVariable(new Modifiers(), v, new List(), new List());  :}
	|	IDENTIFIER.v type_bound.l {:  return new TypeVariable(new Modifiers(), v, new List(), l); :}
	;
	
TypeVariable type_parameter_1 =
		IDENTIFIER.v GT             {:  return new TypeVariable(new Modifiers(), v, new List(), new List());  :}
  |	IDENTIFIER.v type_bound_1.l {:  return new TypeVariable(new Modifiers(), v, new List(), l);  :}
	;
	
List type_bound =
		EXTENDS reference_type.t {:  return new List().add(t);  :}
	|	EXTENDS reference_type.t additional_bound_list.l {:  l.insertChild(t,0); return l; :}
    ;
    
List type_bound_1 =
		EXTENDS reference_type_1.t {:  return new List().add(t);  :}
	|	EXTENDS reference_type.t additional_bound_list_1.l {:  l.insertChild(t,0); return l; :}
    ;
    
List additional_bound_list =
		additional_bound.b additional_bound_list.l {:  l.insertChild(b,0); return l; :}
	|	additional_bound.b {:  return new List().add(b);  :}
    ;
    
List additional_bound_list_1 =
		additional_bound.b additional_bound_list_1.l {:  l.insertChild(b,0); return l; :}
	|	additional_bound_1.b {:  return new List().add(b);  :}
    ;
    
Access additional_bound =
		AND interface_type.t {:  return t;  :}
	;
	
Access additional_bound_1 =
		AND reference_type_1.t {:  return t;  :}
	;

Opt class_body_opt = {: return new Opt(); :}
    |  class_body.b {:  return new Opt(b);  :};

