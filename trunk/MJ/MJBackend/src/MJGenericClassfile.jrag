import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;
import java.io.*;

aspect MJGenerateClassfile {
    /*
    public void StaticForMethodDecl.generateMethod(DataOutputStream out, ConstantPool cp) throws IOException {
	super.generateMethod(out, cp);
    }
    */

    refine GenerateClassfile public void CompilationUnit.generateClassfile() {
	if(fromSource()) {
	    for(int i = 0; i < getNumTypeDecl(); i++) {
		getTypeDecl(i).generateClassfile();
		// move this to later, after expansion.
		// getTypeDecl(i).clear();
	    }
	}
    }

    public class ASMIteratorDeclAttribute extends org.objectweb.asm.Attribute {
	String signature = null;
	
	public ASMIteratorDeclAttribute(final String sig) {
	    super("IteratorDecl");
	    signature = sig;
	}

	public String signature() {
	    return signature;
	}

	public boolean isUnknown() { return false; }

	protected org.objectweb.asm.Attribute read(ClassReader cr, int off, int len,
				 char[] buf, int codeOff, Label[] labels) {
	    return new ASMIteratorDeclAttribute(cr.readUTF8(off, buf));
	}

	protected ByteVector write(ClassWriter cw, byte[] code, int len,
				   int maxStack, int maxLocals) {
	    return new ByteVector().putShort(cw.newUTF8(signature));
	}

    }

    public class ASMStaticForStmtsAttribute extends org.objectweb.asm.Attribute {

	Collection<StaticForStmtsAttribute> staticForStmts;
	
	class StaticForStmtsAttribute {
	    int begin_instr;
	    int end_instr;
	    String iterator_sig;

	    StaticForStmtsAttribute(int b, int e, String s) {
		begin_instr = b;
		end_instr = e;
		iterator_sig = s;
	    }
	}

	public ASMStaticForStmtsAttribute(Collection stmtAttrs) {
	    super("StaticForStmts");
	    staticForStmts = stmtAttrs;
	}

	public boolean isUnknown() { return false; }    

	public boolean isCodeAttribute() { return true; }

	protected org.objectweb.asm.Attribute read(ClassReader cr, int off, int len,
				 char[] buf, int codeOff, Label[] labels) {
	    // read number of entries.
	    Collection attrs = new ArrayList();

	    int entries=  cr.readUnsignedShort(off);
	    int w = off+2;
	    for( int i=0; i<entries; i++) { 
		// first read two numbers.
		int begin = cr.readUnsignedShort(w);;
		int end   = cr.readUnsignedShort(w+2);
		String iterator_sig = cr.readUTF8(w+4, new char[100]);

		w += 6;
		attrs.add(new StaticForStmtsAttribute(begin, end, iterator_sig));
	    }
	    return new ASMStaticForStmtsAttribute(attrs);
	}

	protected ByteVector write(ClassWriter cw, byte[] code, int len,
				   int maxStack, int maxLocals) {
	    ByteVector bv = new ByteVector();
	    bv.putShort(staticForStmts.size());
	    for ( Iterator<StaticForStmtsAttribute> i = staticForStmts.iterator();
		  i.hasNext(); ) {
		StaticForStmtsAttribute a = i.next();
		/*
		bv.putShort(a.begin_pos);
		bv.putShort(a.end_pos);
		bv.putUTF8(iteratorDecl);
		return bv;
		*/
	    }
	    return bv;
	}	
	
    }

    protected String ParClassDecl.sourceFile() {
	TypeDecl gt = genericDecl();

	String outDir = null;
	String destPath = gt.destinationPath();
	
	String filePath = expandedConstantPoolName().substring(0, expandedConstantPoolName().lastIndexOf(File.separator));

	if ( gt.compilationUnit().fromSource()) 
	    outDir = destPath + File.separator + filePath;
	else
	    outDir = destPath.substring(0, destPath.lastIndexOf(File.separator) + 1);

	String outFileName = null;

	// check whether outDir is writeable.
	File outDirFile = new File(outDir);
	if ( !outDirFile.canWrite()) {
	    // TODO: write into output dir + expandedConstantPoolName
	    if(Program.hasValueForOption("-d")) 
		outFileName = Program.getValueForOption("-d");
	    else outFileName = ".";
	    outFileName += expandedConstantPoolName();
	} else 
	    outFileName = outDirFile + File.separator + expandedName() + ".class";
	return outFileName;
    }

    public boolean TypeDecl.generated = false;
    refine GenerateClassfile public void ClassDecl.generateClassfile() {
	GenerateClassfile.ClassDecl.generateClassfile();
	generated = true;
    }
    refine GenerateClassfile public void InterfaceDecl.generateClassfile() {
	GenerateClassfile.InterfaceDecl.generateClassfile();
	generated = true;
    }

    public void ParClassDecl.generateClassfile() {
	if ( generated ) return;
	try {
	    TypeDecl gt = genericDecl();
	    
	    // TODO: should check whether gt already exists and has the proper
	    // timestamp: i.e. its timestamp is newer than the timestamp of its
	    // generic decl as well as all type arguments.

	    // Check that all type arguments can be accessed from this
	    // package. If not, 
	    // - increase visibility of type argument.
	    for ( int i=0; i<getNumArgument(); i++) {
		TypeDecl at = getArgument(i).type();
		if ( !at.accessibleFrom(this)) {
		    at.makeAccessibleFrom(this);

		    /*	
		    // if type is used as superclass, then must changed
		    // the visibility of constructors, transitively.
		    if ( hasSuperclass() && superclass() == at ) {
			for ( int j=0; j<getNumBodyDecl(); j++) {
			    if (getBodyDecl(j) instanceof ConstructorDecl)
				((ConstructorDecl) getBodyDecl(j)).makeSuperConstructorPublic((ClassDecl) at);
			}
		    }
		    */
		}
	    }

	    String gtSource = gt.compilationUnit().fromSource() ? 
		gt.destinationPath() + File.separator + gt.constantPoolName() + ".class"
		: gt.destinationPath();

	    String outFileName = sourceFile();

	    if(Program.verbose()) 
		System.out.println("Writing class file to " + outFileName);

	    File gtFile = new File(gtSource);
	    FileInputStream fis = new FileInputStream(gtFile);

	    // load class.
	    ClassReader cr = new ClassReader(fis);
	    ClassNode cn = new ClassNode();

	    cr.accept(cn, 
		      new org.objectweb.asm.Attribute[] { 
			  new ASMIteratorDeclAttribute(""),
			  new ASMStaticForStmtsAttribute(null) },
		      0);
	    
	    // transform ClassNode cn.
	    expand(cn);

	    // write class.
	    File outFile = new File(outFileName);
	    ClassWriter cw = new ClassWriter(0);
	    cn.accept(cw);
	    
	    FileOutputStream f = new FileOutputStream(outFileName);
	    DataOutputStream out = new DataOutputStream(new BufferedOutputStream(f));
	    
	    out.write(cw.toByteArray());

	    out.close();
	    fis.close();

	    generated = true;
	} catch (IOException e) {
	    e.printStackTrace();
	}
    }

    refine StaticImportsCodegen protected TypeDecl VarAccess.fieldQualifierType() {
	// from CreateBCode.
	TypeDecl typeDecl = hostType();
	if(hasPrevExpr())
	    typeDecl = prevExpr().type();

	while(typeDecl != null && !typeDecl.hasField(name()))
	    typeDecl = typeDecl.enclosingType();

	if ( typeDecl == null )				
	    return decl().hostType();

	if ( typeDecl.shouldErase())
	    return typeDecl.erasure();
	return typeDecl;
    }

    refine StaticImportsCodegen protected TypeDecl MethodAccess.methodQualifierType() {
	TypeDecl typeDecl = null;

	// from GenericsCodegen
	if(decl().isStatic())
	    typeDecl = decl().hostType();
	else {
	    // from CreateBCode MethodAccess.methodQualifierType()
	    if(hasPrevExpr())
		typeDecl = prevExpr().type();
	    else {
		typeDecl = hostType();
		while(typeDecl != null && !typeDecl.hasMethod(name()))
		    typeDecl = typeDecl.enclosingType();
	    }
	}

	// from StaticImportsCodegen
	if ( typeDecl == null ) 
	    typeDecl = decl().hostType();

	TypeDecl hostType = hostType();
	while ( hostType.isInnerType()) 
	    hostType = hostType.hostType();
	
	if ( typeDecl.shouldErase())
	    return typeDecl.erasure();

	return typeDecl;
    }

    syn lazy boolean TypeDecl.shouldErase() = true;
    eq GenericTypeDecl.shouldErase() = !needsExpansion();
    eq ParTypeDecl.shouldErase() {
	if ( !genericDecl().shouldErase() ) return false;
	for ( int i=0; i<getNumArgument(); i++) {
	    if ( !getArgument(i).type().shouldErase())
		return false;
	}
	return true;
    }
    eq TypeVariable.shouldErase() = enclosingType().shouldErase();

    refine GenericsCodegen public void ConstructorDeclSubstituted.emitInvokeConstructor(CodeGeneration gen) {
	if ( hostType().shouldErase())
	    erasedConstructor().emitInvokeConstructor(gen);
	else {
	    int size = -1;
	    for(int i = 0; i < getNumParameter(); i++)
		size -= getParameter(i).type().variableSize();
	    if(hostType().needsEnclosing())
		size--;
	    if(hostType().needsSuperEnclosing()) {
		size--;
	    }
	    for(Iterator iter = hostType().enclosingVariables().iterator(); iter.hasNext(); ) {
		Variable v = (Variable)iter.next();
		size -= v.type().variableSize();
	    }
	    String classname = hostType().expandedConstantPoolName();
	    String      desc = descName();
	    String      name = "<init>";
	    int index = gen.constantPool().addMethodref(classname, name, desc);
	    gen.emit(Bytecode.INVOKESPECIAL, size).add2(index);
	}
    }

    
}

aspect FixJastadd {
    // add signature attribute to constructors.
    refine AnnotationsCodegen eq ConstructorDecl.attributes() {
	//	Collection c = AnnotationsCodegen.ConstructorDecl.attributes();
	// from AnnotationsCodegen
	// change CodeAttribute -> MJCodeAttribute
	ArrayList l = new ArrayList();
	l.add(new MJCodeAttribute(bytecodes(hostType().constantPool()), null));
	l.add(new ExceptionsAttribute(bytecodes(hostType().constantPool()), this));
	if(getModifiers().isSynthetic())
	    l.add(new SyntheticAttribute(hostType().constantPool()));
	
	if (needsSignatureAttribute())
	    l.add(new SignatureAttribute(hostType().constantPool(),
					 constructorTypeSignature()));
	return l;
    }
    
    refine GenericsCodegen eq MethodDecl.attributes() {
	// from Attributes.jrag
	ArrayList l = new ArrayList();
	l.add(new ExceptionsAttribute(bytecodes(hostType().constantPool()), this));
	if(isAbstract() || isNative()) return l;
	l.add(new MJCodeAttribute(bytecodes(hostType().constantPool()), this));
	if(getModifiers().isSynthetic())
	    l.add(new SyntheticAttribute(hostType().constantPool()));

	// from AnnotationsCodegen
	getModifiers().addRuntimeVisibleAnnotationsAttribute(l);
	getModifiers().addRuntimeInvisibleAnnotationsAttribute(l);
	addRuntimeVisibleParameterAnnotationsAttribute(l);
	addRuntimeInvisibleParameterAnnotationsAttribute(l);

	// from GenericsCodegen.
	if(needsSignatureAttribute())
	    l.add(new SignatureAttribute(hostType().constantPool(), methodTypeSignature()));
	
	return l;
    }

    refine Attributes eq TypeDecl.clinit_attributes() {
    ArrayList l = new ArrayList();
    l.add(new MJCodeAttribute(bytecodes(constantPool()), null));
    return l;
    }

    syn String ConstructorDecl.constructorTypeSignature() {
	StringBuffer buf = new StringBuffer();
	buf.append("(");
	for ( int i=0; i<getNumParameter(); i++) 
	    buf.append(getParameter(i).type().classTypeSignature());
	buf.append(")");
	buf.append(lookupType(PRIMITIVE_PACKAGE_NAME, "void").classTypeSignature());
	for(int i = 0; i < getNumException(); i++)
	    buf.append("^" + getException(i).type().classTypeSignature());
	return buf.toString();
    }


    refine GenericsCodegen eq TypeVariable.typeDescriptor() {
	if ( this.hostType().needsExpansion())
	    return this.classTypeSignature();
    	return erasure().typeDescriptor();  
    }
    eq PatternTypeVariable.typeDescriptor() = classTypeSignature();
    eq PatternTypeVariable.constantPoolName() = classTypeSignature();
    eq VectorTypeVariable.classTypeSignature() = "T" + name() + "*;";
}
