import org.objectweb.asm.*;
import org.objectweb.asm.tree.*;
import java.io.*;

aspect MJGenerateClassfile {
    /*
    public void StaticForMethodDecl.generateMethod(DataOutputStream out, ConstantPool cp) throws IOException {
	super.generateMethod(out, cp);
    }
    */

    refine GenerateClassfile public void CompilationUnit.generateClassfile() {
	if(fromSource()) {
	    for(int i = 0; i < getNumTypeDecl(); i++) {
		getTypeDecl(i).generateClassfile();
		// move this to later, after expansion.
		// getTypeDecl(i).clear();
	    }
	}
    }

    public class ASMIteratorDeclAttribute extends org.objectweb.asm.Attribute {
	String signature = null;
	
	public ASMIteratorDeclAttribute(final String sig) {
	    super("IteratorDecl");
	    signature = sig;
	}

	public String signature() {
	    return signature;
	}

	public boolean isUnknown() { return false; }

	protected org.objectweb.asm.Attribute read(ClassReader cr, int off, int len,
				 char[] buf, int codeOff, Label[] labels) {
	    return new ASMIteratorDeclAttribute(cr.readUTF8(off, buf));
	}

	protected ByteVector write(ClassWriter cw, byte[] code, int len,
				   int maxStack, int maxLocals) {
	    return new ByteVector().putShort(cw.newUTF8(signature));
	}

    }

    protected String ParClassDecl.sourceFile() {
	TypeDecl gt = genericDecl();
	String outFileName = gt.destinationPath() + File.separator + expandedConstantPoolName() + ".class";
	return outFileName;
    }

    boolean ParClassDecl.generated = false;
    public void ParClassDecl.generateClassfile() {
	if ( generated ) return;
	try {
	    TypeDecl gt = genericDecl();
	    
	    // TODO: should check whether gt already exists and has the proper
	    // timestamp: i.e. its timestamp is newer than the timestamp of its
	    // generic decl as well as all type arguments.
	    String gtSource = gt.destinationPath() + File.separator + gt.constantPoolName() + ".class";
	    String outFileName = sourceFile();

	    if(Program.verbose()) 
		System.out.println("Writing class file to " + outFileName);

	    File gtFile = new File(gtSource);
	    FileInputStream fis = new FileInputStream(gtFile);

	    // load class.
	    ClassReader cr = new ClassReader(fis);
	    ClassNode cn = new ClassNode();

	    cr.accept(cn, 
		      new org.objectweb.asm.Attribute[] { new ASMIteratorDeclAttribute("") }, 
		      0);
	    
	    // transform ClassNode cn.
	    expand(cn);

	    // write class.
	    File outFile = new File(outFileName);
	    ClassWriter cw = new ClassWriter(0);
	    cn.accept(cw);
	    
	    FileOutputStream f = new FileOutputStream(outFileName);
	    DataOutputStream out = new DataOutputStream(new BufferedOutputStream(f));
	    
	    out.write(cw.toByteArray());
	    out.close();

	    generated = true;
	} catch (IOException e) {
	    e.printStackTrace();
	}
    }

    refine StaticImportsCodegen protected TypeDecl MethodAccess.methodQualifierType() {
	TypeDecl typeDecl = null;

	// from GenericsCodegen
	if(decl().isStatic())
	    typeDecl = decl().hostType();
	else {
	    // from CreateBCode MethodAccess.methodQualifierType()
	    if(hasPrevExpr())
		typeDecl = prevExpr().type();
	    else {
		typeDecl = hostType();
		while(typeDecl != null && !typeDecl.hasMethod(name()))
		    typeDecl = typeDecl.enclosingType();
	    }
	}

	// from StaticImportsCodegen
	if ( typeDecl == null ) 
	    typeDecl = decl().hostType();

	TypeDecl hostType = hostType();
	while ( hostType.isInnerType()) 
	    hostType = hostType.hostType();
	
	if ( typeDecl.shouldErase())
	    return typeDecl.erasure();

	return typeDecl;
    }

    syn lazy boolean TypeDecl.shouldErase() = true;
    eq GenericTypeDecl.shouldErase() = !needsExpansion();
    eq ParTypeDecl.shouldErase() {
	if ( !genericDecl().shouldErase() ) return false;
	for ( int i=0; i<getNumArgument(); i++) {
	    if ( !getArgument(i).type().shouldErase())
		return false;
	}
	return true;
    }
    eq TypeVariable.shouldErase() = enclosingType().shouldErase();

    refine GenericsCodegen public void ConstructorDeclSubstituted.emitInvokeConstructor(CodeGeneration gen) {
	if ( hostType().shouldErase())
	    erasedConstructor().emitInvokeConstructor(gen);
	else {
	    int size = -1;
	    for(int i = 0; i < getNumParameter(); i++)
		size -= getParameter(i).type().variableSize();
	    if(hostType().needsEnclosing())
		size--;
	    if(hostType().needsSuperEnclosing()) {
		size--;
	    }
	    for(Iterator iter = hostType().enclosingVariables().iterator(); iter.hasNext(); ) {
		Variable v = (Variable)iter.next();
		size -= v.type().variableSize();
	    }
	    String classname = hostType().expandedConstantPoolName();
	    String      desc = descName();
	    String      name = "<init>";
	    int index = gen.constantPool().addMethodref(classname, name, desc);
	    gen.emit(Bytecode.INVOKESPECIAL, size).add2(index);
	}
    }
}

aspect MJAttributes {
    eq StaticForMethodDecl.attributes() {
	Collection c = super.attributes();
	// add attribute about the iterator decl.
	c.add(new IteratorDeclAttribute(hostType().constantPool(), 
					getIteratorDecl().signature()));
	return c;
    }

    class IteratorDeclAttribute extends Attribute {
	public IteratorDeclAttribute(ConstantPool cp, String iteratorSig) {
	    super(cp, "IteratorDecl");
	    u2(cp.addUtf8(iteratorSig));
	}
    }
    
    syn String IteratorDecl.signature() {
	// <R;..>[m;..] (A)R;[m]T;methods; -(A)R;[m]T;methods;+(A)R[m]T;methods 
	StringBuffer buf = new StringBuffer();
	buf.append("<");
	for ( int i=0; i<getNumPatternTypeParameter(); i++) {
	    buf.append(getPatternTypeParameter(i).classTypeSignature());
	}  
	buf.append(">");
	buf.append("[");
	for ( int i=0; i<getNumPatternNameParameter(); i++) {
	    buf.append(getPatternNameParameter(i).getID() + ";");
	}
	buf.append("]");
	buf.append(getPattern().signature());
	for ( int i=0; i<getNumNestedPattern(); i++) {
	    buf.append(getNestedPattern(i).signature());
	}
	return buf.toString();
    }
    syn String Pattern.signature() { 
	throw new Error("signature() unsupported by " + getClass().getName());
    }
    syn String MethodPattern.signature() {
	PatternMethodDecl md = patternMethodDecl();
	StringBuffer buf = new StringBuffer(md.methodTypeSignature());
	// append method name.
	buf.append("[");
	buf.append(getID());
	buf.append("]");

	// append modifiers.
	buf.append("(");
	buf.append(md.getModifiers().signature());
	buf.append(")");

	// append base set signature.
	buf.append(getBaseSet().signature());
	return buf.toString();
    }
    syn String NestedMethodPattern.signature() {
	StringBuffer buf = new StringBuffer();
	if ( getIsPositive()) buf.append("+");
	else buf.append("-");
	buf.append(super.signature());
	return buf.toString();
    }
    syn String TrueNestedPattern.signature() { return ""; }

    syn String BaseSet.signature() {
	StringBuffer buf = new StringBuffer(getTypeAccess().type().classTypeSignature());
	buf.append(getRefElmt().signature());
	return buf.toString();
    }

    syn String RefElmt.signature() {
	return getElmtName() + ";";
    }

    syn String Modifiers.signature() {
	StringBuffer buf = new StringBuffer();
	for ( int i=0; i<getNumModifier(); i++) 
	    buf.append(getModifier(i).signature());
	return buf.toString();
    }
    syn String Modifier.signature() = getID() + ";";
    eq NegativeModifier.signature() = "-" + super.signature();
    eq NoModifier.signature() = "NOMOD";
}

aspect FixJastadd {
    // add signature attribute to constructors.
    refine AnnotationsCodegen eq ConstructorDecl.attributes() {
	Collection c = AnnotationsCodegen.ConstructorDecl.attributes();
	if (needsSignatureAttribute())
	    c.add(new SignatureAttribute(hostType().constantPool(),
					 constructorTypeSignature()));
	return c;
    }
    syn String ConstructorDecl.constructorTypeSignature() {
	StringBuffer buf = new StringBuffer();
	buf.append("(");
	for ( int i=0; i<getNumParameter(); i++) 
	    buf.append(getParameter(i).type().classTypeSignature());
	buf.append(")");
	buf.append(lookupType(PRIMITIVE_PACKAGE_NAME, "void").classTypeSignature());
	for(int i = 0; i < getNumException(); i++)
	    buf.append("^" + getException(i).type().classTypeSignature());
	return buf.toString();
    }


    refine GenericsCodegen eq TypeVariable.typeDescriptor() {
	if ( this.hostType().needsExpansion())
	    return this.classTypeSignature();
    	return erasure().typeDescriptor();  
    }
    eq PatternTypeVariable.typeDescriptor() = classTypeSignature();
    eq PatternTypeVariable.constantPoolName() = classTypeSignature();
    eq VectorTypeVariable.classTypeSignature() = "T" + name() + "*;";
}
