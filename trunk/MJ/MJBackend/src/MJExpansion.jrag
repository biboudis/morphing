aspect MJExpansion {

    protected void ParClassDecl.expand(ClassNode cn) {
	// change name
	cn.name = expandedConstantPoolName();

	// remove signature.
	cn.signature = null;
	// change source file.
	//	cn.sourceFile = sourceFile();

	// change superclass.
	if ( hasSuperclass())
	    cn.superName = superclass().expandedConstantPoolName();

	// change interface.
	java.util.List interfaces = new java.util.ArrayList();
	for ( int i=0; i<getNumImplements(); i++) 
	    interfaces.add(getImplements(i).type().expandedConstantPoolName());
	cn.interfaces = interfaces;

	// transform fields.
	expandFields(cn);

	// transform methods.
	expandMethods(cn);
    }

    // TODO: this may not be right... 
    protected MemberNode BodyDecl.transformMemberNode(MemberNode mn, ParClassDecl parClass) {
	throw new Error("transformMemberNode not implemented by " +
			getClass().getName());
    }
    protected MemberNode ConstructorDeclSubstituted.transformMemberNode(MemberNode mn, ParClassDecl parClass) {
	ParTypeDecl ht = (ParTypeDecl) hostType();
	GenericTypeDecl gtd = (GenericTypeDecl) ht.genericDecl();

	HashMap substitutions = new HashMap();
	// put into the map the parameterization from this
	for ( int i=0; i<gtd.getNumTypeParameter(); i++) {
	    substitutions.put(gtd.getTypeParameter(i),
			      ht.getArgument(i).type());
	}
	
	MethodNode newNode = TypeDecl.copyMethodNode((MethodNode)mn);

	// modify descriptor;
	newNode.desc = descName();

	// take away signature.
	newNode.signature = null; //descName();

	InsnTransformVisitor insnVisitor = new InsnTransformVisitor(new org.objectweb.asm.commons.EmptyVisitor(), parClass, this, substitutions);
	
	newNode.accept(insnVisitor);
	
	newNode.instructions = insnVisitor.instructions;
	
	// transform local variables.
	newNode.localVariables = insnVisitor.localVariables;

	newNode.tryCatchBlocks = insnVisitor.tryCatchBlocks;

	return newNode;	
    }

    protected MemberNode MethodDecl.transformMemberNode(MemberNode mn, ParClassDecl parClass) {
	MethodNode newNode = TypeDecl.copyMethodNode((MethodNode)mn);
	
	// see if we need to change name.
	newNode.name = getID();
	
	// modify descriptor;
	newNode.desc = descName();
	
	// modify signature.
	newNode.signature = null; //descName();
	
	// TODO: modify exceptions.
	
	// TODO:change instructions.
	InsnTransformVisitor insnVisitor = new InsnTransformVisitor(new org.objectweb.asm.commons.EmptyVisitor(), parClass, this, expansionSubstitutions);
	
	newNode.accept(insnVisitor);
	
	newNode.instructions = insnVisitor.instructions;
	newNode.localVariables = insnVisitor.localVariables;
	newNode.tryCatchBlocks = insnVisitor.tryCatchBlocks;
	
	// remove IteratorDecl attribute.
	if ( newNode.attrs != null ) {
	    for ( int j=0; j<newNode.attrs.size(); j++) {
		if ( ((org.objectweb.asm.Attribute)newNode.attrs.get(j)).type.equals("IteratorDecl"))
		    newNode.attrs.remove(j);
	    }
	}
	return newNode;
    }

    protected MemberNode FieldDeclaration.transformMemberNode(MemberNode mn, ParClassDecl parClass) {
	// TODO: take care of reflectively declared fields.
	
	FieldNode newNode = TypeDecl.copyFieldNode((FieldNode) mn);

	// change desc.
	newNode.desc = type().typeDescriptor();
	
	// take away signature.
	newNode.signature = null;
	
	return newNode;
    }

    protected void ParClassDecl.expandFields(ClassNode cn) {
	java.util.List fields = cn.fields;
	java.util.List newFields = new ArrayList();

	for ( Iterator fIt = fields.iterator(); fIt.hasNext(); ) {
	    FieldNode fn = (FieldNode) fIt.next();
	    FieldDeclaration fd = findField(fn);
	    
	    // TODO: take care of reflectively declared fields.
	    
	    FieldNode newNode = (FieldNode) fd.transformMemberNode(fn, this);
	    newFields.add(newNode);
	}

	cn.fields = newFields;
    }
    
    protected void ParClassDecl.expandMethods(ClassNode cn) {
	java.util.List methods = cn.methods;
	java.util.List newMethods = new ArrayList();

	for ( Iterator mIt = methods.iterator(); mIt.hasNext(); ) {
	    MethodNode mn = (MethodNode) mIt.next();
	    if ( reflectiveMemberNode(mn) ) {
		// find the corresponding method in gd.
		// we do this because gd's corresponding method already has
		// the reflective iteration info parsed with the appropriate
		// information.
		StaticForMethodDecl md = genericDecl().reflectiveMethod(mn);
		
		if ( md != null ) {
		    ParStaticForMethodDecl subMd = 
			(ParStaticForMethodDecl) md.p(this);
		    List expandedMethods = subMd.expandedMethods();

		    for ( int i=0; i<expandedMethods.getNumChild(); i++) {
			ExpandedMethodDecl expandedMd = 
			    (ExpandedMethodDecl) expandedMethods.getChild(i);

			MethodNode newNode = 
			    (MethodNode) expandedMd.transformMemberNode(mn, this);
			newMethods.add(newNode);
		    }
		} else {
		    // something is seriously wrong.
		    throw new Error("Cannot find the definition for " +
				    "reflectively declared method " +
				    mn.name);
		}
	    } else {
		MethodNode newMn = (MethodNode) findMethod(mn).transformMemberNode(mn, this);
		newMethods.add(newMn);
	    }
	}
	cn.methods = newMethods;
    }

    public BodyDecl TypeDecl.findMethod(MethodNode mn) {
	if ( mn.name.equals("<init>")) {
	    // check constructors.
	    for (Iterator cIt = constructors().iterator(); cIt.hasNext(); ) {
		ConstructorDecl cd = (ConstructorDecl) cIt.next();
		if ( cd.isSameMethod(mn)) return cd;
	    }
	} else {
	    for ( Iterator mIt = methodsIterator(); mIt.hasNext(); ) {
		MethodDecl md = (MethodDecl) mIt.next();
		if ( md.isSameMethod(mn)) return md;
	    }
	}
	return null;
    }
    public FieldDeclaration TypeDecl.findField(FieldNode fn) {
	for ( Iterator fIt = fields(fn.name).iterator(); fIt.hasNext(); ) {
	    FieldDeclaration f = (FieldDeclaration) fIt.next();
	    if ( f.getID().equals(fn.name))
		return f;
	}
	return null;
    }

    public boolean ConstructorDecl.isSameMethod(MethodNode mn) {
	return mn.name.equals("<init>")
	    && (mn.signature == null || 
		mn.signature.equals(constructorTypeSignature()));
    }
    public boolean ConstructorDeclSubstituted.isSameMethod(MethodNode mn) {
	return ((ConstructorDecl) getOriginal()).isSameMethod(mn);
    }
    public boolean MethodDecl.isSameMethod(MethodNode mn) {
	return mn.name.equals(getID()) &&
	    (mn.signature == null || 
	     mn.signature.equals(methodTypeSignature()));
    }
    public boolean MethodDeclSubstituted.isSameMethod(MethodNode mn) {
	return ((MethodDecl) getOriginal()).isSameMethod(mn);
    }

    public StaticForMethodDecl TypeDecl.reflectiveMethod(MethodNode mn) {
	Collection rmethods = reflectiveMethods();
	for ( Iterator rmIt = rmethods.iterator(); rmIt.hasNext(); ) {
	    StaticForMethodDecl md = (StaticForMethodDecl) rmIt.next();
	    if ( md.getIteratorDecl().signature().equals(iteratorDeclAttribute(mn)) && mn.name.equals(md.getID()) && 
		 mn.desc.equals(md.descName()) &&
		 mn.signature.equals( md.methodTypeSignature()))
		return md;
	}
	return null;
    }
    
    public static FieldNode TypeDecl.copyFieldNode(FieldNode fn) {
	return new FieldNode(fn.access,
			     fn.name,
			     fn.desc,
			     fn.signature,
			     fn.value);
    }

    public static MethodNode TypeDecl.copyMethodNode(MethodNode mn) {
	MethodNode newNode = new MethodNode();
	newNode.access = mn.access;
	newNode.name = mn.name;
	newNode.desc = mn.desc;
	newNode.signature = mn.signature;
	newNode.exceptions = mn.exceptions;
	newNode.visibleAnnotations = mn.visibleAnnotations;
	newNode.invisibleAnnotations = mn.invisibleAnnotations;
	newNode.attrs = mn.attrs;
	newNode.annotationDefault = mn.annotationDefault;
	newNode.visibleParameterAnnotations = mn.visibleParameterAnnotations;
	newNode.invisibleParameterAnnotations = mn.invisibleParameterAnnotations;
	newNode.instructions = mn.instructions;
	newNode.tryCatchBlocks = mn.tryCatchBlocks;
	newNode.localVariables = mn.localVariables;
	newNode.maxStack = mn.maxStack;
	newNode.maxLocals = mn.maxLocals;
	return newNode;
    }
    
    public String TypeDecl.iteratorDeclAttribute(MemberNode mn) {
	if ( mn.attrs != null ) {
	    for ( Iterator attrIt = mn.attrs.iterator(); attrIt.hasNext(); ) {
		org.objectweb.asm.Attribute a = (org.objectweb.asm.Attribute)attrIt.next();
		if ( a.type.equals("IteratorDecl"))
		    return ((ASMIteratorDeclAttribute) a).signature();
	    }
	}
	return "";
    }

    protected boolean TypeDecl.reflectiveMemberNode(MemberNode mn) {
	return !iteratorDeclAttribute(mn).equals("");
    }

    refine GenericsCodegen eq ParClassDecl.constantPoolName() =
	shouldErase() ? GenericsCodegen.ParClassDecl.constantPoolName() 
	: expandedConstantPoolName();
    refine GenericsCodegen eq ParInterfaceDecl.constantPoolName() =
	shouldErase() ? GenericsCodegen.ParInterfaceDecl.constantPoolName() 
	: expandedConstantPoolName();
    refine GenericsCodegen eq TypeVariable.constantPoolName() =
	shouldErase() ? GenericsCodegen.TypeVariable.constantPoolName() 
	: expandedConstantPoolName();

    syn lazy String TypeDecl.expandedConstantPoolName () = constantPoolName();
    eq ParTypeDecl.expandedConstantPoolName () {
    	String cpName = genericDecl().constantPoolName();
	int lastSlash = 	cpName.lastIndexOf('/');
	
	StringBuffer buf = new StringBuffer(cpName.substring(0,lastSlash+1) + 
					    expandedName());
	return buf.toString();
    }
    eq RawClassDecl.expandedConstantPoolName() = genericDecl().expandedConstantPoolName();
    eq RawInterfaceDecl.expandedConstantPoolName() = genericDecl().expandedConstantPoolName();
    eq TypeVariable.expandedConstantPoolName() = getID();

    refine GenericsCodegen eq ParClassDecl.typeDescriptor() =
	shouldErase() ? GenericsCodegen.ParClassDecl.typeDescriptor()
	: expandedTypeDescriptor();
    refine GenericsCodegen eq ParInterfaceDecl.typeDescriptor() = 
	shouldErase() ? GenericsCodegen.ParInterfaceDecl.typeDescriptor()
	: expandedTypeDescriptor();
    
    syn lazy String TypeDecl.expandedTypeDescriptor() = typeDescriptor();
    eq ParTypeDecl.expandedTypeDescriptor() {
    	String td = genericDecl().typeDescriptor();
	int lastSlash = td.lastIndexOf('/');
	
	StringBuffer buf = new StringBuffer(td.substring(0,lastSlash+1) + 
					    expandedName() + ";");
	return buf.toString();	
    }
    eq RawClassDecl.expandedTypeDescriptor() = genericDecl().expandedTypeDescriptor();
    eq RawInterfaceDecl.expandedTypeDescriptor() = genericDecl().expandedTypeDescriptor();
    eq TypeVariable.expandedTypeDescriptor() = getID();

    syn lazy String TypeDecl.expandedName() = name();
    eq ParTypeDecl.expandedName() {
	StringBuffer buf = new StringBuffer("$$");
	buf.append(name());
	// $$L for <
	buf.append("$$L");
	for ( int i=0; i<getNumArgument(); i++ ) {
	    TypeDecl argType = getArgument(i).type();
	    buf.append(TypeDecl.convertToExpandedName(argType.expandedConstantPoolName()));
	    buf.append("$$C");
	}	
	// $$R for >
	buf.append("$$R");
	return buf.toString();
    }
    eq RawClassDecl.expandedName() {
	throw new Error("Classes with reflective declarations cannot be " +
			"raw types.");
    }
    eq RawInterfaceDecl.expandedName() {
	throw new Error("Interfaces with reflective declarations cannot be " +
			"raw types.");
    }
    // $$S for /
    protected static String TypeDecl.convertToExpandedName ( String n ) {
	return n.replace("/", "$$S");
    }

    // TODO: not finished.
    syn lazy TypeDecl BodyDecl.parseConstantPoolName(String n) {
	// Package and Type Name
	StringBuffer packageName = new StringBuffer();
	
	int i, last = 0;
	while( (i = n.indexOf("/", last)) > 0 ) {
	    if ( last > 0 )
		packageName.append(".");
	    packageName.append(n.substring(last, i));
	    last = i+1;
	}

	// what's left is the type name.
	String typeName = n.substring(last);

	TypeDecl t = null;

	StringBuffer tnBuf = new StringBuffer(typeName);
	Access a = Signatures.eatTypeName(packageName.toString(), tnBuf);
	while ( tnBuf.length() > 0 )
	  a = a.qualifiesAccess(Signatures.eatTypeName("", tnBuf));
	t = retrieveType(a);
	
	/*
	// if it begins with $$, then it is an expanded constant pool name.
	if ( typeName.startsWith("$$")) {
	    // look for the next $$L...$$R
	    int lindex = typeName.indexOf("$$L");
	    int rindex = typeName.lastIndexOf("$$R");

	    // lookup the generic type.
	    String genericName = typeName.substring(2, lindex);
	    TypeAccess ga = new TypeAccess(packageName.toString(), genericName);
	    GenericTypeDecl genericType = (GenericTypeDecl) ((ParTypeDecl) retrieveType(ga)).genericDecl();

	    String paramsString = typeName.substring(lindex+3, rindex-3);
	    // split up params.
	    String[] params = paramsString.split("\\$\\$C");
	    java.util.ArrayList paramList = new java.util.ArrayList();
	    for ( int j=0; j<params.length; j++) {
		// split params up by $$S
		String[] names = params[j].split("\\$\\$S");
		StringBuffer pPackageName = new StringBuffer();
		String pName = names[names.length-1];
		for ( int k=0; k<names.length-1; k++) {
		    if ( k > 0 ) pPackageName.append(".");
		    pPackageName.append(names[k]);
		}
		TypeAccess paramAccess = new TypeAccess(pPackageName.toString(), pName);
		paramList.add(retrieveType(paramAccess));
	    }

	    // lookup the parameterized type.
	    t = genericType.lookupParTypeDecl(paramList);
	} else {
	    TypeAccess ta = new TypeAccess(packageName.toString(), typeName);
	    t = retrieveType(ta);
	}
	*/

	return t;
    }
    eq ParStaticForMethodDecl.parseConstantPoolName(String n) = original.parseConstantPoolName(n);
    eq FieldDeclarationSubstituted.parseConstantPoolName(String n) = getOriginal().parseConstantPoolName(n);
    eq MethodDeclSubstituted.parseConstantPoolName(String n) = getOriginal().parseConstantPoolName(n);
    eq ExpandedMethodDecl.parseConstantPoolName(String n) = original.parseConstantPoolName(n);
    eq ConstructorDeclSubstituted.parseConstantPoolName(String n) = getOriginal().parseConstantPoolName(n);
    
    syn lazy TypeDecl BodyDecl.retrieveType(Access ta) {
	this.addChild(ta);
	TypeDecl t = ta.type();
	
	this.children[numChildren-1] = null;
	this.numChildren = numChildren-1;
	return t;
    }

    eq ConstructorDeclSubstituted.retrieveType(Access ta) = getOriginal().retrieveType(ta);
    eq MethodDeclSubstituted.retrieveType(Access ta) = getOriginal().retrieveType(ta);
    eq ExpandedMethodDecl.retrieveType(Access ta) = original.retrieveType(ta);
    eq FieldDeclarationSubstituted.retrieveType(Access ta) = getOriginal().retrieveType(ta);
    eq ParStaticForMethodDecl.retrieveType(Access ta) = original.retrieveType(ta);

    syn lazy boolean BodyDecl.isSubstitutedDecl() = false;
    eq FieldDeclarationSubstituted.isSubstitutedDecl() = true;
    eq MethodDeclSubstituted.isSubstitutedDecl() = true;
    eq ConstructorDeclSubstituted.isSubstitutedDecl() = true;

    
}
