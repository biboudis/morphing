aspect MJExpansion {

    protected void ParClassDecl.expand(ClassNode cn) {
	// change name
	cn.name = expandedConstantPoolName();

	// remove signature.
	cn.signature = null;
	// change source file.
	//	cn.sourceFile = sourceFile();

	// change superclass.
	if ( hasSuperclass())
	    cn.superName = superclass().expandedConstantPoolName();

	// change interface.
	java.util.List interfaces = new java.util.ArrayList();
	for ( int i=0; i<getNumImplements(); i++) 
	    interfaces.add(getImplements(i).type().expandedConstantPoolName());
	cn.interfaces = interfaces;

	// transform fields.
	expandFields(cn);

	// transform methods.
	expandMethods(cn);
    }

    // TODO: this may not be right... 
    protected MemberNode BodyDecl.transformMemberNode(MemberNode mn, ParClassDecl parClass) {
	throw new Error("transformMemberNode not implemented by " +
			getClass().getName());
    }
    protected MemberNode ConstructorDecl.transformMemberNode(MemberNode mn, ParClassDecl parClass) {
	MethodNode newNode = TypeDecl.copyMethodNode((MethodNode)mn);

	// modify descriptor;
	newNode.desc = descName();

	// take away signature.
	newNode.signature = null; //descName();

	InsnTransformVisitor insnVisitor = new InsnTransformVisitor(new org.objectweb.asm.commons.EmptyVisitor(), parClass, this, new HashMap());
	
	newNode.accept(insnVisitor);
	
	newNode.instructions = insnVisitor.instructions;
	newNode.localVariables = insnVisitor.localVariables;
	newNode.tryCatchBlocks = insnVisitor.tryCatchBlocks;

	return newNode;	
    }

    protected MemberNode MethodDecl.transformMemberNode(MemberNode mn, ParClassDecl parClass) {
	MethodNode newNode = TypeDecl.copyMethodNode((MethodNode)mn);
	
	// see if we need to change name.
	newNode.name = getID();
	
	// modify descriptor;
	newNode.desc = descName();
	
	// modify signature.
	newNode.signature = null; //descName();
	
	// TODO: modify exceptions.
	
	// TODO:change instructions.
	InsnTransformVisitor insnVisitor = new InsnTransformVisitor(new org.objectweb.asm.commons.EmptyVisitor(), parClass, this, expansionSubstitutions);
	
	newNode.accept(insnVisitor);
	
	newNode.instructions = insnVisitor.instructions;
	newNode.localVariables = insnVisitor.localVariables;
	newNode.tryCatchBlocks = insnVisitor.tryCatchBlocks;
	
	// remove IteratorDecl attribute.
	if ( newNode.attrs != null ) {
	    for ( int j=0; j<newNode.attrs.size(); j++) {
		if ( ((org.objectweb.asm.Attribute)newNode.attrs.get(j)).type.equals("IteratorDecl"))
		    newNode.attrs.remove(j);
	    }
	}
	return newNode;
    }

    protected MemberNode FieldDeclaration.transformMemberNode(MemberNode mn, ParClassDecl parClass) {
	// TODO: take care of reflectively declared fields.
	
	FieldNode newNode = TypeDecl.copyFieldNode((FieldNode) mn);

	// change desc.
	newNode.desc = type().typeDescriptor();
	
	// take away signature.
	newNode.signature = null;
	
	return newNode;
    }

    protected void ParClassDecl.expandFields(ClassNode cn) {
	java.util.List fields = cn.fields;
	java.util.List newFields = new ArrayList();

	for ( Iterator fIt = fields.iterator(); fIt.hasNext(); ) {
	    FieldNode fn = (FieldNode) fIt.next();
	    FieldDeclaration fd = findField(fn);
	    
	    // TODO: take care of reflectively declared fields.
	    
	    FieldNode newNode = (FieldNode) fd.transformMemberNode(fn, this);
	    newFields.add(newNode);
	}

	cn.fields = newFields;
    }
    
    protected void ParClassDecl.expandMethods(ClassNode cn) {
	java.util.List methods = cn.methods;
	java.util.List newMethods = new ArrayList();

	for ( Iterator mIt = methods.iterator(); mIt.hasNext(); ) {
	    MethodNode mn = (MethodNode) mIt.next();
	    if ( reflectiveMemberNode(mn) ) {
		// find the corresponding method in gd.
		// we do this because gd's corresponding method already has
		// the reflective iteration info parsed with the appropriate
		// information.
		StaticForMethodDecl md = genericDecl().reflectiveMethod(mn);
		
		if ( md != null ) {
		    ParStaticForMethodDecl subMd = 
			(ParStaticForMethodDecl) md.p(this);
		    List expandedMethods = subMd.expandedMethods();

		    for ( int i=0; i<expandedMethods.getNumChild(); i++) {
			ExpandedMethodDecl expandedMd = 
			    (ExpandedMethodDecl) expandedMethods.getChild(i);

			MethodNode newNode = 
			    (MethodNode) expandedMd.transformMemberNode(mn, this);
			newMethods.add(newNode);
		    }
		} else {
		    // something is seriously wrong.
		    throw new Error("Cannot find the definition for " +
				    "reflectively declared method " +
				    mn.name);
		}
	    } else {
		MethodNode newMn = (MethodNode) findMethod(mn).transformMemberNode(mn, this);
		newMethods.add(newMn);
	    }
	}
	cn.methods = newMethods;
    }

    public BodyDecl TypeDecl.findMethod(MethodNode mn) {
	if ( mn.name.equals("<init>")) {
	    // check constructors.
	    for (Iterator cIt = constructors().iterator(); cIt.hasNext(); ) {
		ConstructorDecl cd = (ConstructorDecl) cIt.next();
		if ( cd.isSameMethod(mn)) return cd;
	    }
	} else {
	    for ( Iterator mIt = methodsIterator(); mIt.hasNext(); ) {
		MethodDecl md = (MethodDecl) mIt.next();
		if ( md.isSameMethod(mn)) return md;
	    }
	}
	return null;
    }
    public FieldDeclaration TypeDecl.findField(FieldNode fn) {
	for ( Iterator fIt = fields(fn.name).iterator(); fIt.hasNext(); ) {
	    FieldDeclaration f = (FieldDeclaration) fIt.next();
	    if ( f.getID().equals(fn.name))
		return f;
	}
	return null;
    }

    public boolean ConstructorDecl.isSameMethod(MethodNode mn) {
	return mn.name.equals("<init>")
	    && (mn.signature == null || 
		mn.signature.equals(constructorTypeSignature()));
    }
    public boolean ConstructorDeclSubstituted.isSameMethod(MethodNode mn) {
	return ((ConstructorDecl) getOriginal()).isSameMethod(mn);
    }
    public boolean MethodDecl.isSameMethod(MethodNode mn) {
	return mn.name.equals(getID()) &&
	    (mn.signature == null || 
	     mn.signature.equals(methodTypeSignature()));
    }
    public boolean MethodDeclSubstituted.isSameMethod(MethodNode mn) {
	return ((MethodDecl) getOriginal()).isSameMethod(mn);
    }

    public StaticForMethodDecl TypeDecl.reflectiveMethod(MethodNode mn) {
	Collection rmethods = reflectiveMethods();
	for ( Iterator rmIt = rmethods.iterator(); rmIt.hasNext(); ) {
	    StaticForMethodDecl md = (StaticForMethodDecl) rmIt.next();
	    if ( md.getIteratorDecl().signature().equals(iteratorDeclAttribute(mn)) && mn.name.equals(md.getID()) && 
		 mn.desc.equals(md.descName()) &&
		 mn.signature.equals( md.methodTypeSignature()))
		return md;
	}
	return null;
    }
    
    public static FieldNode TypeDecl.copyFieldNode(FieldNode fn) {
	return new FieldNode(fn.access,
			     fn.name,
			     fn.desc,
			     fn.signature,
			     fn.value);
    }

    public static MethodNode TypeDecl.copyMethodNode(MethodNode mn) {
	MethodNode newNode = new MethodNode();
	newNode.access = mn.access;
	newNode.name = mn.name;
	newNode.desc = mn.desc;
	newNode.signature = mn.signature;
	newNode.exceptions = mn.exceptions;
	newNode.visibleAnnotations = mn.visibleAnnotations;
	newNode.invisibleAnnotations = mn.invisibleAnnotations;
	newNode.attrs = mn.attrs;
	newNode.annotationDefault = mn.annotationDefault;
	newNode.visibleParameterAnnotations = mn.visibleParameterAnnotations;
	newNode.invisibleParameterAnnotations = mn.invisibleParameterAnnotations;
	newNode.instructions = mn.instructions;
	newNode.tryCatchBlocks = mn.tryCatchBlocks;
	newNode.localVariables = mn.localVariables;
	newNode.maxStack = mn.maxStack;
	newNode.maxLocals = mn.maxLocals;
	return newNode;
    }
    
    public String TypeDecl.iteratorDeclAttribute(MemberNode mn) {
	if ( mn.attrs != null ) {
	    for ( Iterator attrIt = mn.attrs.iterator(); attrIt.hasNext(); ) {
		org.objectweb.asm.Attribute a = (org.objectweb.asm.Attribute)attrIt.next();
		if ( a.type.equals("IteratorDecl"))
		    return ((ASMIteratorDeclAttribute) a).signature();
	    }
	}
	return "";
    }

    protected boolean TypeDecl.reflectiveMemberNode(MemberNode mn) {
	return !iteratorDeclAttribute(mn).equals("");
    }

    syn lazy String TypeDecl.expandedConstantPoolName () = constantPoolName();
    eq ParTypeDecl.expandedConstantPoolName () {
    	String cpName = genericDecl().constantPoolName();
	int lastSlash = 	cpName.lastIndexOf('/');
	
	StringBuffer buf = new StringBuffer(cpName.substring(0,lastSlash+1) + 
					    expandedName());
	return buf.toString();
    }
    eq RawClassDecl.expandedConstantPoolName() = genericDecl().expandedConstantPoolName();
    eq RawInterfaceDecl.expandedConstantPoolName() = genericDecl().expandedConstantPoolName();
    eq TypeVariable.expandedConstantPoolName() = getID();
	
    syn lazy String TypeDecl.expandedName() = name();
    eq ParTypeDecl.expandedName() {
	StringBuffer buf = new StringBuffer("$$");
	buf.append(name());
	// $$L for <
	buf.append("$$L");
	for ( int i=0; i<getNumArgument(); i++ ) {
	    TypeDecl argType = getArgument(i).type();
	    buf.append(TypeDecl.convertToExpandedName(argType.expandedConstantPoolName()));
	}	
	// $$R for >
	buf.append("$$R");
	return buf.toString();
    }
    eq RawClassDecl.expandedName() {
	throw new Error("Classes with reflective declarations cannot be " +
			"raw types.");
    }
    eq RawInterfaceDecl.expandedName() {
	throw new Error("Interfaces with reflective declarations cannot be " +
			"raw types.");
    }
    // $$S for /
    protected static String TypeDecl.convertToExpandedName ( String n ) {
	return n.replace("/", "$$S");
    }

    // TODO: not finished.
    syn lazy TypeDecl BodyDecl.parseConstantPoolName(String n) {
	// Package and Type Name
	StringBuffer packageName = new StringBuffer();
	
	int i, last = 0;
	while( (i = n.indexOf("/", last)) > 0 ) {
	    if ( last > 0 )
		packageName.append(".");
	    packageName.append(n.substring(last, i));
	    last = i+1;
	}

	// what's left is the type name.
	String typeName = n.substring(last);

	TypeDecl t = null;

	// if it begins with $$, then it is an expanded constant pool name.
	if ( typeName.startsWith("$$")) {
	    
	} else {
	    /*
	    String[] names = typeName.split("\\$");
	    for(int i = 1; i < names.length; i++)
		t = t.lookupType(names[i]);
	    */
	    // TODO: i don't know if this works with innerclasess.
	    TypeAccess ta = new TypeAccess(packageName.toString(), typeName);
	    //	    this.addDecompiledAccess(ta);
	    //t = lookupType(packageName.toString(), typeName);
	    t = retrieveType(ta);
	    /*
	    if ( packageName.length() == 0) 
		t = (TypeDecl) lookupType(typeName).iterator().next();
	    else
		t = lookupType(packageName.toString(), typeName);
	    */
	}

	return t;
    }
    eq ParStaticForMethodDecl.parseConstantPoolName(String n) = original.parseConstantPoolName(n);
    eq FieldDeclarationSubstituted.parseConstantPoolName(String n) = getOriginal().parseConstantPoolName(n);
    eq MethodDeclSubstituted.parseConstantPoolName(String n) = getOriginal().parseConstantPoolName(n);
    eq ExpandedMethodDecl.parseConstantPoolName(String n) = original.parseConstantPoolName(n);
    eq ConstructorDeclSubstituted.parseConstantPoolName(String n) = getOriginal().parseConstantPoolName(n);
    
    syn lazy TypeDecl BodyDecl.retrieveType(TypeAccess ta) {
	this.addChild(ta);
	TypeDecl t = ta.type();
	
	this.children[numChildren-1] = null;
	this.numChildren = numChildren-1;
	return t;
    }

    eq ConstructorDeclSubstituted.retrieveType(TypeAccess ta) = getOriginal().retrieveType(ta);
    eq MethodDeclSubstituted.retrieveType(TypeAccess ta) = getOriginal().retrieveType(ta);
    eq ExpandedMethodDecl.retrieveType(TypeAccess ta) = original.retrieveType(ta);
    eq FieldDeclarationSubstituted.retrieveType(TypeAccess ta) = getOriginal().retrieveType(ta);

    public List GenericTypeDecl.getParTypeDeclList();

    /**
     * A TypeDecl needs expansion if:
     * - it contains a reflective declaration block
     * - it refers to types that needs expansion but cannot be expanded
     *   i.e. is instantiated with at least one of its type parameters.
     **/
    /*
    syn boolean ASTNode.needsExpansion() circular [false] {
	for ( int i=0; i<getNumChild(); i++) {
	    if ( getChild(i).needsExpansion())
		return true;
	}
	return false;
    }
    */
    syn boolean TypeDecl.needsExpansion() circular [true] {
	// check all body decls.
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if ( getBodyDecl(i).needsExpansion()) return true;
	}
	return false;
    }
    eq ClassDecl.needsExpansion() {
	// TODO: there appears to be a bug is inCircular. An innerclass's
	// superclass's qualifier may not be a type access: e.g.
	// ListItr's superclass Itr has qualifier AbstractCollection<E>,
	// which has type ParTypeAccess, which is not a TypeAccess.
	// Look into this.
	// For now, we only inspect non-nested classes.
	if ( isInnerClass()) return false;

	// check whether superclass and interfaces needs expansion
	if ( hasSuperclass() && superclass().needsExpansion())
	    return true;
	for ( Iterator ifIt = interfacesIterator(); ifIt.hasNext(); ) {
	    if ( ((TypeDecl) ifIt.next()).needsExpansion())
		return true;
	}
	return super.needsExpansion();
    }
    eq InterfaceDecl.needsExpansion() {
	for ( Iterator ifIt = superinterfacesIterator(); ifIt.hasNext(); ) 
	    if ( ((TypeDecl) ifIt.next()).needsExpansion()) return true;
	return super.needsExpansion();
    }
    eq ParTypeDecl.needsExpansion() {
	// check whether the generic decl needs expansion.
	if ( genericDecl().needsExpansion()) {
	    // check whether all type arguments can be expanded.
	    for ( int i=0; i<getNumArgument(); i++) {
		if ( !getArgument(i).type().canbeExpanded())
		    return true;
	    }
	} else {
	    // check whether any of the type arguments needs expansion.
	    for ( int i=0; i<getNumArgument(); i++) {
		if ( getArgument(i).type().needsExpansion() )
		    return true;
	    }
	}
	return false;
    }

    syn boolean BodyDecl.needsExpansion() circular [true] {
	return false;
    }
    eq MethodDecl.needsExpansion() {
	// check return type.
	if ( type().needsExpansion()) return true;
	// check parameters.
	for ( int i=0; i<getNumParameter(); i++) {
	    if ( getParameter(i).type().needsExpansion())
		return true;
	}
	// TODO: check exception.

	// check body
	if ( hasBlock())
	    return getBlock().needsExpansion();
	return false;
    }
    eq StaticForMethodDecl.needsExpansion() {
	if ( getIteratorDecl().needsExpansion()) return true;
	return super.needsExpansion();
    }
    syn boolean IteratorDecl.needsExpansion() circular [true] {
	if ( getPattern().needsExpansion()) return true;
	for ( int i=0; i<getNumNestedPattern(); i++)
	    if ( getNestedPattern(i).needsExpansion())
		return true;
	return false;
    }
    syn boolean Pattern.needsExpansion() circular [true]  =
	getBaseSet().getTypeAccess().type().needsExpansion();

    syn boolean Stmt.needsExpansion() circular [true] {
	return false;
    }
    eq Block.needsExpansion() {
	// check all statements.
	return false;
    }

    syn lazy boolean BodyDecl.isSubstitutedDecl() = false;
    eq FieldDeclarationSubstituted.isSubstitutedDecl() = true;
    eq MethodDeclSubstituted.isSubstitutedDecl() = true;
    eq ConstructorDeclSubstituted.isSubstitutedDecl() = true;
}
