aspect MJLookupMethod {
    /**
     * JastAddJ uses a method signature map to store mappings from 
     * String (method signature) to MethodDecl.  This no longer works
     * for reflectively declared methods. We will keep the statically
     * declared methods the way they are. And use another data structure
     * for reflectively declared methods.
     **/

    syn lazy Collection TypeDecl.reflectiveMethods() {
	Set set = new HashSet();
	for ( int i=0; i<getNumBodyDecl(); i++) {
	    if ( getBodyDecl(i).isReflectiveDecl()  &&
		 getBodyDecl(i) instanceof MethodDecl )
		set.add(getBodyDecl(i));
	}
	return set;
    }
    eq TypeVariable.reflectiveMethods() {
	Set set = new HashSet();
	for ( int i=0; i<getNumTypeBound(); i++) {
	    set.addAll(getTypeBound(i).type().reflectiveMethods());
	}
	return set;
    }
    eq ParTypeDecl.reflectiveMethods() {
	Collection refMethods = genericDecl().reflectiveMethods();
	Set substitutedMethods = new HashSet();
	for ( Iterator rmIt = refMethods.iterator(); rmIt.hasNext(); ) {
	    MethodDecl md = (MethodDecl) rmIt.next();
	    if ( md.usesTypeVariable()) {
		BodyDecl bd = md.p(this);
		bd.is$Final = true;
		addBodyDecl(bd);
		substitutedMethods.add(bd);
	    } else 
		substitutedMethods.add(md);
	}
	return substitutedMethods;
    }


    refine LookupMethod eq ClassDecl.interfacesMethodsSignatureMap() {
	HashMap map = new HashMap();
	for(Iterator iter = interfacesIterator(); iter.hasNext(); ) {
	    TypeDecl typeDecl = (TypeDecl)iter.next();
	    for(Iterator i2 = typeDecl.methodsIterator(); i2.hasNext(); ) {
		MethodDecl m = (MethodDecl)i2.next();
		putSimpleSetElement(map, m.signature(), m);
	    }
	}
	return map;
    }

    protected StaticForMethodDecl StaticForMethodDecl.original;
    syn StaticForMethodDecl StaticForMethodDecl.original() = original != null ? original : this;

    HashMap StaticForMethodDecl.parMethodDeclMap = new HashMap();

    public BodyDecl StaticForMethodDecl.p(ParTypeDecl parTypeDecl) {
	// check that this substitution doesn't already exist.
	if ( parMethodDeclMap.get(parTypeDecl) != null)
	    return (BodyDecl) parMethodDeclMap.get(parTypeDecl);
	
	// TODO: this is not good enough for generic methods.
	// Might need a StaticForGenericMethodDecl...
	// What I really need is for StaticForMethodDecl to be a proxy for
	// the underlying MethodDecl. But it is simply too hard to duplicate
	// all the functionalities in MethodDecl.
	// May be a nice functionality for JastAdd.
	ParStaticForMethodDecl m = 
	    new ParStaticForMethodDecl((Modifiers)getModifiers().fullCopy(), 
				       getTypeAccess().type().substituteReturnType(parTypeDecl),
				       getID(),
				       getParameterList().substitute(parTypeDecl),
				       new List(),
				       getExceptionList().substitute(parTypeDecl),
				       new Opt(),
				       getIteratorDecl().substitute(parTypeDecl),
				       new List(), new List());
	m.original = this;

	m.is$Final = true;
	((TypeDecl)parTypeDecl).addBodyDecl(m);

	parMethodDeclMap.put(parTypeDecl, m);

	return m;
    }

    public IteratorDecl IteratorDecl.substitute(ParTypeDecl parTypeDecl) {
	ParIteratorDecl pid = 
	    new ParIteratorDecl(getPatternTypeParameterList(),
				getPatternNameParameterList(),
				getPattern().substitute(parTypeDecl), getNestedPatternList().substitute(parTypeDecl));
	
	pid.original = this;
	return pid;
    }

    public IteratorDecl ParIteratorDecl.original;

    public Pattern Pattern.substitute(ParTypeDecl parTypeDecl) {
	return new Pattern(getTypeAccess().type().substitute(parTypeDecl),
			   getID(),
			   getParameterList().substitute(parTypeDecl),
			   new List(),
			   getExceptionList().substitute(parTypeDecl),
			   getBaseSet().substitute(parTypeDecl));
    }
    public NestedPattern NestedPattern.substitute(ParTypeDecl parTypeDecl) {
	return new NestedPattern(getTypeAccess().type().substitute(parTypeDecl),
				 getID(),
				 getParameterList().substitute(parTypeDecl),
				 new List(),
				 getExceptionList().substitute(parTypeDecl),
				 getBaseSet().substitute(parTypeDecl),
				 getIsPositive());
    }

    public BaseSet BaseSet.substitute(ParTypeDecl parTypeDecl) {
	return new BaseSet(getTypeAccess().type().substitute(parTypeDecl),
			   (RefElmt) getRefElmt().fullCopy());
    }

    // Modify how methods are retrieved.
    refine LookupMethod eq AbstractDot.getRight().lookupMethod(String name) {
	if ( isNameVariable(name)) 
	    return getLeft().type().memberMethods(getNameVariable(name));
	return LookupMethod.AbstractDot.getRight().lookupMethod(name);
    }

    syn Collection TypeDecl.memberMethods(PatternNameVariable name) = Collections.EMPTY_LIST;

    eq TypeVariable.memberMethods(PatternNameVariable name) {
	Collection methods = new ArrayList();

	if ( name.reflectiveBaseType() == this ) 
	    // If the name is exactly what is used to match on the outermost
	    // reflective loop, then the method designated by the name is
	    // exactly what is specified by the pattern.
	    methods.add(name.enclosingRefIterator().getPattern().patternMethodDecl());
	else if ( false ) {
	    // TODO
	    // otherwise, if :
	    // 1. the type is the reflective base type for a nested pattern, AND
	    // 2. name is the name variable used in the nested pattern, AND
	    // 3. the nested pattern is guaranteed to have a range of exactly one.
	    // then again the method is what's specified by the nested pattern.

	} else {
	    // look into bounds.
	    for ( int i=0; i<getNumTypeBound(); i++) {
		methods.addAll(getTypeBound(i).type().memberMethods(name));
	    }
	}
	return methods;
    }
	
    syn lazy HashMap TypeDecl.allStaticMethodsMap() = methodsSignatureMap();

    eq ClassDecl.allStaticMethodsMap() {
	HashMap allMethods = super.allStaticMethodsMap();
	
	// get all the reflective methods, expanded.
	Collection refMethods = reflectiveMethods();
	for (Iterator refIt = refMethods.iterator(); refIt.hasNext(); ) {
	    StaticForMethodDecl m = (StaticForMethodDecl) refIt.next();
	    List expandedMethods = m.expandedMethods();
	    for ( int i=0; i<expandedMethods.getNumChild(); i++) {
		MethodDecl md = (MethodDecl) expandedMethods.getChild(i);
		if ( !allMethods.containsKey(md.signature()))
		    putSimpleSetElement(allMethods, md.signature(), md);
	    }
	}
	return allMethods;
    }

    public ExpandedMethodDecl StaticForMethodDecl.substitute(Map substitution) {
	return new ExpandedMethodDecl((Modifiers) getModifiers().fullCopy(),
				      getTypeAccess().type().substitute(substitution),
				      isNameVariable(getID()) ?
				      (String) substitution.get(getNameVariable(getID())) : getID(),
				      getParameterList().substitute(substitution),
				      new List(),
				      getExceptionList().substitute(substitution),
				      new Opt());
    }

    public NestedPattern NestedPattern.substitute(Map substitutions) {
	return new NestedPattern(getTypeAccess().type().substitute(substitutions),
				 isNameVariable(getID()) ? 
				 (String) substitutions.get(getNameVariable(getID())) : getID(),
				 getParameterList().substitute(substitutions),
				 new List(),
				 getExceptionList().substitute(substitutions),
				 getBaseSet().substitute(substitutions),
				 getIsPositive());	
    }

    public BaseSet BaseSet.substitute(Map substitutions) {
	return new BaseSet(getTypeAccess().type().substitute(substitutions), getRefElmt());
    }

    public List List.substitute(Map submap) {
	List list = new List();
	for ( int i=0; i<getNumChild(); i++) {
	    ASTNode node = getChild(i);
	    if ( node instanceof Access)
		list.add(((Access) node).type().substitute(submap));
	    else
		throw new Error("Can only substitute lists of access nodes but node number " + i + " is of type " + node.getClass().getName());
	}
	return list;
    }

    public Access TypeDecl.substitute(Map submap) {
	return createBoundAccess();
    }
    public Access TypeVariable.substitute(Map submap) {
	if ( submap.containsKey(this))
	    return ((TypeDecl) submap.get(this)).createBoundAccess();
	return createBoundAccess();
    }
    public Access ParTypeDecl.substitute(Map submap) {
	java.util.ArrayList list = new java.util.ArrayList();
	for ( int i=0; i<getNumArgument(); i++) 
	    list.add(getArgument(i).type().substitute(submap));
	return ((GenericTypeDecl) genericDecl()).lookupParTypeDecl(list).createBoundAccess();
    }

}

aspect MJMethodsExpansion {

    /**
     * A TypeDecl can be expanded if it is completely grounded.
     **/
    syn lazy boolean ASTNode.canbeExpanded() circular [false] = true;
    eq ParTypeDecl.canbeExpanded() {
	if ( genericDecl().needsExpansion()) {
	    for ( int i=0; i<getNumArgument(); i++) {
		if ( !getArgument(i).type().grounded())
		    return false;
	    } 	    
	} else 
	    for ( int i=0; i<getNumArgument(); i++) {
		if ( !getArgument(i).type().canbeExpanded())
		    return false;
	    } 
	return true;
    }
    
    // determine whether a type is grounded.
    syn lazy boolean TypeDecl.grounded() = true;
    eq TypeVariable.grounded() = false;
    eq ParClassDecl.grounded() {
	for ( int i=0; i<getNumArgument(); i++) {
	    if ( !getArgument(i).type().grounded())
		return false;
	} 
	return true;
    }
    eq ParInterfaceDecl.grounded() {
	for ( int i=0; i<getNumArgument(); i++) {
	    if ( !getArgument(i).type().grounded())
		return false;
	}
	return true;
    }

    syn lazy List MethodDecl.expandedMethods () = new List().add(this);

    eq ParStaticForMethodDecl.expandedMethods() {
	ParTypeDecl ht = (ParTypeDecl) hostType();
	GenericTypeDecl gtd = (GenericTypeDecl) ht.genericDecl();
	    
	IteratorDecl id = getIteratorDecl();

	// get the mappings for each element in the iterator decl's range. 
	for ( Iterator subMaps = id.reflectiveElmts().values().iterator();
	      subMaps.hasNext(); ) {
	    Map substitutions = (Map) subMaps.next();

	    // put into the map the parameterization from this
	    for ( int i=0; i<gtd.getNumTypeParameter(); i++) {
		substitutions.put(gtd.getTypeParameter(i),
				  ht.getArgument(i).type());
	    }

	    ExpandedMethodDecl md = substitute(substitutions);
	    md.expansionSubstitutions = substitutions;
	    md.original = this; //this.original;

	    md.is$Final = true;
	    addExpandedMethodDecl(md);
	}

	return getExpandedMethodDeclList();
    }

    public Map MethodDecl.expansionSubstitutions = null;
    public StaticForMethodDecl ExpandedMethodDecl.original = null;


    // A map from elements in the reflective range to the mappings 
    // resulting from the pattern variables to the concrete values in
    // the element.
    syn Map IteratorDecl.reflectiveElmts() {
	throw new Error("Cannot get reflective elemets for a " +
			    "reflective iterator when the base type is " +
			    "not grounded");
    }

    eq ParIteratorDecl.reflectiveElmts() {
	// in order to call this, base type must be fully grounded.
	if ( !getPattern().getBaseSet().getTypeAccess().type().canbeExpanded())
	    // this should never happen.
	    throw new Error("Cannot return the reflective elements of a " +
			    "reflective iterator when the base type is " +
			    "not grounded");
	
	Map refElmtsMap = new HashMap();

	if ( getPattern().getBaseSet().iterateMethods()) {
	    Map methods = getPattern().getBaseSet().type().allStaticMethodsMap();
	    // find all methods that fall into the range of this
	    // iterator decl.
	    for ( Iterator mIt = methods.values().iterator(); 
		  mIt.hasNext(); ) {
		MethodDecl md = (MethodDecl) mIt.next();
		HashMap map = new HashMap();

		if ( md.isSubsumedBy(this, map))
		    refElmtsMap.put(md, map);
	    }
	} else {
	    // iterate over fields.
	}

	return refElmtsMap;
    }

    syn lazy boolean BaseSet.iterateMethods () = getRefElmt().getElmtName().equals("methods");
    syn lazy boolean BaseSet.iterateFields () = getRefElmt().getElmtName().equals("fields");

}

aspect MJLookupConstructor {

    boolean ConstrainedTypeVariable.usedAsSupertype = false;
    public boolean ConstrainedTypeVariable.usedAsSupertype() {
	return usedAsSupertype; 
    }
    public void ConstrainedTypeVariable.setUsedAsSupertype(boolean p) {
	usedAsSupertype = p;
    }


    // A constrained TypeVariable used as a supertype must not be final.
    eq ConstrainedTypeVariable.isFinal() = 
	usedAsSupertype ? false : super.isFinal() ;

    // Add a default constructor to a TypeVariable constrained to be a class. 
    eq ConstrainedTypeVariable.constructors() {
	if ( getConstraint().equals("class")) {
	    ConstructorDecl cd = new ConstructorDecl(new Modifiers(new List().add(new Modifier("public"))), typeName(), new List(), new List(), new Opt(), new Block());
	    addBodyDecl(cd);
	    cd.is$Final = true;
	    cd.bypassErrorChecking = true;

	    Collection c = new ArrayList();
	    c.add(cd);
	    return c;
	}
	return super.constructors();
    }

    // TODO: what about super constructor?  any?
}
