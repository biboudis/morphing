package AST;

aspect StaticFor {

    eq StaticForDecl.isStatic() = true;

    interface StaticForDeclaration {
	IteratorDecl getIteratorDecl();
	public ASTNode setEnd(int i);
	public ASTNode setStart(int i);
    }
    StaticForMethodDecl implements StaticForDeclaration;
    StaticForFieldDeclaration implements StaticForDeclaration;
    StaticForConstructorDecl implements StaticForDeclaration;

    // StaticForDecl may have multiple body decl's. Rewrite to a list
    // of StaticForDeclaration
    rewrite StaticForDecl in TypeDecl.getBodyDecl() {
	when ( getNumBodyDecl() > 1 ) 
	    to List {
	    List declList = new List();
	    for ( int i=0; i<getNumBodyDecl(); i++) {
		declList.addChild((ASTNode) getBodyDecl(i).createStaticForDeclarationFrom((IteratorDecl) getIteratorDecl().fullCopy()));
	    }
	    return declList;
	}
    }
    
    // StaticForDecl with single BodyDecl -> StaticForDeclaration.
    rewrite StaticForDecl {
	when ( getNumBodyDecl() == 1 )
	    to ASTNode {
	    StaticForDeclaration decl = getBodyDecl(0).createStaticForDeclarationFrom(getIteratorDecl());
	    decl.setStart(start);
	    decl.setEnd(end);
	    return (ASTNode) decl;
	}
    }

    public StaticForDeclaration BodyDecl.createStaticForDeclarationFrom(IteratorDecl id) {
	throw new Error("Cannot create StaticForDeclaration for " +
			getClass().getName());
    }
    public StaticForDeclaration ConstructorDecl.createStaticForDeclarationFrom(IteratorDecl id) {
	return new StaticForConstructorDecl(getModifiers(), getID(), getParameterList(), getExceptionList(), getConstructorInvocationOpt(), getBlock(), id);
    }
    public StaticForDeclaration MethodDecl.createStaticForDeclarationFrom(IteratorDecl id) {
	return new StaticForMethodDecl(getModifiers(), getTypeAccess(), getID(), getParameterList(), getEmptyBracketList(), getExceptionList(), getBlockOpt(), id);
    }
    public StaticForDeclaration FieldDeclaration.createStaticForDeclarationFrom(IteratorDecl id) {
	return new StaticForFieldDeclaration(getModifiers(), getTypeAccess(), getID(), getInitOpt(), id);
    }

    // TODO: MemberClassDecl, MemberInterfaceDecl, StaticInitializer
    

    public void PatternNameVariable.toString(StringBuffer s) {
	s.append(getID());
    }
    public void Pattern.toString(StringBuffer s) {
	getTypeAccess().toString(s);
	s.append(" " + getID() + "(");

	if(getNumParameter() > 0) {
	    getParameter(0).toString(s);
	    for(int i = 1; i < getNumParameter(); i++) {
		s.append(", ");
		getParameter(i).toString(s);
	    }
	}
	s.append(")");	    
	for(int i = 0; i < getNumEmptyBracket(); i++) {
	    s.append("[]");
	}
	if(getNumException() > 0) {
	    s.append(" throws ");
	    getException(0).toString(s);
	    for(int i = 1; i < getNumException(); i++) {
		s.append(", ");
		getException(i).toString(s);
	    }
	}

	s.append(" : ");
	getBaseSet().toString(s);
    }

    public void BaseSet.toString(StringBuffer s) {
	getTypeAccess().toString(s);
	s.append(".");
	getRefElmt().toString(s);
    }

    public void RefElmt.toString(StringBuffer s) {
	s.append(getElmtName());
    }

    syn TypeDecl BaseSet.baseType() = getTypeAccess().type();
}
